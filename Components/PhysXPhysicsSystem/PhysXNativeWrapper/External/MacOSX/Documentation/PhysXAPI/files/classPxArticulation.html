<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxArticulation Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxArticulation Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxArticulation" --><!-- doxytag: inherits="PxSerializable" -->a tree structure of bodies connected by joints that is treated as a unit by the dynamics solver  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxArticulation_8h-source.html">PxArticulation.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxArticulation:</div>
<div class="dynsection">
<p><center><img src="classPxArticulation__inherit__graph.png" border="0" usemap="#PxArticulation__inherit__map" alt="Inheritance graph"></center>
<map name="PxArticulation__inherit__map">
<area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="5,5,112,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxArticulation:</div>
<div class="dynsection">
<p><center><img src="classPxArticulation__coll__graph.png" border="0" usemap="#PxArticulation__coll__map" alt="Collaboration graph"></center>
<map name="PxArticulation__coll__map">
<area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="84,96,191,123"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxSerialFlag::Enum, PxU16 \&gt;" alt="" coords="6,5,270,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxArticulation-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#05473039f1bd3bb20f824be6ae5aa435">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the articulation.  <a href="#05473039f1bd3bb20f824be6ae5aa435"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#fd299e63283d38910c48243e6d9755dd">getScene</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene which this articulation belongs to.  <a href="#fd299e63283d38910c48243e6d9755dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#4154ccfb1afad6e3b8145a67e7f580bd">setMaxProjectionIterations</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> iterations)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets maxProjectionIterations.  <a href="#4154ccfb1afad6e3b8145a67e7f580bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#f3685ff6164f06bec07499a0d1b0336a">getMaxProjectionIterations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets maxProjectionIterations.  <a href="#f3685ff6164f06bec07499a0d1b0336a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#284072a943c7e9caa992c513e0855aaf">setSeparationTolerance</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> tolerance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets separationTolerance.  <a href="#284072a943c7e9caa992c513e0855aaf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#cacffbf3e5e6e2e02e8b0929e9b73cf6">getSeparationTolerance</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets separationTolerance.  <a href="#cacffbf3e5e6e2e02e8b0929e9b73cf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#cda14790e09cb759007038d35885065a">setInternalDriveIterations</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> iterations)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the number of iterations used to compute the drive response to internal forces  <a href="#cda14790e09cb759007038d35885065a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#6d02a86ad795aaed3e1a2dc6a3d49762">getInternalDriveIterations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets internal driveIterations.  <a href="#6d02a86ad795aaed3e1a2dc6a3d49762"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#767fb3ec58b891bcd8dd0d769a5789cf">setExternalDriveIterations</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> iterations)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the number of iterations for drive response to external forces.  <a href="#767fb3ec58b891bcd8dd0d769a5789cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#563b2f0279522377f86d7947d790e31f">getExternalDriveIterations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets externalDriveIterations.  <a href="#563b2f0279522377f86d7947d790e31f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#f31eb23f85c5a8516612cad455d4fef3">setSolverIterationCounts</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> minPositionIters, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> minVelocityIters=1)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the solver iteration counts for the articulation.  <a href="#f31eb23f85c5a8516612cad455d4fef3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#895c71778bd0ec8905719f507e0a966f">getSolverIterationCounts</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;minPositionIters, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;minVelocityIters) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the solver iteration counts.  <a href="#895c71778bd0ec8905719f507e0a966f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df">isSleeping</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this articulation is sleeping.  <a href="#2ab9a560f94ce01b499fedff8f54a9df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#e7e4735b8c23aaf5f41d829208cccce6">setSleepThreshold</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> threshold)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass-normalized energy threshold below which an articulation may go to sleep.  <a href="#e7e4735b8c23aaf5f41d829208cccce6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#9e7f831e514e0de1c15812f62c0ab20b">getSleepThreshold</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the mass-normalized energy below which an articulation may go to sleep.  <a href="#9e7f831e514e0de1c15812f62c0ab20b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#2e849888d2b521d9d20dd5a008e955f3">wakeUp</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> wakeCounterValue=PX_SLEEP_INTERVAL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wakes up the articulation if it is sleeping.  <a href="#2e849888d2b521d9d20dd5a008e955f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#b7da60ba6a4a5b7068115dc79a545b73">putToSleep</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forces the articulation to sleep.  <a href="#b7da60ba6a4a5b7068115dc79a545b73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#5e2777634f2b482e7366fb7649834c37">createLink</a> (<a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *parent, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds a link to the articulation with default attribute values.  <a href="#5e2777634f2b482e7366fb7649834c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#c5de09243fe7491e92bf7720cba35782">getNbLinks</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the number of links in the articulation  <a href="#c5de09243fe7491e92bf7720cba35782"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#4d17df3ebac94afe4beedd7871e4d157">getLinks</a> (<a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the set of links in the articulation  <a href="#4d17df3ebac94afe4beedd7871e4d157"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#1efa57c3102cb6258ee90ac70a3c2657">setName</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxArticulation.html#e10c600444771ea7e29d531b84f3c734" title="Retrieves the name string set with setName().">getName()</a>.  <a href="#1efa57c3102cb6258ee90ac70a3c2657"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#e10c600444771ea7e29d531b84f3c734">getName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classPxArticulation.html#1efa57c3102cb6258ee90ac70a3c2657" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <a href="#e10c600444771ea7e29d531b84f3c734"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#5d0f508bf685bdd4b3130492308c165f">getWorldBounds</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the articulation.  <a href="#5d0f508bf685bdd4b3130492308c165f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#b8c30bf0858be5f35f5e18c10e19ea85">getAggregate</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the aggregate the articulation might be a part of.  <a href="#b8c30bf0858be5f35f5e18c10e19ea85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PxArticulationDriveCache *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#795fd4cd7bb40e05c9e9bfd6f0d73a70">createDriveCache</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> compliance, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> driveIterations) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a drive cache for applying impulses which are propagated to the entire articulation  <a href="#795fd4cd7bb40e05c9e9bfd6f0d73a70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#da8e885a5ea020e2b41be20d6c202f26">releaseDriveCache</a> (PxArticulationDriveCache &amp;driveCache) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">release a drive cache  <a href="#da8e885a5ea020e2b41be20d6c202f26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#29fd49597cee46481679988e3ace38a5">applyImpulse</a> (<a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *link, const PxArticulationDriveCache &amp;driveCache, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linearImpulse, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angularImpulse)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">apply an impulse to an entire articulation  <a href="#29fd49597cee46481679988e3ace38a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#bfe3887e17be7b04d71a7d21c96c181d">computeImpulseResponse</a> (<a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *link, <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linearResponse, <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angularResponse, const PxArticulationDriveCache &amp;driveCache, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linearImpulse, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angularImpulse) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">determine the effect of applying an impulse to an entire articulation, without applying the impulse  <a href="#bfe3887e17be7b04d71a7d21c96c181d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#7cbe2a99ed02a02156011a69d4830355">getConcreteTypeName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns string name of dynamic type.  <a href="#7cbe2a99ed02a02156011a69d4830355"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#d292404f71931e4e465bfe7581c2aa1e">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#d292404f71931e4e465bfe7581c2aa1e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#fb20bef717acc399402e9d89df4eb6df">PxArticulation</a> (<a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#40b1a0e20776a863c0f82ecd48527d58">PxArticulation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#30d90e77b54c18880636629aea545ac3">~PxArticulation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxArticulation.html#ebd44e6ecdffe21d718935245277e55a">isKindOf</a> (const char *name) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
a tree structure of bodies connected by joints that is treated as a unit by the dynamics solver 
<p>
Articulations are more expensive to simulate than the equivalent collection of <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> and <a class="el" href="classPxJoint.html" title="a base interface providing common functionality for PhysX joints">PxJoint</a> structures, but because the dynamics solver treats each articulation as a single object, they are much less prone to separation and have better support for actuation.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulationJoint.html" title="a joint between two links in an articulation.">PxArticulationJoint</a> <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fb20bef717acc399402e9d89df4eb6df"></a><!-- doxytag: member="PxArticulation::PxArticulation" ref="fb20bef717acc399402e9d89df4eb6df" args="(PxRefResolver &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxArticulation::PxArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="40b1a0e20776a863c0f82ecd48527d58"></a><!-- doxytag: member="PxArticulation::PxArticulation" ref="40b1a0e20776a863c0f82ecd48527d58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxArticulation::PxArticulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="30d90e77b54c18880636629aea545ac3"></a><!-- doxytag: member="PxArticulation::~PxArticulation" ref="30d90e77b54c18880636629aea545ac3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxArticulation::~PxArticulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="29fd49597cee46481679988e3ace38a5"></a><!-- doxytag: member="PxArticulation::applyImpulse" ref="29fd49597cee46481679988e3ace38a5" args="(PxArticulationLink *link, const PxArticulationDriveCache &amp;driveCache, const PxVec3 &amp;linearImpulse, const PxVec3 &amp;angularImpulse)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::applyImpulse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxArticulationDriveCache &amp;&nbsp;</td>
          <td class="paramname"> <em>driveCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>linearImpulse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angularImpulse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
apply an impulse to an entire articulation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>link</em>&nbsp;</td><td>the link to which to apply the impulse </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>driveCache</em>&nbsp;</td><td>the drive cache </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linearImpulse</em>&nbsp;</td><td>the linear impulse to apply </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angularImpulse</em>&nbsp;</td><td>the angular impulse to apply</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#bfe3887e17be7b04d71a7d21c96c181d" title="determine the effect of applying an impulse to an entire articulation, without applying...">computeImpulseResponse</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this call may only be made on articulations that are in a scene, and may not be made during simulation </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfe3887e17be7b04d71a7d21c96c181d"></a><!-- doxytag: member="PxArticulation::computeImpulseResponse" ref="bfe3887e17be7b04d71a7d21c96c181d" args="(PxArticulationLink *link, PxVec3 &amp;linearResponse, PxVec3 &amp;angularResponse, const PxArticulationDriveCache &amp;driveCache, const PxVec3 &amp;linearImpulse, const PxVec3 &amp;angularImpulse) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::computeImpulseResponse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>linearResponse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angularResponse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxArticulationDriveCache &amp;&nbsp;</td>
          <td class="paramname"> <em>driveCache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>linearImpulse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angularImpulse</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
determine the effect of applying an impulse to an entire articulation, without applying the impulse 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>link</em>&nbsp;</td><td>the link to which to apply the impulse </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>linearResponse</em>&nbsp;</td><td>the change in linear velocity of the articulation link </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>angularResponse</em>&nbsp;</td><td>the change in angular velocity of the articulation link </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>driveCache</em>&nbsp;</td><td>the drive cache </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linearImpulse</em>&nbsp;</td><td>the linear impulse to apply </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angularImpulse</em>&nbsp;</td><td>the angular impulse to apply</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#29fd49597cee46481679988e3ace38a5" title="apply an impulse to an entire articulation">applyImpulse</a></dd></dl>
This call will wake up the articulation if it is asleep.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this call may only be made on articulations that are in a scene, and may not be made during simulation </dd></dl>

</div>
</div><p>
<a class="anchor" name="795fd4cd7bb40e05c9e9bfd6f0d73a70"></a><!-- doxytag: member="PxArticulation::createDriveCache" ref="795fd4cd7bb40e05c9e9bfd6f0d73a70" args="(PxReal compliance, PxU32 driveIterations) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxArticulationDriveCache* PxArticulation::createDriveCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>compliance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>driveIterations</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create a drive cache for applying impulses which are propagated to the entire articulation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>compliance</em>&nbsp;</td><td>the compliance value to use at all joints of the articulation. This is equivalent to the external compliance parameter for articulation joints, as the impulse is treated as an external force </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>driveIterations</em>&nbsp;</td><td>the number of iterations to use to evaluate the drive strengths</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a drive cache</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#da8e885a5ea020e2b41be20d6c202f26" title="release a drive cache">releaseDriveCache</a> <a class="el" href="classPxArticulation.html#29fd49597cee46481679988e3ace38a5" title="apply an impulse to an entire articulation">applyImpulse</a> <a class="el" href="classPxArticulation.html#bfe3887e17be7b04d71a7d21c96c181d" title="determine the effect of applying an impulse to an entire articulation, without applying...">computeImpulseResponse</a></dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>this call may only be made on articulations that are in a scene, and may not be made during simulation </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e2777634f2b482e7366fb7649834c37"></a><!-- doxytag: member="PxArticulation::createLink" ref="5e2777634f2b482e7366fb7649834c37" args="(PxArticulationLink *parent, const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxArticulationLink.html">PxArticulationLink</a>* PxArticulation::createLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
adds a link to the articulation with default attribute values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>parent</em>&nbsp;</td><td>the parent link of the articulation. Should be NULL if (and only if) this is the root link </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>the pose of the new link</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new link, or NULL if the link cannot be created because the articulation has reached its maximum link count</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxsArticulationLink </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8c30bf0858be5f35f5e18c10e19ea85"></a><!-- doxytag: member="PxArticulation::getAggregate" ref="b8c30bf0858be5f35f5e18c10e19ea85" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a>* PxArticulation::getAggregate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the aggregate the articulation might be a part of. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The aggregate the articulation is a part of, or NULL if the articulation does not belong to an aggregate.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7cbe2a99ed02a02156011a69d4830355"></a><!-- doxytag: member="PxArticulation::getConcreteTypeName" ref="7cbe2a99ed02a02156011a69d4830355" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxArticulation::getConcreteTypeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns string name of dynamic type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>class name of most derived type of this object. </dd></dl>

<p>Reimplemented from <a class="el" href="classPxSerializable.html#2a5e41e56b01a2113bb2a9fed0ad0795">PxSerializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="563b2f0279522377f86d7947d790e31f"></a><!-- doxytag: member="PxArticulation::getExternalDriveIterations" ref="563b2f0279522377f86d7947d790e31f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxArticulation::getExternalDriveIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
gets externalDriveIterations. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of iterations used to compute the drive response to external forces</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#767fb3ec58b891bcd8dd0d769a5789cf" title="sets the number of iterations for drive response to external forces.">setExternalDriveIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d02a86ad795aaed3e1a2dc6a3d49762"></a><!-- doxytag: member="PxArticulation::getInternalDriveIterations" ref="6d02a86ad795aaed3e1a2dc6a3d49762" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxArticulation::getInternalDriveIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
gets internal driveIterations. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of iterations used to compute the drive response to internal forces</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#cda14790e09cb759007038d35885065a" title="sets the number of iterations used to compute the drive response to internal forces...">setInternalDriveIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d17df3ebac94afe4beedd7871e4d157"></a><!-- doxytag: member="PxArticulation::getLinks" ref="4d17df3ebac94afe4beedd7871e4d157" args="(PxArticulationLink **userBuffer, PxU32 bufferSize) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxArticulation::getLinks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulationLink.html">PxArticulationLink</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the set of links in the articulation 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>buffer into which to write an array of articulation link pointers </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>the size of the buffer. If this is not large enough to contain all the pointers to links, only as many as will fit are written.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of links written into the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxsArticulationLink </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3685ff6164f06bec07499a0d1b0336a"></a><!-- doxytag: member="PxArticulation::getMaxProjectionIterations" ref="f3685ff6164f06bec07499a0d1b0336a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxArticulation::getMaxProjectionIterations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
gets maxProjectionIterations. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of projection iterations</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#4154ccfb1afad6e3b8145a67e7f580bd" title="sets maxProjectionIterations.">setMaxProjectionIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e10c600444771ea7e29d531b84f3c734"></a><!-- doxytag: member="PxArticulation::getName" ref="e10c600444771ea7e29d531b84f3c734" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxArticulation::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the name string set with <a class="el" href="classPxArticulation.html#1efa57c3102cb6258ee90ac70a3c2657" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Name string associated with object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#1efa57c3102cb6258ee90ac70a3c2657" title="Sets a name string for the object that can be retrieved with getName().">setName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5de09243fe7491e92bf7720cba35782"></a><!-- doxytag: member="PxArticulation::getNbLinks" ref="c5de09243fe7491e92bf7720cba35782" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxArticulation::getNbLinks           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the number of links in the articulation 
<p>

</div>
</div><p>
<a class="anchor" name="fd299e63283d38910c48243e6d9755dd"></a><!-- doxytag: member="PxArticulation::getScene" ref="fd299e63283d38910c48243e6d9755dd" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxScene.html">PxScene</a>* PxArticulation::getScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene which this articulation belongs to. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Owner Scene. NULL if not part of a scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cacffbf3e5e6e2e02e8b0929e9b73cf6"></a><!-- doxytag: member="PxArticulation::getSeparationTolerance" ref="cacffbf3e5e6e2e02e8b0929e9b73cf6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxArticulation::getSeparationTolerance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
gets separationTolerance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the separation tolerance</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#284072a943c7e9caa992c513e0855aaf" title="sets separationTolerance.">setSeparationTolerance()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e7f831e514e0de1c15812f62c0ab20b"></a><!-- doxytag: member="PxArticulation::getSleepThreshold" ref="9e7f831e514e0de1c15812f62c0ab20b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxArticulation::getSleepThreshold           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the mass-normalized energy below which an articulation may go to sleep. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The energy threshold for sleeping.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df" title="Returns true if this articulation is sleeping.">isSleeping()</a> <a class="el" href="classPxArticulation.html#2e849888d2b521d9d20dd5a008e955f3" title="Wakes up the articulation if it is sleeping.">wakeUp()</a> <a class="el" href="classPxArticulation.html#b7da60ba6a4a5b7068115dc79a545b73" title="Forces the articulation to sleep.">putToSleep()</a> <a class="el" href="classPxArticulation.html#e7e4735b8c23aaf5f41d829208cccce6" title="Sets the mass-normalized energy threshold below which an articulation may go to sleep...">setSleepThreshold()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="895c71778bd0ec8905719f507e0a966f"></a><!-- doxytag: member="PxArticulation::getSolverIterationCounts" ref="895c71778bd0ec8905719f507e0a966f" args="(PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::getSolverIterationCounts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>minVelocityIters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the solver iteration counts. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#f31eb23f85c5a8516612cad455d4fef3" title="Sets the solver iteration counts for the articulation.">setSolverIterationCounts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d0f508bf685bdd4b3130492308c165f"></a><!-- doxytag: member="PxArticulation::getWorldBounds" ref="5d0f508bf685bdd4b3130492308c165f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a> PxArticulation::getWorldBounds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the axis aligned bounding box enclosing the articulation. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The articulation's bounding box.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box.">PxBounds3</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebd44e6ecdffe21d718935245277e55a"></a><!-- doxytag: member="PxArticulation::isKindOf" ref="ebd44e6ecdffe21d718935245277e55a" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxArticulation::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classPxSerializable.html#6b6d98ad5d2dd045de560930c3789415">PxSerializable</a>.</p>

<p>References <a class="el" href="PxSerialFramework_8h-source.html#l00572">PxSerializable::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ab9a560f94ce01b499fedff8f54a9df"></a><!-- doxytag: member="PxArticulation::isSleeping" ref="2ab9a560f94ce01b499fedff8f54a9df" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxArticulation::isSleeping           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this articulation is sleeping. 
<p>
When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.<p>
If an articulation is asleep after the call to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">PxScene::fetchResults()</a> returns, it is guaranteed that the poses of the links were not changed. You can use this information to avoid updating the transforms of associated of dependent objects.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the articulation is sleeping.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df" title="Returns true if this articulation is sleeping.">isSleeping()</a> <a class="el" href="classPxArticulation.html#2e849888d2b521d9d20dd5a008e955f3" title="Wakes up the articulation if it is sleeping.">wakeUp()</a> <a class="el" href="classPxArticulation.html#b7da60ba6a4a5b7068115dc79a545b73" title="Forces the articulation to sleep.">putToSleep()</a> <a class="el" href="classPxArticulation.html#9e7f831e514e0de1c15812f62c0ab20b" title="Returns the mass-normalized energy below which an articulation may go to sleep.">getSleepThreshold()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7da60ba6a4a5b7068115dc79a545b73"></a><!-- doxytag: member="PxArticulation::putToSleep" ref="b7da60ba6a4a5b7068115dc79a545b73" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::putToSleep           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forces the articulation to sleep. 
<p>
The articulation will stay asleep during the next simulation step if not touched by another non-sleeping actor.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This will set the velocity of all bodies in the articulation to zero.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df" title="Returns true if this articulation is sleeping.">isSleeping()</a> <a class="el" href="classPxArticulation.html#2e849888d2b521d9d20dd5a008e955f3" title="Wakes up the articulation if it is sleeping.">wakeUp()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="05473039f1bd3bb20f824be6ae5aa435"></a><!-- doxytag: member="PxArticulation::release" ref="05473039f1bd3bb20f824be6ae5aa435" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the articulation. 
<p>
Do not keep a reference to the deleted instance.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxScene::createArticulation() </dd></dl>

</div>
</div><p>
<a class="anchor" name="da8e885a5ea020e2b41be20d6c202f26"></a><!-- doxytag: member="PxArticulation::releaseDriveCache" ref="da8e885a5ea020e2b41be20d6c202f26" args="(PxArticulationDriveCache &amp;driveCache) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::releaseDriveCache           </td>
          <td>(</td>
          <td class="paramtype">PxArticulationDriveCache &amp;&nbsp;</td>
          <td class="paramname"> <em>driveCache</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
release a drive cache 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>driveCache</em>&nbsp;</td><td>the drive cache to release</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#795fd4cd7bb40e05c9e9bfd6f0d73a70" title="create a drive cache for applying impulses which are propagated to the entire articulation...">createDriveCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="767fb3ec58b891bcd8dd0d769a5789cf"></a><!-- doxytag: member="PxArticulation::setExternalDriveIterations" ref="767fb3ec58b891bcd8dd0d769a5789cf" args="(PxU32 iterations)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setExternalDriveIterations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>iterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sets the number of iterations for drive response to external forces. 
<p>
The drive model uses an iterative algorithm to determine the load on each joint of the articulation. This is the number of iterations to use when computing response of the drive to external forces.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterations</em>&nbsp;</td><td>the number of iterations used to compute the drive response to external forces.</td></tr>
  </table>
</dl>
<b>Default:</b> 4<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#563b2f0279522377f86d7947d790e31f" title="gets externalDriveIterations.">getExternalDriveIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cda14790e09cb759007038d35885065a"></a><!-- doxytag: member="PxArticulation::setInternalDriveIterations" ref="cda14790e09cb759007038d35885065a" args="(PxU32 iterations)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setInternalDriveIterations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>iterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sets the number of iterations used to compute the drive response to internal forces 
<p>
The drive model uses an iterative algorithm to determine the load on each joint of the articulation. This is the number of iterations to use when computing response of the drive to internal forces.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterations</em>&nbsp;</td><td>the number of iterations used to compute the drive response to internal forces.</td></tr>
  </table>
</dl>
<b>Default:</b> 4<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#6d02a86ad795aaed3e1a2dc6a3d49762" title="gets internal driveIterations.">getInternalDriveIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4154ccfb1afad6e3b8145a67e7f580bd"></a><!-- doxytag: member="PxArticulation::setMaxProjectionIterations" ref="4154ccfb1afad6e3b8145a67e7f580bd" args="(PxU32 iterations)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setMaxProjectionIterations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>iterations</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sets maxProjectionIterations. 
<p>
This is the maximum number of iterations to run projection on the articulation to bring the links back together if the separation tolerance is exceeded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>iterations</em>&nbsp;</td><td>the maximum number of projection iterations <b>Default:</b> 4</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#f3685ff6164f06bec07499a0d1b0336a" title="gets maxProjectionIterations.">getMaxProjectionIterations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1efa57c3102cb6258ee90ac70a3c2657"></a><!-- doxytag: member="PxArticulation::setName" ref="1efa57c3102cb6258ee90ac70a3c2657" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a name string for the object that can be retrieved with <a class="el" href="classPxArticulation.html#e10c600444771ea7e29d531b84f3c734" title="Retrieves the name string set with setName().">getName()</a>. 
<p>
This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>String to set the objects name to.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#e10c600444771ea7e29d531b84f3c734" title="Retrieves the name string set with setName().">getName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="284072a943c7e9caa992c513e0855aaf"></a><!-- doxytag: member="PxArticulation::setSeparationTolerance" ref="284072a943c7e9caa992c513e0855aaf" args="(PxReal tolerance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setSeparationTolerance           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>tolerance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sets separationTolerance. 
<p>
This is the maximum allowed separation of any joint in the articulation before projection is used<p>
<b>Default: 0.1f, scaled by the tolerance scale </b><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tolerance</em>&nbsp;</td><td>the separation tolerance for the articulation</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#cacffbf3e5e6e2e02e8b0929e9b73cf6" title="gets separationTolerance.">getSeparationTolerance()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7e4735b8c23aaf5f41d829208cccce6"></a><!-- doxytag: member="PxArticulation::setSleepThreshold" ref="e7e4735b8c23aaf5f41d829208cccce6" args="(PxReal threshold)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setSleepThreshold           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>threshold</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mass-normalized energy threshold below which an articulation may go to sleep. 
<p>
The articulation will sleep if the energy of each body is below this threshold.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Energy below which an actor may go to sleep. <b>Range:</b> (0,inf]</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df" title="Returns true if this articulation is sleeping.">isSleeping()</a> <a class="el" href="classPxArticulation.html#9e7f831e514e0de1c15812f62c0ab20b" title="Returns the mass-normalized energy below which an articulation may go to sleep.">getSleepThreshold()</a> <a class="el" href="classPxArticulation.html#2e849888d2b521d9d20dd5a008e955f3" title="Wakes up the articulation if it is sleeping.">wakeUp()</a> <a class="el" href="classPxArticulation.html#b7da60ba6a4a5b7068115dc79a545b73" title="Forces the articulation to sleep.">putToSleep()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f31eb23f85c5a8516612cad455d4fef3"></a><!-- doxytag: member="PxArticulation::setSolverIterationCounts" ref="f31eb23f85c5a8516612cad455d4fef3" args="(PxU32 minPositionIters, PxU32 minVelocityIters=1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::setSolverIterationCounts           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>minVelocityIters</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the solver iteration counts for the articulation. 
<p>
The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.<p>
If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minPositionIters</em>&nbsp;</td><td>Number of position iterations the solver should perform for this articulation. <b>Range:</b> [1,255] </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minVelocityIters</em>&nbsp;</td><td>Number of velocity iterations the solver should perform for this articulation. <b>Range:</b> [1,255]</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#895c71778bd0ec8905719f507e0a966f" title="Retrieves the solver iteration counts.">getSolverIterationCounts()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e849888d2b521d9d20dd5a008e955f3"></a><!-- doxytag: member="PxArticulation::wakeUp" ref="2e849888d2b521d9d20dd5a008e955f3" args="(PxReal wakeCounterValue=PX_SLEEP_INTERVAL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxArticulation::wakeUp           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>wakeCounterValue</em> = <code>PX_SLEEP_INTERVAL</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wakes up the articulation if it is sleeping. 
<p>
The wakeCounterValue determines how long until the articulation is put to sleep, a value of zero means that the articulation is sleeping. wakeUp(0) is equivalent to <a class="el" href="classPxRigidDynamic.html#ae00aa2067a2fe268b999aad04f27c28" title="Forces the actor to sleep.">PxRigidDynamic::putToSleep()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeCounterValue</em>&nbsp;</td><td>New sleep counter value. <b>Range:</b> [0,inf]</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html#2ab9a560f94ce01b499fedff8f54a9df" title="Returns true if this articulation is sleeping.">isSleeping()</a> <a class="el" href="classPxArticulation.html#b7da60ba6a4a5b7068115dc79a545b73" title="Forces the articulation to sleep.">putToSleep()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="d292404f71931e4e465bfe7581c2aa1e"></a><!-- doxytag: member="PxArticulation::userData" ref="d292404f71931e4e465bfe7581c2aa1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxArticulation.html#d292404f71931e4e465bfe7581c2aa1e">PxArticulation::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxArticulation_8h-source.html">PxArticulation.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
