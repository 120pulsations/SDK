<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: pxtask::CudaContextManagerDesc Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespacepxtask.html">pxtask</a>::<a class="el" href="classpxtask_1_1CudaContextManagerDesc.html">CudaContextManagerDesc</a>
  </div>
<div class="contents">
<h1>pxtask::CudaContextManagerDesc Class Reference</h1><!-- doxytag: class="pxtask::CudaContextManagerDesc" -->Descriptor used to create a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxCudaContextManager_8h-source.html">PxCudaContextManager.h</a>&gt;</code>
<p>

<p>
<a href="classpxtask_1_1CudaContextManagerDesc-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#6ae9400dc042482808161acd39469bc1">CudaContextManagerDesc</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="PxCudaContextManager_8h.html#f9f5bd81658f866613785b3a0bb7d7d9">CUcontext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#abb9cf4c1749ccc006880085a86e9824">ctx</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The CUDA context to manage.  <a href="#abb9cf4c1749ccc006880085a86e9824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#75bfbfc726b4686e4d747508a189fbca">graphicsDevice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">D3D device pointer or OpenGl context handle.  <a href="#75bfbfc726b4686e4d747508a189fbca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structpxtask_1_1CudaInteropMode.html#641d7ebb1cdaa3c951e09f6ec693a600">CudaInteropMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#ea333c339a524798430b0adad7e37ea1">interopMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The CUDA/Graphics interop mode of this context.  <a href="#ea333c339a524798430b0adad7e37ea1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#b70067b8e2e627c5b0b9247176ced46a">memoryBaseSize</a> [CudaBufferMemorySpace::COUNT]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of persistent memory.  <a href="#b70067b8e2e627c5b0b9247176ced46a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#e3974aeb7ff30e47308004ba0489c5f7">memoryPageSize</a> [CudaBufferMemorySpace::COUNT]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of memory pages.  <a href="#e3974aeb7ff30e47308004ba0489c5f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#ea8828043add10812ca4150e8f248684">maxMemorySize</a> [CudaBufferMemorySpace::COUNT]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum size of memory that the memory manager will allocate.  <a href="#ea8828043add10812ca4150e8f248684"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Descriptor used to create a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6ae9400dc042482808161acd39469bc1"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::CudaContextManagerDesc" ref="6ae9400dc042482808161acd39469bc1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE pxtask::CudaContextManagerDesc::CudaContextManagerDesc           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="PxCudaMemoryManager_8h-source.html#l00041">NULL</a>, and <a class="el" href="PxSimpleTypes_8h-source.html#l00185">PX_MAX_U32</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="abb9cf4c1749ccc006880085a86e9824"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::ctx" ref="abb9cf4c1749ccc006880085a86e9824" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="PxCudaContextManager_8h.html#f9f5bd81658f866613785b3a0bb7d7d9">CUcontext</a>* <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#abb9cf4c1749ccc006880085a86e9824">pxtask::CudaContextManagerDesc::ctx</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The CUDA context to manage. 
<p>
If left NULL, the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> will create a new context. If graphicsDevice is also not NULL, this new CUDA context will be bound to that graphics device, enabling the use of CUDA/Graphics interop features.<p>
If ctx is not NULL, the specified context must be applied to the thread that is allocating the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> at creation time (aka, it cannot be popped). The <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> will take ownership of the context until the manager is released. All access to the context must be gated by lock acquisition.<p>
If the user provides a context for the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>, the context _must_ have either been created on the GPU ordinal returned by <a class="el" href="namespacepxtask.html#8e55cd6fa3bb267751abfa3d046fb478" title="Ask the NVIDIA control panel which GPU has been selected for use by PhysX. Returns...">getSuggestedCudaDeviceOrdinal()</a> or on your graphics device.<p>
It is perfectly acceptable to allocate device or host pinned memory from the context outside the scope of the <a class="el" href="classpxtask_1_1CudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">CudaMemoryManager</a>, so long as you manage its eventual cleanup. 
</div>
</div><p>
<a class="anchor" name="75bfbfc726b4686e4d747508a189fbca"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::graphicsDevice" ref="75bfbfc726b4686e4d747508a189fbca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#75bfbfc726b4686e4d747508a189fbca">pxtask::CudaContextManagerDesc::graphicsDevice</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
D3D device pointer or OpenGl context handle. 
<p>
Only applicable when ctx is NULL, thus forcing a new context to be created. In that case, the created context will be bound to this graphics device. 
</div>
</div><p>
<a class="anchor" name="ea333c339a524798430b0adad7e37ea1"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::interopMode" ref="ea333c339a524798430b0adad7e37ea1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpxtask_1_1CudaInteropMode.html#641d7ebb1cdaa3c951e09f6ec693a600">CudaInteropMode::Enum</a> <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#ea333c339a524798430b0adad7e37ea1">pxtask::CudaContextManagerDesc::interopMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The CUDA/Graphics interop mode of this context. 
<p>
If ctx is NULL, this value describes the nature of the graphicsDevice pointer provided by the user. Else it describes the nature of the context provided by the user. 
</div>
</div><p>
<a class="anchor" name="ea8828043add10812ca4150e8f248684"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::maxMemorySize" ref="ea8828043add10812ca4150e8f248684" args="[CudaBufferMemorySpace::COUNT]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#ea8828043add10812ca4150e8f248684">pxtask::CudaContextManagerDesc::maxMemorySize</a>[CudaBufferMemorySpace::COUNT]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum size of memory that the memory manager will allocate. 
<p>

</div>
</div><p>
<a class="anchor" name="b70067b8e2e627c5b0b9247176ced46a"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::memoryBaseSize" ref="b70067b8e2e627c5b0b9247176ced46a" args="[CudaBufferMemorySpace::COUNT]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#b70067b8e2e627c5b0b9247176ced46a">pxtask::CudaContextManagerDesc::memoryBaseSize</a>[CudaBufferMemorySpace::COUNT]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of persistent memory. 
<p>
This memory is allocated up front and stays allocated until the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> is released. Size is in bytes, has to be power of two and bigger than the page size. Set to 0 to only use dynamic pages.<p>
Note: On Vista O/S and above, there is a per-memory allocation overhead to every CUDA work submission, so we recommend that you carefully tune this initial base memory size to closely approximate the ammount of memory your application will consume. 
</div>
</div><p>
<a class="anchor" name="e3974aeb7ff30e47308004ba0489c5f7"></a><!-- doxytag: member="pxtask::CudaContextManagerDesc::memoryPageSize" ref="e3974aeb7ff30e47308004ba0489c5f7" args="[CudaBufferMemorySpace::COUNT]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html#e3974aeb7ff30e47308004ba0489c5f7">pxtask::CudaContextManagerDesc::memoryPageSize</a>[CudaBufferMemorySpace::COUNT]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size of memory pages. 
<p>
The memory manager will dynamically grow and shrink in blocks multiple of this page size. Size has to be power of two and bigger than 0. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCudaContextManager_8h-source.html">PxCudaContextManager.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
