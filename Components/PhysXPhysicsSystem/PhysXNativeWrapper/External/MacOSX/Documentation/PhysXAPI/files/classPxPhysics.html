<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxPhysics Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxPhysics Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxPhysics" -->Abstract singleton factory class used for instancing objects in the Physics SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxPhysics_8h-source.html">PxPhysics.h</a>&gt;</code>
<p>

<p>
<a href="classPxPhysics-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#5d2cea62dd20865d8c13b8d07bd6fb60">~PxPhysics</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f3528cb7b52867c31988edf0f62fa215">registerClass</a> (<a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a> type, <a class="el" href="group__common.html#ge2cfe135e954bac0ce73fc5498d7f8c9">PxClassCreationCallback</a> callback)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxUserReferences.html">PxUserReferences</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#3de530a0b8e478a0eb8314a53f3a9244">createUserReferences</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a user references object.  <a href="#3de530a0b8e478a0eb8314a53f3a9244"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#0a6bf6561aaec4e8c2297c3f0b8a2ef1">releaseUserReferences</a> (<a class="el" href="classPxUserReferences.html">PxUserReferences</a> &amp;ref)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxCollection.html">PxCollection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#ec4071049acd86dc727a5fec1e4051fd">createCollection</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a collection object.  <a href="#ec4071049acd86dc727a5fec1e4051fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#71d918eda7eb706b3630c7fb6863b120">releaseCollection</a> (<a class="el" href="classPxCollection.html">PxCollection</a> &amp;)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#959aa89c1fa423201ac6b1609efc331a">addCollection</a> (const <a class="el" href="classPxCollection.html">PxCollection</a> &amp;collection, <a class="el" href="classPxScene.html">PxScene</a> &amp;scene)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds collected objects to a scene.  <a href="#959aa89c1fa423201ac6b1609efc331a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#795e11d0e5ed6ac50af9c656f6a67e37">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys the instance it is called on.  <a href="#795e11d0e5ed6ac50af9c656f6a67e37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxScene.html">PxScene</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1">createScene</a> (const <a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;sceneDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a scene.  <a href="#6dcded7be00c17004432a04a78569db1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f6181c2f379b52712bece3f7639fab1e">getNbScenes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets number of created scenes.  <a href="#f6181c2f379b52712bece3f7639fab1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1ecd80a6f7c5239bd6cc50c5ea76156d">getScenes</a> (<a class="el" href="classPxScene.html">PxScene</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of scene pointers to a user buffer.  <a href="#1ecd80a6f7c5239bd6cc50c5ea76156d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidStatic.html">PxRigidStatic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#82949b1375677a8c58d64c7cd47b7f4b">createRigidStatic</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a static rigid actor with the specified pose and all other fields initialized to their default values.  <a href="#82949b1375677a8c58d64c7cd47b7f4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#58d338d214918182945c8fcb99325e20">createRigidDynamic</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values.  <a href="#58d338d214918182945c8fcb99325e20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConstraint.html">PxConstraint</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1126f3f545ebe183be1753f62d1efc7d">createConstraint</a> (<a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor0, <a class="el" href="classPxRigidActor.html">PxRigidActor</a> *actor1, <a class="el" href="classPxConstraintConnector.html">PxConstraintConnector</a> &amp;connector, const <a class="el" href="structPxConstraintShaderTable.html">PxConstraintShaderTable</a> &amp;shaders, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> dataSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a constraint shader.  <a href="#1126f3f545ebe183be1753f62d1efc7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxArticulation.html">PxArticulation</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#a65bf245c40886f007b7cda86dee9f3f">createArticulation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an articulation with all fields initialized to their default values.  <a href="#a65bf245c40886f007b7cda86dee9f3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#4209ffb5ab43cd7d9c6a59e4139c1993">createAggregate</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxSize, bool enableSelfCollision)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an aggregate with the specified maximum size and selfCollision property.  <a href="#4209ffb5ab43cd7d9c6a59e4139c1993"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxParticleSystem.html">PxParticleSystem</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#a89391ab4db1f756c93db682ea6f690c">createParticleSystem</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxParticles, bool perParticleRestOffset=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a particle system.  <a href="#a89391ab4db1f756c93db682ea6f690c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxParticleFluid.html">PxParticleFluid</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#109db6886909a61b7c51acc7afc0bc2b">createParticleFluid</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxParticles, bool perParticleRestOffset=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a particle fluid.  <a href="#109db6886909a61b7c51acc7afc0bc2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxCloth.html">PxCloth</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#c0d443eb73c6ef9325abfb1330c8a4e1">createCloth</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;globalPose, <a class="el" href="classPxClothFabric.html">PxClothFabric</a> &amp;fabric, const <a class="el" href="structPxClothParticle.html">PxClothParticle</a> *particles, const <a class="el" href="classPxClothCollisionData.html">PxClothCollisionData</a> &amp;collData, <a class="el" href="classPxFlags.html">PxClothFlags</a> flags)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#35c1965ae47b24e119c6a2d8ce25477e">createMaterial</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> staticFriction, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> dynamicFriction, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> restitution)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new material with default properties.  <a href="#35c1965ae47b24e119c6a2d8ce25477e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#051662877c0f3346ac7fa4f1bf4bcd95">getNbMaterials</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of materials that currently exist.  <a href="#051662877c0f3346ac7fa4f1bf4bcd95"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1a9cabf0c8c0f11d7eb7e948be2e32b0">getMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of material pointers to a user buffer.  <a href="#1a9cabf0c8c0f11d7eb7e948be2e32b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd">createTriangleMesh</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a triangle mesh object.  <a href="#29dcbbe128cef11eaf4ce5696c216dfd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#91183bc0ffba9000a0f76bf4d9bf5fa2">getNbTriangleMeshes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of triangle meshes that currently exist.  <a href="#91183bc0ffba9000a0f76bf4d9bf5fa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#a781fee3bcd9ea28cfaa45717c4a8738">getTriangleMeshes</a> (<a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of triangle mesh pointers to a user buffer.  <a href="#a781fee3bcd9ea28cfaa45717c4a8738"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#01f20b850bb06cf86d1bd3b59efb4a96">createHeightField</a> (const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;heightFieldDesc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> object.  <a href="#01f20b850bb06cf86d1bd3b59efb4a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#92275b36165ce356aa217d17fbb3ac2c">getNbHeightFields</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of heightfields that currently exist.  <a href="#92275b36165ce356aa217d17fbb3ac2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#d2470ec4f7a3b36664f92d08c3b42ba7">getHeightFields</a> (<a class="el" href="classPxHeightField.html">PxHeightField</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of heightfield pointers to a user buffer.  <a href="#d2470ec4f7a3b36664f92d08c3b42ba7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#54fc5f8b0884977ccfd45ea829392a52">createConvexMesh</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a convex mesh object.  <a href="#54fc5f8b0884977ccfd45ea829392a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#372b961576ee45702d02618933e8db0d">getNbConvexMeshes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of convex meshes that currently exist.  <a href="#372b961576ee45702d02618933e8db0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#f842c37b9e11bf180465452e8dacfc06">getConvexMeshes</a> (<a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of convex mesh pointers to a user buffer.  <a href="#f842c37b9e11bf180465452e8dacfc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxClothFabric.html">PxClothFabric</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#c32634024422793b65190304c4631494">createClothFabric</a> (<a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cloth fabric object.  <a href="#c32634024422793b65190304c4631494"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxClothFabric.html">PxClothFabric</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#98043225eeee19ccffc0116bc5251ccc">createClothFabric</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbParticles, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbPhases, const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *phases, const <a class="el" href="structPxClothFabricPhaseType.html#9f876cdc99a8e874ef799592a5f5562e">PxClothFabricPhaseType::Enum</a> *phaseTypes, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbRestvalues, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *restvalues, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbSets, const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *sets, const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *fibers, const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *indices)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cloth fabric object from particle connectivity and restlength information.  <a href="#98043225eeee19ccffc0116bc5251ccc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#66ab807ef19f4e229e6163db9f19df85">getNbClothFabrics</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of cloth fabrics that currently exist.  <a href="#66ab807ef19f4e229e6163db9f19df85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#8dc5895be663e3f8d221459f59a8b803">getClothFabrics</a> (<a class="el" href="classPxClothFabric.html">PxClothFabric</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the array of cloth fabrics to a user buffer.  <a href="#8dc5895be663e3f8d221459f59a8b803"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#e6b06e75ab03222d301a15e14c5ac467">getTolerancesScale</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the simulation tolerance parameters.  <a href="#e6b06e75ab03222d301a15e14c5ac467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFoundation.html">PxFoundation</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#1c2899065d7b3d9367a409b0207848cc">getFoundation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the Foundation instance.  <a href="#1c2899065d7b3d9367a409b0207848cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVisualDebugger.html">PxVisualDebugger</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#ff68604b7d5aaf30bb932c67e4aa7d89">getVisualDebugger</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the PhysX Visual Debugger.  <a href="#ff68604b7d5aaf30bb932c67e4aa7d89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
physx::debugger::comm::PvdConnectionManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#606fa4a3820e15d05439a27d48ccdd69">getPvdConnectionManager</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
physx::PxProfileZoneManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxPhysics.html#87d4979f29122526fae07e70036d1fc6">getProfileZoneManager</a> ()=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract singleton factory class used for instancing objects in the Physics SDK. 
<p>
In addition you can use <a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> to set global parameters which will effect all scenes, create triangle meshes.<p>
You can get an instance of this class by calling <a class="el" href="group__physics.html#g2d0057fc33b72e210c58376fa209ce8d" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g2d0057fc33b72e210c58376fa209ce8d" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> <a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> <a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="5d2cea62dd20865d8c13b8d07bd6fb60"></a><!-- doxytag: member="PxPhysics::~PxPhysics" ref="5d2cea62dd20865d8c13b8d07bd6fb60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxPhysics::~PxPhysics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="959aa89c1fa423201ac6b1609efc331a"></a><!-- doxytag: member="PxPhysics::addCollection" ref="959aa89c1fa423201ac6b1609efc331a" args="(const PxCollection &amp;collection, PxScene &amp;scene)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::addCollection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxCollection.html">PxCollection</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxScene.html">PxScene</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>scene</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds collected objects to a scene. 
<p>
This function adds all objects contained in the input collection to the input scene. This is typically used after deserializing the collection, to populate the scene with deserialized objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>collection</em>&nbsp;</td><td>Objects to add to the scene. See <a class="el" href="classPxCollection.html" title="Collection class for serialization.">PxCollection</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scene</em>&nbsp;</td><td>Scene to which collected objects will be added. See <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCollection.html" title="Collection class for serialization.">PxCollection</a> <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4209ffb5ab43cd7d9c6a59e4139c1993"></a><!-- doxytag: member="PxPhysics::createAggregate" ref="4209ffb5ab43cd7d9c6a59e4139c1993" args="(PxU32 maxSize, bool enableSelfCollision)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxAggregate.html">PxAggregate</a>* PxPhysics::createAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enableSelfCollision</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an aggregate with the specified maximum size and selfCollision property. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxSize</em>&nbsp;</td><td>the maximum number of actors that may be placed in the aggregate. This value must not exceed 128, otherwise NULL will be returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enableSelfCollision</em>&nbsp;</td><td>whether the aggregate supports self-collision </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new aggregate.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a65bf245c40886f007b7cda86dee9f3f"></a><!-- doxytag: member="PxPhysics::createArticulation" ref="a65bf245c40886f007b7cda86dee9f3f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxArticulation.html">PxArticulation</a>* PxPhysics::createArticulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an articulation with all fields initialized to their default values. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new articulation</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0d443eb73c6ef9325abfb1330c8a4e1"></a><!-- doxytag: member="PxPhysics::createCloth" ref="c0d443eb73c6ef9325abfb1330c8a4e1" args="(const PxTransform &amp;globalPose, PxClothFabric &amp;fabric, const PxClothParticle *particles, const PxClothCollisionData &amp;collData, PxClothFlags flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCloth.html">PxCloth</a>* PxPhysics::createCloth           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>globalPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxClothFabric.html">PxClothFabric</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fabric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxClothParticle.html">PxClothParticle</a> *&nbsp;</td>
          <td class="paramname"> <em>particles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxClothCollisionData.html">PxClothCollisionData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>collData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxClothFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>globalPose</em>&nbsp;</td><td>The world space transform of the cloth. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fabric</em>&nbsp;</td><td>The fabric the cloth should use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>particles</em>&nbsp;</td><td>Particle definition buffer. The size of the buffer has to match the number of points of the cloth mesh which elements must match with the provided </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collData</em>&nbsp;</td><td>Collision information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Cloth flags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="classPxClothCollisionData.html" title="Collision data used for cloth-sphere and cloth-capsule collision.">PxClothCollisionData</a> <a class="el" href="group__cloth.html#g2be4311f196add0112bf7148caa36151">PxClothFlags</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="98043225eeee19ccffc0116bc5251ccc"></a><!-- doxytag: member="PxPhysics::createClothFabric" ref="98043225eeee19ccffc0116bc5251ccc" args="(PxU32 nbParticles, PxU32 nbPhases, const PxU32 *phases, const PxClothFabricPhaseType::Enum *phaseTypes, PxU32 nbRestvalues, const PxReal *restvalues, PxU32 nbSets, const PxU32 *sets, const PxU32 *fibers, const PxU32 *indices)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxClothFabric.html">PxClothFabric</a>* PxPhysics::createClothFabric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbPhases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxClothFabricPhaseType.html#9f876cdc99a8e874ef799592a5f5562e">PxClothFabricPhaseType::Enum</a> *&nbsp;</td>
          <td class="paramname"> <em>phaseTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbRestvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *&nbsp;</td>
          <td class="paramname"> <em>restvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>fibers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>indices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth fabric object from particle connectivity and restlength information. 
<p>
This can then be instanced into <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> objects.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>We recommended using <a class="el" href="classPxCooking.html#8574625cb5d69ccf2ac9a3633a53a205" title="Cooks a triangle mesh to a PxClothFabric.">PxCooking.cookClothFabric()</a> to create cloth fabrics from meshes and then using createClothFabric(const PxInputStream&amp; stream). This method should only be used if you need to provide fully customized particle fiber/connectivity information for your fabric or if you did custom cloth fabric serialization and want to deserialize.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbParticles</em>&nbsp;</td><td>the number of particles needed when creating a <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> instance from the fabric. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbPhases</em>&nbsp;</td><td>the number of solver phases. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phases</em>&nbsp;</td><td>array defining which set to use for each phase. See <a class="el" href="classPxClothFabric.html#6bca3accc82f16f46a1c1be1371b4399" title="Copies the phase array to a user specified buffer.">PxClothFabric.getPhases()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phaseTypes</em>&nbsp;</td><td>array defining the type of each phase. See <a class="el" href="structPxClothFabricPhaseType.html" title="describe type of phase in cloth fabric">PxClothFabricPhaseType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbRestvalues</em>&nbsp;</td><td>the number of rest values </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restvalues</em>&nbsp;</td><td>array of rest values for each constraint. See <a class="el" href="classPxClothFabric.html#fb53563992c3181c6f2b6c826deea2b0" title="Copies the rest values array to a user specified buffer.">PxClothFabric.getRestvalues()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbSets</em>&nbsp;</td><td>number of sets in the fabric. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sets</em>&nbsp;</td><td>array with an index per set which points one entry beyond the last fiber of the set. See <a class="el" href="classPxClothFabric.html#f45bfae66b62c892245fac4dbc099f71" title="Copies the set array to a user specified buffer.">PxClothFabric.getSets()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fibers</em>&nbsp;</td><td>array with an index per fiber which points one entry beyond the last particle index of the fiber. See <a class="el" href="classPxClothFabric.html#ac7f2a4ac8c2edad5d6eae2404516acc" title="Copies the fibers array to a user specified buffer.">PxClothFabric.getFibers()</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>indices</em>&nbsp;</td><td>array of particle indices which specifies the line strips of connected particles of a fiber. See <a class="el" href="classPxClothFabric.html#085f09b26d28b5d071fc3476fb76753e" title="Copies the particle indices array to a user specified buffer.">PxClothFabric.getParticleIndices()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth fabric.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="classPxClothFabric.html#7e8a7516cc7cb1777c790bc82cab2eac" title="Release the cloth fabric.">PxClothFabric.release()</a> <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c32634024422793b65190304c4631494"></a><!-- doxytag: member="PxPhysics::createClothFabric" ref="c32634024422793b65190304c4631494" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxClothFabric.html">PxClothFabric</a>* PxPhysics::createClothFabric           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cloth fabric object. 
<p>
This can then be instanced into <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream to load the cloth fabric from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new cloth fabric.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> <a class="el" href="classPxClothFabric.html#7e8a7516cc7cb1777c790bc82cab2eac" title="Release the cloth fabric.">PxClothFabric.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="classPxCloth.html" title="Set of connected particles tailored towards simulating character cloth. A cloth object...">PxCloth</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec4071049acd86dc727a5fec1e4051fd"></a><!-- doxytag: member="PxPhysics::createCollection" ref="ec4071049acd86dc727a5fec1e4051fd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxCollection.html">PxCollection</a>* PxPhysics::createCollection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a collection object. 
<p>
Objects can only be serialized or deserialized through a collection. For serialization, users must add objects to the collection and serialize the collection as a whole. For deserialization, the system gives back a collection of deserialized objects to users.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new collection object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxCollection.html#ebf358855b8e054c907f49f85288a68d" title="Deletes a collection object.">PxCollection::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1126f3f545ebe183be1753f62d1efc7d"></a><!-- doxytag: member="PxPhysics::createConstraint" ref="1126f3f545ebe183be1753f62d1efc7d" args="(PxRigidActor *actor0, PxRigidActor *actor1, PxConstraintConnector &amp;connector, const PxConstraintShaderTable &amp;shaders, PxU32 dataSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConstraint.html">PxConstraint</a>* PxPhysics::createConstraint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxRigidActor.html">PxRigidActor</a> *&nbsp;</td>
          <td class="paramname"> <em>actor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxConstraintConnector.html">PxConstraintConnector</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxConstraintShaderTable.html">PxConstraintShaderTable</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shaders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>dataSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a constraint shader. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A constraint shader will get added automatically to the scene the two linked actors belong to. Either, but not both, of actor0 and actor1 may be NULL to denote attachment to the world.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor0</em>&nbsp;</td><td>the first actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor1</em>&nbsp;</td><td>the second actor </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connector</em>&nbsp;</td><td>the connector object, which the SDK uses to communicate with the infrastructure for the constraint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shaders</em>&nbsp;</td><td>the shader functions for the constraint </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataSize</em>&nbsp;</td><td>the size of the data block for the shader</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new shader. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54fc5f8b0884977ccfd45ea829392a52"></a><!-- doxytag: member="PxPhysics::createConvexMesh" ref="54fc5f8b0884977ccfd45ea829392a52" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxConvexMesh.html">PxConvexMesh</a>* PxPhysics::createConvexMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a convex mesh object. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The stream to load the convex mesh from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new convex mesh.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> <a class="el" href="classPxConvexMesh.html#6d2ce602a2383f40a3eb7d79e0c990d8" title="Releases the convex mesh.">PxConvexMesh.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> <a class="el" href="classPxPhysics.html#29dcbbe128cef11eaf4ce5696c216dfd" title="Creates a triangle mesh object.">createTriangleMesh()</a> <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a> <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="01f20b850bb06cf86d1bd3b59efb4a96"></a><!-- doxytag: member="PxPhysics::createHeightField" ref="01f20b850bb06cf86d1bd3b59efb4a96" args="(const PxHeightFieldDesc &amp;heightFieldDesc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxHeightField.html">PxHeightField</a>* PxPhysics::createHeightField           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxHeightFieldDesc.html">PxHeightFieldDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>heightFieldDesc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> object. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>heightFieldDesc</em>&nbsp;</td><td>The descriptor to load the object from. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new height field object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> <a class="el" href="classPxHeightField.html#6b35bf964920daa991d6b509cbc02744" title="Releases the height field.">PxHeightField.release()</a> <a class="el" href="classPxHeightFieldDesc.html" title="Descriptor class for PxHeightField.">PxHeightFieldDesc</a> <a class="el" href="classPxHeightFieldGeometry.html" title="Height field geometry class.">PxHeightFieldGeometry</a> <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35c1965ae47b24e119c6a2d8ce25477e"></a><!-- doxytag: member="PxPhysics::createMaterial" ref="35c1965ae47b24e119c6a2d8ce25477e" args="(PxReal staticFriction, PxReal dynamicFriction, PxReal restitution)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a>* PxPhysics::createMaterial           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>staticFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>dynamicFriction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>restitution</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new material with default properties. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new material.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>staticFriction</em>&nbsp;</td><td>the coefficient of static friction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dynamicFriction</em>&nbsp;</td><td>the coefficient of dynamic friction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>restitution</em>&nbsp;</td><td>the coefficient of restitution</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html">PxMaterial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="109db6886909a61b7c51acc7afc0bc2b"></a><!-- doxytag: member="PxPhysics::createParticleFluid" ref="109db6886909a61b7c51acc7afc0bc2b" args="(PxU32 maxParticles, bool perParticleRestOffset=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxParticleFluid.html">PxParticleFluid</a>* PxPhysics::createParticleFluid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perParticleRestOffset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a particle fluid. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxParticles</em>&nbsp;</td><td>the maximum number of particles that may be placed in the particle fluid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perParticleRestOffset</em>&nbsp;</td><td>whether the ParticleFluid supports perParticleRestOffset </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new particle fluid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a89391ab4db1f756c93db682ea6f690c"></a><!-- doxytag: member="PxPhysics::createParticleSystem" ref="a89391ab4db1f756c93db682ea6f690c" args="(PxU32 maxParticles, bool perParticleRestOffset=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxParticleSystem.html">PxParticleSystem</a>* PxPhysics::createParticleSystem           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>perParticleRestOffset</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a particle system. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxParticles</em>&nbsp;</td><td>the maximum number of particles that may be placed in the particle system </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>perParticleRestOffset</em>&nbsp;</td><td>whether the ParticleSystem supports perParticleRestOffset </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new particle system. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58d338d214918182945c8fcb99325e20"></a><!-- doxytag: member="PxPhysics::createRigidDynamic" ref="58d338d214918182945c8fcb99325e20" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidDynamic.html">PxRigidDynamic</a>* PxPhysics::createRigidDynamic           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a dynamic rigid actor with the specified pose and all other fields initialized to their default values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>the initial pose of the actor. Must be a valid transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="82949b1375677a8c58d64c7cd47b7f4b"></a><!-- doxytag: member="PxPhysics::createRigidStatic" ref="82949b1375677a8c58d64c7cd47b7f4b" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidStatic.html">PxRigidStatic</a>* PxPhysics::createRigidStatic           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a static rigid actor with the specified pose and all other fields initialized to their default values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>the initial pose of the actor. Must be a valid transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6dcded7be00c17004432a04a78569db1"></a><!-- doxytag: member="PxPhysics::createScene" ref="6dcded7be00c17004432a04a78569db1" args="(const PxSceneDesc &amp;sceneDesc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxScene.html">PxScene</a>* PxPhysics::createScene           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sceneDesc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a scene. 
<p>
The scene can then create its contained entities.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sceneDesc</em>&nbsp;</td><td>Scene descriptor. See <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new scene object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> <a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed" title="Deletes the scene.">PxScene.release()</a> <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="29dcbbe128cef11eaf4ce5696c216dfd"></a><!-- doxytag: member="PxPhysics::createTriangleMesh" ref="29dcbbe128cef11eaf4ce5696c216dfd" args="(PxInputStream &amp;stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a>* PxPhysics::createTriangleMesh           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxInputStream.html">PxInputStream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a triangle mesh object. 
<p>
This can then be instanced into <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>The triangle mesh stream. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new triangle mesh.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> <a class="el" href="classPxTriangleMesh.html#3f78801a37a29335f342f2897acf4c8c" title="Destroys the triangle mesh.">PxTriangleMesh.release()</a> <a class="el" href="classPxInputStream.html" title="Input stream class for I/O.">PxInputStream</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3de530a0b8e478a0eb8314a53f3a9244"></a><!-- doxytag: member="PxPhysics::createUserReferences" ref="3de530a0b8e478a0eb8314a53f3a9244" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxUserReferences.html">PxUserReferences</a>* PxPhysics::createUserReferences           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a user references object. 
<p>
User references are needed when a collection contains external references, either to another collection (when serializing subsets) or to user objects.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxUserReferences.html#5b8d71e82007611653e93588f329b525" title="Deletes a user references object.">PxUserReferences::release()</a> <a class="el" href="classPxUserReferences.html" title="Container for user-defined names/references.">PxUserReferences</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8dc5895be663e3f8d221459f59a8b803"></a><!-- doxytag: member="PxPhysics::getClothFabrics" ref="8dc5895be663e3f8d221459f59a8b803" args="(PxClothFabric **userBuffer, PxU32 bufferSize) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getClothFabrics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxClothFabric.html">PxClothFabric</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of cloth fabrics to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the cloth fabrics in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive cloth fabric pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of cloth fabric pointers which can be stored in the buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of cloth fabric pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#66ab807ef19f4e229e6163db9f19df85" title="Return the number of cloth fabrics that currently exist.">getNbClothFabrics()</a> <a class="el" href="classPxClothFabric.html" title="A cloth fabric is a structure that contains all the internal solver constraints of...">PxClothFabric</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f842c37b9e11bf180465452e8dacfc06"></a><!-- doxytag: member="PxPhysics::getConvexMeshes" ref="f842c37b9e11bf180465452e8dacfc06" args="(PxConvexMesh **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getConvexMeshes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConvexMesh.html">PxConvexMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of convex mesh pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the convex meshes in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive convex mesh pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of convex mesh pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first convex mesh pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of convex mesh pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#372b961576ee45702d02618933e8db0d" title="Return the number of convex meshes that currently exist.">getNbConvexMeshes()</a> <a class="el" href="classPxConvexMesh.html" title="A convex mesh.">PxConvexMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c2899065d7b3d9367a409b0207848cc"></a><!-- doxytag: member="PxPhysics::getFoundation" ref="1c2899065d7b3d9367a409b0207848cc" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFoundation.html">PxFoundation</a>&amp; PxPhysics::getFoundation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the Foundation instance. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the Foundation object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2470ec4f7a3b36664f92d08c3b42ba7"></a><!-- doxytag: member="PxPhysics::getHeightFields" ref="d2470ec4f7a3b36664f92d08c3b42ba7" args="(PxHeightField **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getHeightFields           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxHeightField.html">PxHeightField</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of heightfield pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the heightfields in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive heightfield pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of heightfield pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first heightfield pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of heightfield pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#92275b36165ce356aa217d17fbb3ac2c" title="Return the number of heightfields that currently exist.">getNbHeightFields()</a> <a class="el" href="classPxHeightField.html" title="A height field class.">PxHeightField</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a9cabf0c8c0f11d7eb7e948be2e32b0"></a><!-- doxytag: member="PxPhysics::getMaterials" ref="1a9cabf0c8c0f11d7eb7e948be2e32b0" args="(PxMaterial **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of material pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the materials in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of material pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first material pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of material pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#051662877c0f3346ac7fa4f1bf4bcd95" title="Return the number of materials that currently exist.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html">PxMaterial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ab807ef19f4e229e6163db9f19df85"></a><!-- doxytag: member="PxPhysics::getNbClothFabrics" ref="66ab807ef19f4e229e6163db9f19df85" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbClothFabrics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of cloth fabrics that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of cloth fabrics.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#8dc5895be663e3f8d221459f59a8b803" title="Writes the array of cloth fabrics to a user buffer.">getClothFabrics()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="372b961576ee45702d02618933e8db0d"></a><!-- doxytag: member="PxPhysics::getNbConvexMeshes" ref="372b961576ee45702d02618933e8db0d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbConvexMeshes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of convex meshes that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of convex meshes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#f842c37b9e11bf180465452e8dacfc06" title="Writes the array of convex mesh pointers to a user buffer.">getConvexMeshes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="92275b36165ce356aa217d17fbb3ac2c"></a><!-- doxytag: member="PxPhysics::getNbHeightFields" ref="92275b36165ce356aa217d17fbb3ac2c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbHeightFields           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of heightfields that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of heightfields.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#d2470ec4f7a3b36664f92d08c3b42ba7" title="Writes the array of heightfield pointers to a user buffer.">getHeightFields()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="051662877c0f3346ac7fa4f1bf4bcd95"></a><!-- doxytag: member="PxPhysics::getNbMaterials" ref="051662877c0f3346ac7fa4f1bf4bcd95" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbMaterials           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of materials that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of materials.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#1a9cabf0c8c0f11d7eb7e948be2e32b0" title="Writes the array of material pointers to a user buffer.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6181c2f379b52712bece3f7639fab1e"></a><!-- doxytag: member="PxPhysics::getNbScenes" ref="f6181c2f379b52712bece3f7639fab1e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbScenes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets number of created scenes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of scenes created.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getScene() </dd></dl>

</div>
</div><p>
<a class="anchor" name="91183bc0ffba9000a0f76bf4d9bf5fa2"></a><!-- doxytag: member="PxPhysics::getNbTriangleMeshes" ref="91183bc0ffba9000a0f76bf4d9bf5fa2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getNbTriangleMeshes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of triangle meshes that currently exist. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of triangle meshes.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#a781fee3bcd9ea28cfaa45717c4a8738" title="Writes the array of triangle mesh pointers to a user buffer.">getTriangleMeshes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="87d4979f29122526fae07e70036d1fc6"></a><!-- doxytag: member="PxPhysics::getProfileZoneManager" ref="87d4979f29122526fae07e70036d1fc6" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::PxProfileZoneManager* PxPhysics::getProfileZoneManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="606fa4a3820e15d05439a27d48ccdd69"></a><!-- doxytag: member="PxPhysics::getPvdConnectionManager" ref="606fa4a3820e15d05439a27d48ccdd69" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::debugger::comm::PvdConnectionManager* PxPhysics::getPvdConnectionManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The factory manager allows notifications when a new connection to pvd is made. It also allows the users to specify a scheme to handle the read-side of a network connection. By default, the SDK specifies that a thread gets launched which blocks reading on the network socket.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A valid manager *if* the SDK was compiled with <a class="el" href="namespacePVD.html">PVD</a> support. Null otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ecd80a6f7c5239bd6cc50c5ea76156d"></a><!-- doxytag: member="PxPhysics::getScenes" ref="1ecd80a6f7c5239bd6cc50c5ea76156d" args="(PxScene **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getScenes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxScene.html">PxScene</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of scene pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the scene pointers in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive scene pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of scene pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first scene pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of scene pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#f6181c2f379b52712bece3f7639fab1e" title="Gets number of created scenes.">getNbScenes()</a> <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6b06e75ab03222d301a15e14c5ac467"></a><!-- doxytag: member="PxPhysics::getTolerancesScale" ref="e6b06e75ab03222d301a15e14c5ac467" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classPxTolerancesScale.html">PxTolerancesScale</a>&amp; PxPhysics::getTolerancesScale           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the simulation tolerance parameters. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current simulation tolerance parameters. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a781fee3bcd9ea28cfaa45717c4a8738"></a><!-- doxytag: member="PxPhysics::getTriangleMeshes" ref="a781fee3bcd9ea28cfaa45717c4a8738" args="(PxTriangleMesh **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxPhysics::getTriangleMeshes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTriangleMesh.html">PxTriangleMesh</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the array of triangle mesh pointers to a user buffer. 
<p>
Returns the number of pointers written.<p>
The ordering of the triangle meshes in the array is not specified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive triangle mesh pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>The number of triangle mesh pointers which can be stored in the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first mesh pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of triangle mesh pointers written to userBuffer, this should be less or equal to bufferSize.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#91183bc0ffba9000a0f76bf4d9bf5fa2" title="Return the number of triangle meshes that currently exist.">getNbTriangleMeshes()</a> <a class="el" href="classPxTriangleMesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff68604b7d5aaf30bb932c67e4aa7d89"></a><!-- doxytag: member="PxPhysics::getVisualDebugger" ref="ff68604b7d5aaf30bb932c67e4aa7d89" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVisualDebugger.html">PxVisualDebugger</a>* PxPhysics::getVisualDebugger           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the PhysX Visual Debugger. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="classPxVisualDebugger.html" title="Class to communicate with the PhysX Visual Debugger.">PxVisualDebugger</a>. Can be NULL if <a class="el" href="namespacePVD.html">PVD</a> is not supported on this platform. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3528cb7b52867c31988edf0f62fa215"></a><!-- doxytag: member="PxPhysics::registerClass" ref="f3528cb7b52867c31988edf0f62fa215" args="(PxType type, PxClassCreationCallback callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxPhysics::registerClass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__common.html#gc1fb4b256a5d900d394e89db170a2b79">PxType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ge2cfe135e954bac0ce73fc5498d7f8c9">PxClassCreationCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="795e11d0e5ed6ac50af9c656f6a67e37"></a><!-- doxytag: member="PxPhysics::release" ref="795e11d0e5ed6ac50af9c656f6a67e37" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxPhysics::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys the instance it is called on. 
<p>
Use this release method to destroy an instance of this class. Be sure to not keep a reference to this object after calling release. Avoid release calls while a scene is simulating (in between simulate() and fetchResults() calls).<p>
Note that this must be called once for each prior call to PxCreatePhysics, as there is a reference counter. Also note that you mustn't destroy the allocator or the error callback (if available) until after the reference count reaches 0 and the SDK is actually removed.<p>
Releasing an SDK will also release any scenes, triangle meshes, convex meshes, and heightfields created through it, provided the user hasn't already done so.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g2d0057fc33b72e210c58376fa209ce8d" title="Creates an instance of the physics SDK.">PxCreatePhysics()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="71d918eda7eb706b3630c7fb6863b120"></a><!-- doxytag: member="PxPhysics::releaseCollection" ref="71d918eda7eb706b3630c7fb6863b120" args="(PxCollection &amp;)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxPhysics::releaseCollection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxCollection.html">PxCollection</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0a6bf6561aaec4e8c2297c3f0b8a2ef1"></a><!-- doxytag: member="PxPhysics::releaseUserReferences" ref="0a6bf6561aaec4e8c2297c3f0b8a2ef1" args="(PxUserReferences &amp;ref)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED void PxPhysics::releaseUserReferences           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxUserReferences.html">PxUserReferences</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ref</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxPhysics_8h-source.html">PxPhysics.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
