<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxRigidBody Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidBody Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxRigidBody" --><!-- doxytag: inherits="PxRigidActor" --><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidBody_8h-source.html">PxRigidBody.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxRigidBody:</div>
<div class="dynsection">
<p><center><img src="classPxRigidBody__inherit__graph.png" border="0" usemap="#PxRigidBody__inherit__map" alt="Inheritance graph"></center>
<map name="PxRigidBody__inherit__map">
<area shape="rect" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body" alt="" coords="5,304,136,331"><area shape="rect" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK." alt="" coords="160,304,280,331"><area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="" coords="95,155,196,181"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="" coords="111,80,180,107"><area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="27,5,133,32"><area shape="rect" href="classPxObservable.html" title="Observable interface for classes which can send out state change notifications." alt="" coords="157,5,264,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidBody:</div>
<div class="dynsection">
<p><center><img src="classPxRigidBody__coll__graph.png" border="0" usemap="#PxRigidBody__coll__map" alt="Collaboration graph"></center>
<map name="PxRigidBody__coll__map">
<area shape="rect" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies..." alt="" coords="184,251,286,277"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="" coords="200,173,270,200"><area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="84,96,191,123"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxSerialFlag::Enum, PxU16 \&gt;" alt="" coords="6,5,270,32"><area shape="rect" href="classPxObservable.html" title="Observable interface for classes which can send out state change notifications." alt="" coords="215,96,322,123"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxRigidBody-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mass Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf">setCMassLocalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor.  <a href="#b152773926fe7b222d61e982c3cb6adf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#afdbdab1865112b15201aeabb23877b4">getCMassLocalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <a href="#afdbdab1865112b15201aeabb23877b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35">setMass</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> mass)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <a href="#8a697a7a4b9bdd2c83a68e84b9bc3a35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#2b1c475ca9cc6aebc168ac58256b7284">getMass</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the mass of the actor.  <a href="#2b1c475ca9cc6aebc168ac58256b7284"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd">setMassSpaceInertiaTensor</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;m)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <a href="#755d0c8a8d1dd8b29e59d50a6dfda5fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#063cce94190de44d86a15c1b49dd7f71">getMassSpaceInertiaTensor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <a href="#063cce94190de44d86a15c1b49dd7f71"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7">getLinearVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <a href="#04bab22deecb716e2cdd7a64b5cfaee7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05">setLinearVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;linVel, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the linear velocity of the actor.  <a href="#0aed51d5ddcf81b09a104ad7f0f30c05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0">getAngularVelocity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <a href="#f91b92d6fcf47103b148337749aa93e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27">setAngularVelocity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;angVel, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the angular velocity of the actor.  <a href="#d49850630db14af26e019d2550ecfd27"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Forces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c">addForce</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor.  <a href="#22b0a1ef0b6c5656a6063c5c38f5679c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79">addTorque</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;torque, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <a href="#cb04ffc816d45afff2d04e93d7446e79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#993328baf1a95a6738e79fda62376cab">clearForce</a> (<a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <a href="#993328baf1a95a6738e79fda62376cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#906c4aaec604bcbed80b5d74cd06c2e8">clearTorque</a> (<a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool autowake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <a href="#906c4aaec604bcbed80b5d74cd06c2e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#3fdc523e746bab9df5e5b55f22067885">PxRigidBody</a> (<a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#797d480716c6c53a9b2a541937fbcd69">PxRigidBody</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#229ff64730b95c9c36b653ffee707e8a">~PxRigidBody</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBody.html#d2e17e08871d8a2f492aee495550a0a0">isKindOf</a> (const char *name) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3fdc523e746bab9df5e5b55f22067885"></a><!-- doxytag: member="PxRigidBody::PxRigidBody" ref="3fdc523e746bab9df5e5b55f22067885" args="(PxRefResolver &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxRigidBody::PxRigidBody           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="797d480716c6c53a9b2a541937fbcd69"></a><!-- doxytag: member="PxRigidBody::PxRigidBody" ref="797d480716c6c53a9b2a541937fbcd69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidBody::PxRigidBody           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="229ff64730b95c9c36b653ffee707e8a"></a><!-- doxytag: member="PxRigidBody::~PxRigidBody" ref="229ff64730b95c9c36b653ffee707e8a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidBody::~PxRigidBody           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="22b0a1ef0b6c5656a6063c5c38f5679c"></a><!-- doxytag: member="PxRigidBody::addForce" ref="22b0a1ef0b6c5656a6063c5c38f5679c" args="(const PxVec3 &amp;force, PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addForce           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the global coordinate frame to the actor. 
<p>
<b>This will not induce a torque</b>.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Specify if the call should wake up the actor if it is currently asleep.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb04ffc816d45afff2d04e93d7446e79"></a><!-- doxytag: member="PxRigidBody::addTorque" ref="cb04ffc816d45afff2d04e93d7446e79" args="(const PxVec3 &amp;torque, PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::addTorque           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies an impulsive torque defined in the global coordinate frame to the actor. 
<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the torque is to be conventional or impulsive.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the global frame. <b>Range:</b> torque vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>whether to wake up the object if it is asleep</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor...">addForce()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="993328baf1a95a6738e79fda62376cab"></a><!-- doxytag: member="PxRigidBody::clearForce" ref="993328baf1a95a6738e79fda62376cab" args="(PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearForce           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the accumulated forces (sets the accumulated force back to zero). 
<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the cleared force is to be conventional or impulsive.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Specify if the call should wake up the actor if it is currently asleep.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#22b0a1ef0b6c5656a6063c5c38f5679c" title="Applies a force (or impulse) defined in the global coordinate frame to the actor...">addForce</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="906c4aaec604bcbed80b5d74cd06c2e8"></a><!-- doxytag: member="PxRigidBody::clearTorque" ref="906c4aaec604bcbed80b5d74cd06c2e8" args="(PxForceMode::Enum mode=PxForceMode::eFORCE, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::clearTorque           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the impulsive torque defined in the global coordinate frame to the actor. 
<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the cleared torque is to be conventional or impulsive.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The force modes <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545a3699bd1b7ae178eda5b946097de52c4" title="parameter has unit of mass * distance /time">PxForceMode::eIMPULSE</a> and <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e5459f25946973fec4c78991859e8bf76376" title="parameter has unit of distance / time, i.e. the effect is mass independent: a velocity...">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links</dd></dl>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the autowake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when clearing the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>whether to wake up the object if it is asleep</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <a class="el" href="classPxRigidBody.html#cb04ffc816d45afff2d04e93d7446e79" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f91b92d6fcf47103b148337749aa93e0"></a><!-- doxytag: member="PxRigidBody::getAngularVelocity" ref="f91b92d6fcf47103b148337749aa93e0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getAngularVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the angular velocity of the actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor.">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="afdbdab1865112b15201aeabb23877b4"></a><!-- doxytag: member="PxRigidBody::getCMassLocalPose" ref="afdbdab1865112b15201aeabb23877b4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxRigidBody::getCMassLocalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the center of mass pose relative to the actor frame. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The center of mass pose relative to the actor frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div><p>
<a class="anchor" name="04bab22deecb716e2cdd7a64b5cfaee7"></a><!-- doxytag: member="PxRigidBody::getLinearVelocity" ref="04bab22deecb716e2cdd7a64b5cfaee7" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getLinearVelocity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the linear velocity of an actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor.">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b1c475ca9cc6aebc168ac58256b7284"></a><!-- doxytag: member="PxRigidBody::getMass" ref="2b1c475ca9cc6aebc168ac58256b7284" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxRigidBody::getMass           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the mass of the actor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The mass of this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="063cce94190de44d86a15c1b49dd7f71"></a><!-- doxytag: member="PxRigidBody::getMassSpaceInertiaTensor" ref="063cce94190de44d86a15c1b49dd7f71" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBody::getMassSpaceInertiaTensor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame. 
<p>
This method retrieves a mass frame inertia vector.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The mass space inertia tensor of this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2e17e08871d8a2f492aee495550a0a0"></a><!-- doxytag: member="PxRigidBody::isKindOf" ref="d2e17e08871d8a2f492aee495550a0a0" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidBody::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classPxRigidActor.html#e644382039f621f73ca7db7aa9d2e0cf">PxRigidActor</a>.</p>

<p>Reimplemented in <a class="el" href="classPxArticulationLink.html#45d7a988876af31572acca1376401c18">PxArticulationLink</a>, and <a class="el" href="classPxRigidDynamic.html#0ed60c0a05771d8679069a46b778f8f8">PxRigidDynamic</a>.</p>

<p>References <a class="el" href="PxRigidActor_8h-source.html#l00247">PxRigidActor::isKindOf()</a>.</p>

<p>Referenced by <a class="el" href="PxRigidDynamic_8h-source.html#l00378">PxRigidDynamic::isKindOf()</a>, and <a class="el" href="PxArticulationLink_8h-source.html#l00112">PxArticulationLink::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d49850630db14af26e019d2550ecfd27"></a><!-- doxytag: member="PxRigidBody::setAngularVelocity" ref="d49850630db14af26e019d2550ecfd27" args="(const PxVec3 &amp;angVel, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setAngularVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>angVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the angular velocity of the actor. 
<p>
Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.<p>
<b>Default:</b> (0.0, 0.0, 0.0)<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default), and the new velocity is non-zero<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angVel</em>&nbsp;</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#f91b92d6fcf47103b148337749aa93e0" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> <a class="el" href="classPxRigidBody.html#0aed51d5ddcf81b09a104ad7f0f30c05" title="Sets the linear velocity of the actor.">setLinearVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b152773926fe7b222d61e982c3cb6adf"></a><!-- doxytag: member="PxRigidBody::setCMassLocalPose" ref="b152773926fe7b222d61e982c3cb6adf" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setCMassLocalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the pose of the center of mass relative to the actor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Changing this transform will not move the actor in the world!<p>
Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<b>Default:</b> the identity transform<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Mass frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#afdbdab1865112b15201aeabb23877b4" title="Retrieves the center of mass pose relative to the actor frame.">getCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div><p>
<a class="anchor" name="0aed51d5ddcf81b09a104ad7f0f30c05"></a><!-- doxytag: member="PxRigidBody::setLinearVelocity" ref="0aed51d5ddcf81b09a104ad7f0f30c05" args="(const PxVec3 &amp;linVel, bool autowake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setLinearVelocity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>linVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>autowake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the linear velocity of the actor. 
<p>
Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.<p>
<b>Default:</b> (0.0, 0.0, 0.0)<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping, the autowake parameter is true (default), and the new velocity is non-zero<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linVel</em>&nbsp;</td><td>New linear velocity of actor. <b>Range:</b> velocity vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>autowake</em>&nbsp;</td><td>Whether to wake the object up if it is asleep and the velocity is non-zero</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#04bab22deecb716e2cdd7a64b5cfaee7" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> <a class="el" href="classPxRigidBody.html#d49850630db14af26e019d2550ecfd27" title="Sets the angular velocity of the actor.">setAngularVelocity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a697a7a4b9bdd2c83a68e84b9bc3a35"></a><!-- doxytag: member="PxRigidBody::setMass" ref="8a697a7a4b9bdd2c83a68e84b9bc3a35" args="(PxReal mass)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMass           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>mass</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the mass of a dynamic actor. 
<p>
The mass must be positive.<p>
<a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> or the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a>.<p>
<b>Default:</b> 1.0<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mass</em>&nbsp;</td><td>New mass value for the actor. <b>Range:</b> (0,inf)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#2b1c475ca9cc6aebc168ac58256b7284" title="Retrieves the mass of the actor.">getMass()</a> PxRigidBodyDesc.mass <a class="el" href="classPxRigidBody.html#755d0c8a8d1dd8b29e59d50a6dfda5fd" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="755d0c8a8d1dd8b29e59d50a6dfda5fd"></a><!-- doxytag: member="PxRigidBody::setMassSpaceInertiaTensor" ref="755d0c8a8d1dd8b29e59d50a6dfda5fd" args="(const PxVec3 &amp;m)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidBody::setMassSpaceInertiaTensor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the inertia tensor, using a parameter specified in mass space coordinates. 
<p>
Note that such matrices are diagonal -- the passed vector is the diagonal.<p>
If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a>.<p>
<b>Default:</b> (1.0, 1.0, 1.0)<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>m</em>&nbsp;</td><td>New mass space inertia tensor for the actor. <b>Range:</b> inertia vector</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBodyDesc.massSpaceInertia getMassSpaceInertia() <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidBody_8h-source.html">PxRigidBody.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
