<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxRigidActor Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidActor Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxRigidActor" --><!-- doxytag: inherits="PxActor" --><a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> represents a base class shared between dynamic and static rigid bodies in the physics SDK.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidActor_8h-source.html">PxRigidActor.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxRigidActor:</div>
<div class="dynsection">
<p><center><img src="classPxRigidActor__inherit__graph.png" border="0" usemap="#PxRigidActor__inherit__map" alt="Inheritance graph"></center>
<map name="PxRigidActor__inherit__map">
<area shape="rect" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects." alt="" coords="96,229,195,256"><area shape="rect" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK..." alt="" coords="219,229,320,256"><area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="" coords="172,80,242,107"><area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="88,5,195,32"><area shape="rect" href="classPxObservable.html" title="Observable interface for classes which can send out state change notifications." alt="" coords="219,5,326,32"><area shape="rect" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body" alt="" coords="6,304,136,331"><area shape="rect" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK." alt="" coords="160,304,280,331"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxRigidActor:</div>
<div class="dynsection">
<p><center><img src="classPxRigidActor__coll__graph.png" border="0" usemap="#PxRigidActor__coll__map" alt="Collaboration graph"></center>
<map name="PxRigidActor__coll__map">
<area shape="rect" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="" coords="200,174,270,200"><area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="84,96,191,123"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxSerialFlag::Enum, PxU16 \&gt;" alt="" coords="6,6,270,32"><area shape="rect" href="classPxObservable.html" title="Observable interface for classes which can send out state change notifications." alt="" coords="215,96,322,123"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxRigidActor-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the rigid actor object.  <a href="#1130f92afcba590b04b1e51b86f5377a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global Pose Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722">getGlobalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actors world space transform.  <a href="#6eb5e3d590e6087c930f8141d40de722"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#69f113040670657910dd850599832698">setGlobalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, bool wake=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <a href="#69f113040670657910dd850599832698"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Shapes</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#4023bdc10613959dec2b9ef947814866">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, <a class="el" href="classPxMaterial.html">PxMaterial</a> *const *materials, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> materialCount, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localPose=PxTransform::createIdentity())=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor.  <a href="#4023bdc10613959dec2b9ef947814866"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_FORCE_INLINE <a class="el" href="classPxShape.html">PxShape</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#b801a6253517d635055e6bb0f52f4510">createShape</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;material, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;localPose=PxTransform::createIdentity())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new shape with default properties and a single material adds it to the list of shapes of this actor.  <a href="#b801a6253517d635055e6bb0f52f4510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112">getNbShapes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <a href="#e5c3534de94642c5980d29f4c49bc112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec">getShapes</a> (<a class="el" href="classPxShape.html">PxShape</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <a href="#22ef86619d7a6de688b9ef2b0ad7bcec"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Constraints</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172">getNbConstraints</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <a href="#d941cfa63351e7ff6095a4afbe2d9172"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <a href="#c88777d5457f87247f5625094eb2be57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#1780ac9aed1b9871e72765ed63f9ff09">PxRigidActor</a> (<a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#e4d374e43e502bdb761d020048f8a7fa">PxRigidActor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#aa01a5b7ff077d01da077a5c8163609f">~PxRigidActor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidActor.html#e644382039f621f73ca7db7aa9d2e0cf">isKindOf</a> (const char *name) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> represents a base class shared between dynamic and static rigid bodies in the physics SDK. 
<p>
<a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> objects specify the geometry of the object by defining a set of attached shapes (see <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a>, <a class="el" href="classPxRigidActor.html#4023bdc10613959dec2b9ef947814866" title="Creates a new shape with default properties and a list of materials and adds it to...">createShape()</a>).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> PxRigidActorDesc </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="1780ac9aed1b9871e72765ed63f9ff09"></a><!-- doxytag: member="PxRigidActor::PxRigidActor" ref="1780ac9aed1b9871e72765ed63f9ff09" args="(PxRefResolver &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxRigidActor::PxRigidActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e4d374e43e502bdb761d020048f8a7fa"></a><!-- doxytag: member="PxRigidActor::PxRigidActor" ref="e4d374e43e502bdb761d020048f8a7fa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxRigidActor::PxRigidActor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aa01a5b7ff077d01da077a5c8163609f"></a><!-- doxytag: member="PxRigidActor::~PxRigidActor" ref="aa01a5b7ff077d01da077a5c8163609f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxRigidActor::~PxRigidActor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b801a6253517d635055e6bb0f52f4510"></a><!-- doxytag: member="PxRigidActor::createShape" ref="b801a6253517d635055e6bb0f52f4510" args="(const PxGeometry &amp;geometry, const PxMaterial &amp;material, const PxTransform &amp;localPose=PxTransform::createIdentity())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_FORCE_INLINE <a class="el" href="classPxShape.html">PxShape</a>* PxRigidActor::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxMaterial.html">PxMaterial</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>material</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localPose</em> = <code>PxTransform::createIdentity()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new shape with default properties and a single material adds it to the list of shapes of this actor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Mass properties of dynamic rigid actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a> to do that.<p>
The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>). The only exception are triangle mesh, heightfield or plane geometry shapes if the actor is not a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a>. In these cases the eSIMULATION_SHAPE flag is omitted.<p>
Creating compounds with a very large number of shapes may adversly affect performance and stability.</dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the shape. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>material</em>&nbsp;</td><td>the material for the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localPose</em>&nbsp;</td><td>optional actor-relative pose of the shape</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly created shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Deletes the shape.">PxShape::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4023bdc10613959dec2b9ef947814866"></a><!-- doxytag: member="PxRigidActor::createShape" ref="4023bdc10613959dec2b9ef947814866" args="(const PxGeometry &amp;geometry, PxMaterial *const *materials, PxU32 materialCount, const PxTransform &amp;localPose=PxTransform::createIdentity())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxShape.html">PxShape</a>* PxRigidActor::createShape           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> *const *&nbsp;</td>
          <td class="paramname"> <em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>materialCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>localPose</em> = <code>PxTransform::createIdentity()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new shape with default properties and a list of materials and adds it to the list of shapes of this actor. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Mass properties of dynamic rigid actors will not automatically be recomputed to reflect the new mass distribution implied by the shape. Follow this call with a call to the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a> to do that.<p>
The default shape flags to be set are: eVISUALIZATION, eSIMULATION_SHAPE, eSCENE_QUERY_SHAPE (see <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>). The only exception are triangle mesh, heightfield or plane geometry shapes if the actor is not a <a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a>. In these cases the eSIMULATION_SHAPE flag is omitted.<p>
Creating compounds with a very large number of shapes may adversly affect performance and stability.</dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>the geometry of the shape. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materials</em>&nbsp;</td><td>a pointer to an array of material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materialCount</em>&nbsp;</td><td>the count of materials </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localPose</em>&nbsp;</td><td>optional actor-relative pose of the shape</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly created shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Deletes the shape.">PxShape::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c88777d5457f87247f5625094eb2be57"></a><!-- doxytag: member="PxRigidActor::getConstraints" ref="c88777d5457f87247f5625094eb2be57" args="(PxConstraint **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxRigidActor::getConstraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConstraint.html">PxConstraint</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the constraint shader pointers belonging to the actor. 
<p>
You can retrieve the number of constraint shader pointers by calling <a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172" title="Returns the number of constraint shaders attached to the actor.">getNbConstraints()</a><p>
Note: Removing constraint shaders with <a class="el" href="classPxConstraint.html#8153c211d21fff49565e7e06e475d5cc">PxConstraint::release()</a> will invalidate the pointer of the released constraint.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the constraint shader pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first constraint pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shader pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="a plugin class for implementing constraints">PxConstraint</a> <a class="el" href="classPxRigidActor.html#d941cfa63351e7ff6095a4afbe2d9172" title="Returns the number of constraint shaders attached to the actor.">getNbConstraints()</a> <a class="el" href="classPxConstraint.html#8153c211d21fff49565e7e06e475d5cc">PxConstraint::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6eb5e3d590e6087c930f8141d40de722"></a><!-- doxytag: member="PxRigidActor::getGlobalPose" ref="6eb5e3d590e6087c930f8141d40de722" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxRigidActor::getGlobalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the actors world space transform. 
<p>
The <a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722" title="Retrieves the actors world space transform.">getGlobalPose()</a> method retrieves the actor's current actor space to world space transformation.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Global pose of object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#69f113040670657910dd850599832698" title="Method for setting an actor&#39;s pose in the world.">PxRigidDynamic.setGlobalPose()</a> <a class="el" href="classPxRigidActor.html#69f113040670657910dd850599832698" title="Method for setting an actor&#39;s pose in the world.">PxRigidStatic.setGlobalPose()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00064">PxShapeExt::getGlobalPose()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d941cfa63351e7ff6095a4afbe2d9172"></a><!-- doxytag: member="PxRigidActor::getNbConstraints" ref="d941cfa63351e7ff6095a4afbe2d9172" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxRigidActor::getNbConstraints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of constraint shaders attached to the actor. 
<p>
You can use <a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57" title="Retrieve all the constraint shader pointers belonging to the actor.">getConstraints()</a> to retrieve the constraint shader pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shaders attached to this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxConstraint.html" title="a plugin class for implementing constraints">PxConstraint</a> <a class="el" href="classPxRigidActor.html#c88777d5457f87247f5625094eb2be57" title="Retrieve all the constraint shader pointers belonging to the actor.">getConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5c3534de94642c5980d29f4c49bc112"></a><!-- doxytag: member="PxRigidActor::getNbShapes" ref="e5c3534de94642c5980d29f4c49bc112" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxRigidActor::getNbShapes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of shapes assigned to the actor. 
<p>
You can use <a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec" title="Retrieve all the shape pointers belonging to the actor.">getShapes()</a> to retrieve the shape pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of shapes associated with this actor.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxRigidActor.html#22ef86619d7a6de688b9ef2b0ad7bcec" title="Retrieve all the shape pointers belonging to the actor.">getShapes()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="22ef86619d7a6de688b9ef2b0ad7bcec"></a><!-- doxytag: member="PxRigidActor::getShapes" ref="22ef86619d7a6de688b9ef2b0ad7bcec" args="(PxShape **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxRigidActor::getShapes           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the shape pointers belonging to the actor. 
<p>
These are the shapes used by the actor for collision detection.<p>
You can retrieve the number of shape pointers by calling <a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112" title="Returns the number of shapes assigned to the actor.">getNbShapes()</a><p>
Note: Removing shapes with <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Deletes the shape.">PxShape::release()</a> will invalidate the pointer of the released shape.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the shape pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first shape pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of shape pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> <a class="el" href="classPxRigidActor.html#e5c3534de94642c5980d29f4c49bc112" title="Returns the number of shapes assigned to the actor.">getNbShapes()</a> <a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37" title="Deletes the shape.">PxShape::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e644382039f621f73ca7db7aa9d2e0cf"></a><!-- doxytag: member="PxRigidActor::isKindOf" ref="e644382039f621f73ca7db7aa9d2e0cf" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxRigidActor::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classPxActor.html#fe6ddb3480f61350f60496c2e903c5c7">PxActor</a>.</p>

<p>Reimplemented in <a class="el" href="classPxArticulationLink.html#45d7a988876af31572acca1376401c18">PxArticulationLink</a>, <a class="el" href="classPxRigidBody.html#d2e17e08871d8a2f492aee495550a0a0">PxRigidBody</a>, <a class="el" href="classPxRigidDynamic.html#0ed60c0a05771d8679069a46b778f8f8">PxRigidDynamic</a>, and <a class="el" href="classPxRigidStatic.html#b8f40a26cecf625a44d573d611e20842">PxRigidStatic</a>.</p>

<p>References <a class="el" href="PxActor_8h-source.html#l00388">PxActor::isKindOf()</a>.</p>

<p>Referenced by <a class="el" href="PxRigidStatic_8h-source.html#l00080">PxRigidStatic::isKindOf()</a>, and <a class="el" href="PxRigidBody_8h-source.html#l00286">PxRigidBody::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1130f92afcba590b04b1e51b86f5377a"></a><!-- doxytag: member="PxRigidActor::release" ref="1130f92afcba590b04b1e51b86f5377a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the rigid actor object. 
<p>
Also releases any shapes associated with the actor.<p>
Releasing an actor will affect any objects that are connected to the actor (constraint shaders like joints etc.). Such connected objects will be deleted upon scene deletion, or explicitly by the user by calling <a class="el" href="classPxRigidActor.html#1130f92afcba590b04b1e51b86f5377a" title="Deletes the rigid actor object.">release()</a> on these objects. It is recommended to always remove all objects that reference actors before the actors themselves are removed. It is not possible to retrieve list of dead connected objects.<p>
Calls <a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762" title="Deletes the actor.">PxActor::release()</a> so you might want to check the documentation of that method as well.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762" title="Deletes the actor.">PxActor::release()</a> </dd></dl>

<p>Implements <a class="el" href="classPxActor.html#589a4e70ef83b583ee6a4fc5c7767762">PxActor</a>.</p>

<p>Implemented in <a class="el" href="classPxArticulationLink.html#ec08ba9942f441a813bdd07547d9b695">PxArticulationLink</a>, and <a class="el" href="classPxRigidStatic.html#90cb91e05c4179714de909283958e08a">PxRigidStatic</a>.</p>

</div>
</div><p>
<a class="anchor" name="69f113040670657910dd850599832698"></a><!-- doxytag: member="PxRigidActor::setGlobalPose" ref="69f113040670657910dd850599832698" args="(const PxTransform &amp;pose, bool wake=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxRigidActor::setGlobalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wake</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Method for setting an actor's pose in the world. 
<p>
This method instantaneously changes the actor space to world space transformation.<p>
This method is mainly for dynamic rigid bodies (see <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>). Calling this method on static actors is likely to result in a performance penalty, since internal optimization structures for static actors may need to be recomputed. In addition, moving static actors will not interact correctly with dynamic actors or joints.<p>
To directly control an actor's position and have it correctly interact with dynamic bodies and joints, create a dynamic body with the <a class="el" href="structPxRigidDynamicFlag.html#bd6137b6192c71260bfe7d7608e7a428b07681351de60a2ed7fe8a4ce2561b57" title="Enables kinematic mode for the actor.">PxRigidDynamicFlag::eKINEMATIC</a> flag, then use the setKinematicTarget() commands to define its path.<p>
Even when moving dynamic actors, exercise restraint in making use of this method. Where possible, avoid:<p>
<ul>
<li>moving actors into other actors, thus causing interpenetration (an invalid physical state)</li>
</ul>
<ul>
<li>moving an actor that is connected by a joint to another away from the other (thus causing joint error)</li>
</ul>
<b>Sleeping:</b> This call wakes dynamic actors if they are sleeping and the wake parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Transformation from the actors local frame to the global frame. <b>Range:</b> rigid body transform. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wake</em>&nbsp;</td><td>whether to wake the object if it is dynamic. This parameter has no effect for static actors</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#6eb5e3d590e6087c930f8141d40de722" title="Retrieves the actors world space transform.">getGlobalPose()</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidActor_8h-source.html">PxRigidActor.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
