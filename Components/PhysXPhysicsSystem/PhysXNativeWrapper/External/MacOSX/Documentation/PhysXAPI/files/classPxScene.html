<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxScene Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxScene Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxScene" -->A scene is a collection of bodies, particle systems and constraints which can interact.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxScene_8h-source.html">PxScene.h</a>&gt;</code>
<p>

<p>
<a href="classPxScene-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Simulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d">simulate</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> elapsedTime, physx::pxtask::BaseTask *completionTask=NULL, void *scratchMemBlock=0, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> scratchMemBlockSize=0, bool controlSimulation=true)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the simulation by an elapsedTime time.  <a href="#b87a979561b8188f8f17bf177f27a95d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5">checkResults</a> (bool block=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This checks to see if the simulation run has completed.  <a href="#6f45a8ee04f0bcd2c23b23daa176bee5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults</a> (bool block=false, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *errorState=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#336aeaed9954dc3008631a61423914da">flush</a> (bool sendPendingReports=false)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear internal buffers and free memory.  <a href="#336aeaed9954dc3008631a61423914da"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Threads and Memory</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
physx::pxtask::TaskManager *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4f6b4a69011e064c12f594a43fd10260">getTaskManager</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the task manager associated with this scene.  <a href="#4f6b4a69011e064c12f594a43fd10260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ad9cc8bf329f4de4b407436f5cd38c98">setSolverBatchSize</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> solverBatchSize)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of actors required to spawn a separate rigid body solver thread.  <a href="#ad9cc8bf329f4de4b407436f5cd38c98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#dd966317a1feb083e273fd8c12f454b5">getSolverBatchSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of actors required to spawn a separate rigid body solver thread.  <a href="#dd966317a1feb083e273fd8c12f454b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966">setNbContactDataBlocks</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> numBlocks)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set the cache blocks that can be used during <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a>.  <a href="#148be23880c4e2d67f9f772066a9f966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697">getNbContactDataBlocksUsed</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the number of cache blocks currently used by the scene  <a href="#b6224a915d459fb6a1c0899a080f5697"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329">getMaxNbContactDataBlocksUsed</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the maximum number of cache blocks used by the scene  <a href="#a3c625507d5cfaf0f1cb9d26f66be329"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Create/Release Objects</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#be7b1220a8798cc9b0ca58fb074141fb">addArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an articulation to this scene.  <a href="#be7b1220a8798cc9b0ca58fb074141fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4f53c1ba66a089688d4704bd295a2ca5">removeArticulation</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;articulation)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an articulation from this scene.  <a href="#4f53c1ba66a089688d4704bd295a2ca5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#dd384929e3a8a81881f7e616c7a0539b">addActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an actor to this scene.  <a href="#dd384929e3a8a81881f7e616c7a0539b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#acd3e4ee7ec859a67e4bd908e2af9eba">addActors</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> nbActors, <a class="el" href="classPxActor.html">PxActor</a> **actors)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#3626f6101e56b30ac641aadd813b04ed">removeActor</a> (<a class="el" href="classPxActor.html">PxActor</a> &amp;actor)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an actor from this scene.  <a href="#3626f6101e56b30ac641aadd813b04ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7e1a5eaea13e5f97415dd14690e7ce38">addAggregate</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;aggregate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an aggregate to this scene.  <a href="#7e1a5eaea13e5f97415dd14690e7ce38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a3df37bb8adfc75962d6dccbd4ceda5c">removeAggregate</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;aggregate)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an aggregate from this scene.  <a href="#a3df37bb8adfc75962d6dccbd4ceda5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a95c08ef234a55388b297ec657487b69">getNbAggregates</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of aggregates in the scene.  <a href="#a95c08ef234a55388b297ec657487b69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#f25335de0c6012d9a5d7e78c8272824e">getAggregates</a> (<a class="el" href="classPxAggregate.html">PxAggregate</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the aggregates in the scene.  <a href="#f25335de0c6012d9a5d7e78c8272824e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dominance</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4221eb7b6fd63257f4f3b503ac066a46">setDominanceGroupPair</a> (<a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group2, const <a class="el" href="structPxConstraintDominance.html">PxConstraintDominance</a> &amp;dominance)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies the dominance behavior of constraints between two actors with two certain dominance groups.  <a href="#4221eb7b6fd63257f4f3b503ac066a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxConstraintDominance.html">PxConstraintDominance</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#bd7e9615f7f01dfe7821bd44deeb264d">getDominanceGroupPair</a> (<a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group1, <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> group2) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Samples the dominance matrix.  <a href="#bd7e9615f7f01dfe7821bd44deeb264d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Enumeration</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a478c375feae299d9c851ed0cf7f00fe">getNbActors</a> (<a class="el" href="classPxFlags.html">PxActorTypeSelectionFlags</a> types) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the number of actors of certain types in the scene.  <a href="#a478c375feae299d9c851ed0cf7f00fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6dcdcb8477c6d9eb7e789eb659919999">getActors</a> (<a class="el" href="classPxFlags.html">PxActorTypeSelectionFlags</a> types, <a class="el" href="classPxActor.html">PxActor</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an array of all the actors of certain types in the scene.  <a href="#6dcdcb8477c6d9eb7e789eb659919999"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxActiveTransform.html">PxActiveTransform</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#023d910b2045f286979cefc238f9df19">getActiveTransforms</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;nbTransformsOut, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step.  <a href="#023d910b2045f286979cefc238f9df19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b09a3fad6a720283c0a95fe7f76973e4">getNbArticulations</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of articulations in the scene.  <a href="#b09a3fad6a720283c0a95fe7f76973e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#eca9cb7d9353559e214a51a599e28a85">getArticulations</a> (<a class="el" href="classPxArticulation.html">PxArticulation</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the articulations in the scene.  <a href="#eca9cb7d9353559e214a51a599e28a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7ee023de370ac90a7d4c204d916d3080">getNbConstraints</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of constraint shaders in the scene.  <a href="#7ee023de370ac90a7d4c204d916d3080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1e9919abdfb23495a84f47c5157a67b1">getConstraints</a> (<a class="el" href="classPxConstraint.html">PxConstraint</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> startIndex=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the constraint shaders in the scene.  <a href="#1e9919abdfb23495a84f47c5157a67b1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiclient</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a">createClient</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserves a new client ID.  <a href="#285849425521dd0344f55b4a7c0a834a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b3207044e1825469dbd1a19880baef14">setClientBehaviorBits</a> (<a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> clientBehaviorBits)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets behavior bits for a client.  <a href="#b3207044e1825469dbd1a19880baef14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#33266f793c6ce63e58a9d363492c2c2e">getClientBehaviorBits</a> (<a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves behavior bits for a client.  <a href="#33266f793c6ce63e58a9d363492c2c2e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Callbacks</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#06eb4fdf45e324c6110fd9fd5f28ca03">setSimulationEventCallback</a> (<a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *callback, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <a href="#06eb4fdf45e324c6110fd9fd5f28ca03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#17361190e6640cbd1a5a9bc82796d4fc">getSimulationEventCallback</a> (<a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> client=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the simulationEventCallback pointer set with <a class="el" href="classPxScene.html#06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a>.  <a href="#17361190e6640cbd1a5a9bc82796d4fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e">setContactModifyCallback</a> (<a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  <a href="#eec3367a4461c1ab2e552acdb8c0609e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1978693b355df49712d7e59c10c4115d">getContactModifyCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>.  <a href="#1978693b355df49712d7e59c10c4115d"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Filtering</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5d004fdc88ed31447aa57ee4f98c14ea">getFilterShaderData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the shared global filter data in use for this scene.  <a href="#5d004fdc88ed31447aa57ee4f98c14ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ce291f68b365a4f1aaa291ba940eff9a">getFilterShaderDataSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>).  <a href="#ce291f68b365a4f1aaa291ba940eff9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a3f57314433de21448966c1d9004d71a">getFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the custom collision filter shader in use for this scene.  <a href="#a3f57314433de21448966c1d9004d71a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#2b4c17b1a16df239e5d6a2e0e6f8b633">getFilterCallback</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the custom collision filter callback in use for this scene.  <a href="#2b4c17b1a16df239e5d6a2e0e6f8b633"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene Query</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#2a2a206b9e510e37e82f79118baf31cc">createBatchQuery</a> (const <a class="el" href="classPxBatchQueryDesc.html">PxBatchQueryDesc</a> &amp;desc)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a BatchQuery object.  <a href="#2a2a206b9e510e37e82f79118baf31cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PX_DEPRECATED <br class="typebreak">
<a class="el" href="classPxSweepCache.html">PxSweepCache</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#9f7799979371a651a8b64f5ca261bb90">createSweepCache</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> dimensions=5.0f)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a sweep cache, for use with <a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74" title="Performs a linear sweep through space with a compound of geometry objects, returning...">PxBatchQuery::linearCompoundGeometrySweepMultiple()</a>. See the Guide, "Sweep API" section for more information.  <a href="#9f7799979371a651a8b64f5ca261bb90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#bf2322887ca4db2fdea0229a44e2892c">setDynamicTreeRebuildRateHint</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> dynamicTreeRebuildRateHint)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rebuild rate of the dynamic tree pruning structure.  <a href="#bf2322887ca4db2fdea0229a44e2892c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#e220420fdd08f0dabee8b30f5ef2de68">getDynamicTreeRebuildRateHint</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the rebuild rate of the dynamic tree pruning structure.  <a href="#e220420fdd08f0dabee8b30f5ef2de68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#68f8e25d497c46cfe5a8f2a573dfd20c">raycastAny</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;hit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast returning any blocking hit, not necessarily the closest.  <a href="#68f8e25d497c46cfe5a8f2a573dfd20c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#486fdf6c044cd85432a8c505d022f784">raycastSingle</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> &amp;hit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast returning a single result.  <a href="#486fdf6c044cd85432a8c505d022f784"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#5a7ed4b2542fa5195fcf71b92b544c45">raycastMultiple</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> *hitBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> hitBufferSize, bool &amp;blockingHit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast returning multiple results.  <a href="#5a7ed4b2542fa5195fcf71b92b544c45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4147b84f33ff7e1f3c4e562bdc8dd7a0">sweepAny</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> queryFlags, <a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;hit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep returning any blocking hit, not necessarily the closest.  <a href="#4147b84f33ff7e1f3c4e562bdc8dd7a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#3ad1aa60da4c4f165291be7d1118b531">sweepAny</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> **geometryList, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseList, const <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> geometryCount, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> queryFlags, <a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;hit, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep of geometry compound returning any blocking hit, not necessarily the closest.  <a href="#3ad1aa60da4c4f165291be7d1118b531"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#71a99edf703ffc6f0ac7d0b40f3d62e1">sweepSingle</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;hit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep returning a single result.  <a href="#71a99edf703ffc6f0ac7d0b40f3d62e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#bb7901989e0980b324ebcaa476344e45">sweepSingle</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> **geometryList, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseList, const <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> geometryCount, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;hit, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep of geometry compound returning a single result.  <a href="#bb7901989e0980b324ebcaa476344e45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#cb3acf236345ab8d643ef94f173e7bb3">sweepMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxSweepHit.html">PxSweepHit</a> *hitBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> hitBufferSize, bool &amp;blockingHit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep returning multiple results.  <a href="#cb3acf236345ab8d643ef94f173e7bb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#8e0d09e2ed1553575e1ef2f2924f8b21">sweepMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> **geometryList, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseList, const <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> geometryCount, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags, <a class="el" href="structPxSweepHit.html">PxSweepHit</a> *hitBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> hitBufferSize, bool &amp;blockingHit, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep of geometry compound returning multiple results.  <a href="#8e0d09e2ed1553575e1ef2f2924f8b21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#1997dd1b7ae2dc99e93fdbdc264fcf73">overlapMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, <a class="el" href="classPxShape.html">PxShape</a> **hitBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> hitBufferSize, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test overlap between a geometry and objects in the scene.  <a href="#1997dd1b7ae2dc99e93fdbdc264fcf73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b1479ae5b2c484e34d2f9215157efba3">overlapAny</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, <a class="el" href="classPxShape.html">PxShape</a> *&amp;hit, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *filterCall=NULL, <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> queryClient=<a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test returning, for a given geometry, any overlapping object in the scene.  <a href="#b1479ae5b2c484e34d2f9215157efba3"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Visualization and Statistics</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a">setVisualizationParameter</a> (<a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a> param, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that lets you set debug visualization parameters.  <a href="#4055d302466a1f5cd9d481028b66b20a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7c036458140a45b23facb9cf2a9cdb84">getVisualizationParameter</a> (<a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a> paramEnum) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function that lets you query debug visualization parameters.  <a href="#7c036458140a45b23facb9cf2a9cdb84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#b562ba2df953188a7e2b99f7ddcda5dc">setVisualizationCullingBox</a> (const <a class="el" href="classPxBounds3.html">PxBounds3</a> &amp;box)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classPxBounds3.html">PxBounds3</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#8f92b0e0f1967c4051ba47df01671671">getVisualizationCullingBox</a> () const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classPxRenderBuffer.html">PxRenderBuffer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#35f231796a325fcf587e681831c5fcb5">getRenderBuffer</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the render buffer.  <a href="#35f231796a325fcf587e681831c5fcb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#7abb1e1354ae3258b91fc097e9d682b8">getSimulationStatistics</a> (<a class="el" href="classPxSimulationStatistics.html">PxSimulationStatistics</a> &amp;stats) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve statistics for the current simulation step.  <a href="#7abb1e1354ae3258b91fc097e9d682b8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#37b5f1aed7edbae16640e0555d9271ae">PxScene</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#ba2cd20df65cecbc62a08415f9a8a4b8">~PxScene</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Basics</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#64fbe5f25cef90d47fcb1c6428efe15a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the scene.  <a href="#61f68a8c516aea477cc5328b00c976ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#43fd03c451d881d29080a53ee2e50914">saveToDesc</a> (<a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;desc) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves the Scene descriptor.  <a href="#43fd03c451d881d29080a53ee2e50914"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6610c08a5a92c894dcac9d658e48b7de">setFlag</a> (<a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a scene flag. You can only set one flag at a time.  <a href="#6610c08a5a92c894dcac9d658e48b7de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxSceneFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#0acbc97457d54775b6402f3790c3513b">getFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scene flags.  <a href="#0acbc97457d54775b6402f3790c3513b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#575ed34c73adbd61892d728a688479f3">setGravity</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;vec)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a constant gravity for the entire scene.  <a href="#575ed34c73adbd61892d728a688479f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6fe48dbf9144be415d63f1d2f3ce0b16">getGravity</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current gravity setting.  <a href="#6fe48dbf9144be415d63f1d2f3ce0b16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxPhysics.html">PxPhysics</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#a77b43c78a62a0c771e5e6404fc55ffe">getPhysics</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this method to retrieve the Physics SDK.  <a href="#a77b43c78a62a0c771e5e6404fc55ffe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#6003ed1a202d434ef64439741e3f2de2">getTimestamp</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene's internal timestamp, increased each time a simulation step is completed.  <a href="#6003ed1a202d434ef64439741e3f2de2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxScene.html#32850ee34d1736811c1e93e25c689a68">getSceneQueryStaticTimestamp</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  <a href="#32850ee34d1736811c1e93e25c689a68"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A scene is a collection of bodies, particle systems and constraints which can interact. 
<p>
The scene simulates the behavior of these objects over time. Several scenes may exist at the same time, but each body, particle system or constraint is specific to a scene -- they may not be shared.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> <a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics.createScene()</a> <a class="el" href="classPxScene.html#61f68a8c516aea477cc5328b00c976ed" title="Deletes the scene.">release()</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="37b5f1aed7edbae16640e0555d9271ae"></a><!-- doxytag: member="PxScene::PxScene" ref="37b5f1aed7edbae16640e0555d9271ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxScene::PxScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ba2cd20df65cecbc62a08415f9a8a4b8"></a><!-- doxytag: member="PxScene::~PxScene" ref="ba2cd20df65cecbc62a08415f9a8a4b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxScene::~PxScene           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="dd384929e3a8a81881f7e616c7a0539b"></a><!-- doxytag: member="PxScene::addActor" ref="dd384929e3a8a81881f7e616c7a0539b" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an actor to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the actor is already assigned to a scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and a error is issued.<p>
You can not add individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) to the scene. Use <a class="el" href="classPxScene.html#be7b1220a8798cc9b0ca58fb074141fb" title="Adds an articulation to this scene.">addArticulation()</a> instead.<p>
If the actor is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then each assigned <a class="el" href="classPxConstraint.html" title="a plugin class for implementing constraints">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>Actor to add to scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="acd3e4ee7ec859a67e4bd908e2af9eba"></a><!-- doxytag: member="PxScene::addActors" ref="acd3e4ee7ec859a67e4bd908e2af9eba" args="(PxU32 nbActors, PxActor **actors)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>nbActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>actors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7e1a5eaea13e5f97415dd14690e7ce38"></a><!-- doxytag: member="PxScene::addAggregate" ref="7e1a5eaea13e5f97415dd14690e7ce38" args="(PxAggregate &amp;aggregate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an aggregate to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the aggregate is already assigned to a scene (see <a class="el" href="classPxAggregate.html#a70f305e7f2934d99afd74d28b0c0194" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and a error is issued.<p>
If the aggregate already contains actors, those actors are added to the scene as well.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aggregate</em>&nbsp;</td><td>Aggregate to add to scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="be7b1220a8798cc9b0ca58fb074141fb"></a><!-- doxytag: member="PxScene::addArticulation" ref="be7b1220a8798cc9b0ca58fb074141fb" args="(PxArticulation &amp;articulation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::addArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds an articulation to this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the articulation is already assigned to a scene (see <a class="el" href="classPxArticulation.html#fd299e63283d38910c48243e6d9755dd" title="Retrieves the scene which this articulation belongs to.">PxArticulation::getScene</a>), the call is ignored and a error is issued.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>Articulation to add to scene. See <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f45a8ee04f0bcd2c23b23daa176bee5"></a><!-- doxytag: member="PxScene::checkResults" ref="6f45a8ee04f0bcd2c23b23daa176bee5" args="(bool block=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::checkResults           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This checks to see if the simulation run has completed. 
<p>
This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results are available.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a2a206b9e510e37e82f79118baf31cc"></a><!-- doxytag: member="PxScene::createBatchQuery" ref="2a2a206b9e510e37e82f79118baf31cc" args="(const PxBatchQueryDesc &amp;desc)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBatchQuery.html">PxBatchQuery</a>* PxScene::createBatchQuery           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBatchQueryDesc.html">PxBatchQueryDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a BatchQuery object. 
<p>
Scene queries like raycasts, overlap tests and sweeps are batched in this object and are then executed at once. See <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor of scene query. Scene Queries need to register a callback. See <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="285849425521dd0344f55b4a7c0a834a"></a><!-- doxytag: member="PxScene::createClient" ref="285849425521dd0344f55b4a7c0a834a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> PxScene::createClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reserves a new client ID. 
<p>
PX_DEFAULT_CLIENT is always available as the default clientID. Additional clients are returned by this function. Clients cannot be released once created. An error is reported when more than a supported number of clients (currently 128) are created. 
</div>
</div><p>
<a class="anchor" name="9f7799979371a651a8b64f5ca261bb90"></a><!-- doxytag: member="PxScene::createSweepCache" ref="9f7799979371a651a8b64f5ca261bb90" args="(PxReal dimensions=5.0f)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PX_DEPRECATED <a class="el" href="classPxSweepCache.html">PxSweepCache</a>* PxScene::createSweepCache           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>dimensions</em> = <code>5.0f</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a sweep cache, for use with <a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74" title="Performs a linear sweep through space with a compound of geometry objects, returning...">PxBatchQuery::linearCompoundGeometrySweepMultiple()</a>. See the Guide, "Sweep API" section for more information. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimensions</em>&nbsp;</td><td>the dimensions of the sweep cache. Objects within this distance of the swept volume will be cached</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSweepCache.html">PxSweepCache</a> <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b34e054ccf428a1cdbd81bf1e2b87fae"></a><!-- doxytag: member="PxScene::fetchResults" ref="b34e054ccf428a1cdbd81bf1e2b87fae" args="(bool block=false, PxU32 *errorState=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::fetchResults           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> *&nbsp;</td>
          <td class="paramname"> <em>errorState</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the big brother to <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> it basically does the following:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> ( <a class="code" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults</a>(block) )
    {
        fire appropriate callbacks
        swap buffers
        <span class="keywordflow">return</span> <span class="keyword">true</span>
    }
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>block</em>&nbsp;</td><td>When set to true will block until the condition is met. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>errorState</em>&nbsp;</td><td>Used to retrieve hardware error codes. A non zero value indicates an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the results have been fetched.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="336aeaed9954dc3008631a61423914da"></a><!-- doxytag: member="PxScene::flush" ref="336aeaed9954dc3008631a61423914da" args="(bool sendPendingReports=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::flush           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendPendingReports</em> = <code>false</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear internal buffers and free memory. 
<p>
This method can be used to clear buffers and free internal memory without having to destroy the scene. Can be usefull if the physics data gets streamed in and a checkpoint with a clean state should be created.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is not allowed to call this method while the simulation is running. The call will fail.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendPendingReports</em>&nbsp;</td><td>When set to true pending reports will be sent out before the buffers get cleaned up (for instance lost touch contact/trigger reports due to deleted objects). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="023d910b2045f286979cefc238f9df19"></a><!-- doxytag: member="PxScene::getActiveTransforms" ref="023d910b2045f286979cefc238f9df19" args="(PxU32 &amp;nbTransformsOut, PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxActiveTransform.html">PxActiveTransform</a>* PxScene::getActiveTransforms           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>nbTransformsOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the <a class="el" href="classPxScene.html" title="A scene is a collection of bodies, particle systems and constraints which can interact...">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step. 
<p>
Note: <a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c5374265e70916e1547948697848370e74d" title="Enable Active Transform Notification.">PxSceneFlag::eENABLE_ACTIVETRANSFORMS</a> must be set. Multiclient behavior: Active transforms now return only the list of active actors owned by the specified client.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>nbTransformsOut</em>&nbsp;</td><td>The number of transforms returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose actors the caller is interested in.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the list of PxActiveTransforms generated during the last call to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxActiveTransform.html" title="Data struct for use with Active Transform Notification. Used with PxScene::getActiveTransforms()...">PxActiveTransform</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6dcdcb8477c6d9eb7e789eb659919999"></a><!-- doxytag: member="PxScene::getActors" ref="6dcdcb8477c6d9eb7e789eb659919999" args="(PxActorTypeSelectionFlags types, PxActor **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxActorTypeSelectionFlags</a>&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve an array of all the actors of certain types in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>types</em>&nbsp;</td><td>Combination of actor types to retrieve. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive actor pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of actors written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#a478c375feae299d9c851ed0cf7f00fe" title="Retrieve the number of actors of certain types in the scene.">getNbActors()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f25335de0c6012d9a5d7e78c8272824e"></a><!-- doxytag: member="PxScene::getAggregates" ref="f25335de0c6012d9a5d7e78c8272824e" args="(PxAggregate **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getAggregates           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the aggregates in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive aggregates pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first aggregate pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of aggregates written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#a95c08ef234a55388b297ec657487b69" title="Returns the number of aggregates in the scene.">getNbAggregates()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eca9cb7d9353559e214a51a599e28a85"></a><!-- doxytag: member="PxScene::getArticulations" ref="eca9cb7d9353559e214a51a599e28a85" args="(PxArticulation **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getArticulations           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the articulations in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive articulations pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first articulations pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of articulations written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b09a3fad6a720283c0a95fe7f76973e4" title="Returns the number of articulations in the scene.">getNbArticulations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="33266f793c6ce63e58a9d363492c2c2e"></a><!-- doxytag: member="PxScene::getClientBehaviorBits" ref="33266f793c6ce63e58a9d363492c2c2e" args="(PxClientID client) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getClientBehaviorBits           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves behavior bits for a client. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxClientBehaviorBit.html" title="Multiclient behavior bit flags for clients.">PxClientBehaviorBit</a> <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12" title="An ID to identify different clients for multiclient support.">PxClientID</a> <a class="el" href="classPxScene.html#b3207044e1825469dbd1a19880baef14" title="Sets behavior bits for a client.">setClientBehaviorBits()</a> <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e9919abdfb23495a84f47c5157a67b1"></a><!-- doxytag: member="PxScene::getConstraints" ref="1e9919abdfb23495a84f47c5157a67b1" args="(PxConstraint **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getConstraints           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConstraint.html">PxConstraint</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the constraint shaders in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to receive constraint shader pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startIndex</em>&nbsp;</td><td>Index of first constraint pointer to be retrieved </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of constraint shaders written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#7ee023de370ac90a7d4c204d916d3080" title="Returns the number of constraint shaders in the scene.">getNbConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1978693b355df49712d7e59c10c4115d"></a><!-- doxytag: member="PxScene::getContactModifyCallback" ref="1978693b355df49712d7e59c10c4115d" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a>* PxScene::getContactModifyCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> pointer set with <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current user contact modify callback pointer. See <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a> <a class="el" href="classPxScene.html#eec3367a4461c1ab2e552acdb8c0609e" title="Sets a user callback object, which receives callbacks on all contacts generated for...">setContactModifyCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd7e9615f7f01dfe7821bd44deeb264d"></a><!-- doxytag: member="PxScene::getDominanceGroupPair" ref="bd7e9615f7f01dfe7821bd44deeb264d" args="(PxDominanceGroup group1, PxDominanceGroup group2) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxConstraintDominance.html">PxConstraintDominance</a> PxScene::getDominanceGroupPair           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Samples the dominance matrix. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#4221eb7b6fd63257f4f3b503ac066a46" title="Specifies the dominance behavior of constraints between two actors with two certain...">setDominanceGroupPair()</a> <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> <a class="el" href="structPxConstraintDominance.html" title="Expresses the dominance relationship of a constraint. For the time being only three...">PxConstraintDominance</a> <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classPxActor.html#24602fee489b3e797ff0f82613eef755" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e220420fdd08f0dabee8b30f5ef2de68"></a><!-- doxytag: member="PxScene::getDynamicTreeRebuildRateHint" ref="e220420fdd08f0dabee8b30f5ef2de68" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getDynamicTreeRebuildRateHint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the rebuild rate of the dynamic tree pruning structure. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The rebuild rate of the dyamic tree pruning structure.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3" title="Hint for how much work should be done per simulation frame to rebuild the pruning...">PxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classPxScene.html#bf2322887ca4db2fdea0229a44e2892c" title="Sets the rebuild rate of the dynamic tree pruning structure.">setDynamicTreeRebuildRateHint()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b4c17b1a16df239e5d6a2e0e6f8b633"></a><!-- doxytag: member="PxScene::getFilterCallback" ref="2b4c17b1a16df239e5d6a2e0e6f8b633" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSimulationFilterCallback.html">PxSimulationFilterCallback</a>* PxScene::getFilterCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the custom collision filter callback in use for this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Filter callback class that defines the collision pair filtering.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#f7b94475075eb9b43ca32650cd169cc1" title="A custom collision filter callback which can be used to implement more complex filtering...">PxSceneDesc.filterCallback</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3f57314433de21448966c1d9004d71a"></a><!-- doxytag: member="PxScene::getFilterShader" ref="a3f57314433de21448966c1d9004d71a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3">PxSimulationFilterShader</a> PxScene::getFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the custom collision filter shader in use for this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Filter shader class that defines the collision pair filtering.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#9410287c6ea926dad9e2b2374541ad38" title="The custom filter shader to use for collision filtering.">PxSceneDesc.filterShader</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d004fdc88ed31447aa57ee4f98c14ea"></a><!-- doxytag: member="PxScene::getFilterShaderData" ref="5d004fdc88ed31447aa57ee4f98c14ea" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* PxScene::getFilterShaderData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the shared global filter data in use for this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The reference points to a copy of the original filter data specified in <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Shared filter data for filter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#ce291f68b365a4f1aaa291ba940eff9a" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData).">getFilterShaderDataSize()</a> <a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce291f68b365a4f1aaa291ba940eff9a"></a><!-- doxytag: member="PxScene::getFilterShaderDataSize" ref="ce291f68b365a4f1aaa291ba940eff9a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getFilterShaderDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of shared filter data [bytes].</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#5d004fdc88ed31447aa57ee4f98c14ea" title="Gets the shared global filter data in use for this scene.">getFilterShaderData()</a> <a class="el" href="classPxSceneDesc.html#710c03915bbaaa9bdf23925d535c3883" title="Size (in bytes) of the shared global filter data filterShaderData.">PxSceneDesc.filterShaderDataSize</a> <a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0acbc97457d54775b6402f3790c3513b"></a><!-- doxytag: member="PxScene::getFlags" ref="0acbc97457d54775b6402f3790c3513b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxSceneFlags</a> PxScene::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the scene flags. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The scene flags. See <a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fe48dbf9144be415d63f1d2f3ce0b16"></a><!-- doxytag: member="PxScene::getGravity" ref="6fe48dbf9144be415d63f1d2f3ce0b16" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxVec3.html">PxVec3</a> PxScene::getGravity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the current gravity setting. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current gravity for the scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#575ed34c73adbd61892d728a688479f3" title="Sets a constant gravity for the entire scene.">setGravity()</a> <a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20" title="Gravity vector.">PxSceneDesc.gravity</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3c625507d5cfaf0f1cb9d26f66be329"></a><!-- doxytag: member="PxScene::getMaxNbContactDataBlocksUsed" ref="a3c625507d5cfaf0f1cb9d26f66be329" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getMaxNbContactDataBlocksUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the maximum number of cache blocks used by the scene 
<p>
This function may not be called while the scene is simulating<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of cache blocks ever used by the scene</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to determine how many 16K blocks are initially reserved to store contact...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to determine how many 16K blocks are reserved to store contact, friction...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#336aeaed9954dc3008631a61423914da" title="Clear internal buffers and free memory.">flush()</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a478c375feae299d9c851ed0cf7f00fe"></a><!-- doxytag: member="PxScene::getNbActors" ref="a478c375feae299d9c851ed0cf7f00fe" args="(PxActorTypeSelectionFlags types) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getNbActors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxActorTypeSelectionFlags</a>&nbsp;</td>
          <td class="paramname"> <em>types</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the number of actors of certain types in the scene. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>types</em>&nbsp;</td><td>Combination of actor types. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of actors.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#6dcdcb8477c6d9eb7e789eb659919999" title="Retrieve an array of all the actors of certain types in the scene.">getActors()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a95c08ef234a55388b297ec657487b69"></a><!-- doxytag: member="PxScene::getNbAggregates" ref="a95c08ef234a55388b297ec657487b69" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getNbAggregates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of aggregates in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of aggregates in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#f25335de0c6012d9a5d7e78c8272824e" title="Retrieve all the aggregates in the scene.">getAggregates()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b09a3fad6a720283c0a95fe7f76973e4"></a><!-- doxytag: member="PxScene::getNbArticulations" ref="b09a3fad6a720283c0a95fe7f76973e4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getNbArticulations           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of articulations in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of articulations in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#eca9cb7d9353559e214a51a599e28a85" title="Retrieve all the articulations in the scene.">getArticulations()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ee023de370ac90a7d4c204d916d3080"></a><!-- doxytag: member="PxScene::getNbConstraints" ref="7ee023de370ac90a7d4c204d916d3080" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getNbConstraints           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of constraint shaders in the scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of constraint shaders in this scene.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#1e9919abdfb23495a84f47c5157a67b1" title="Retrieve all the constraint shaders in the scene.">getConstraints()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6224a915d459fb6a1c0899a080f5697"></a><!-- doxytag: member="PxScene::getNbContactDataBlocksUsed" ref="b6224a915d459fb6a1c0899a080f5697" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getNbContactDataBlocksUsed           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the number of cache blocks currently used by the scene 
<p>
This function may not be called while the scene is simulating<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of cache blocks currently used by the scene</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to determine how many 16K blocks are initially reserved to store contact...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to determine how many 16K blocks are reserved to store contact, friction...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#336aeaed9954dc3008631a61423914da" title="Clear internal buffers and free memory.">flush()</a> <a class="el" href="classPxScene.html#148be23880c4e2d67f9f772066a9f966" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a77b43c78a62a0c771e5e6404fc55ffe"></a><!-- doxytag: member="PxScene::getPhysics" ref="a77b43c78a62a0c771e5e6404fc55ffe" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxPhysics.html">PxPhysics</a>&amp; PxScene::getPhysics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this method to retrieve the Physics SDK. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The physics SDK this scene is associated with.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="35f231796a325fcf587e681831c5fcb5"></a><!-- doxytag: member="PxScene::getRenderBuffer" ref="35f231796a325fcf587e681831c5fcb5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classPxRenderBuffer.html">PxRenderBuffer</a>&amp; PxScene::getRenderBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the render buffer. 
<p>
This will contain the results of any active visualization for this scene.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not use this method while the simulation is running. Calls to this method while result in undefined behaviour.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The render buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRenderBuffer.html" title="Interface for points, lines, triangles, and text buffer.">PxRenderBuffer</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="32850ee34d1736811c1e93e25c689a68"></a><!-- doxytag: member="PxScene::getSceneQueryStaticTimestamp" ref="32850ee34d1736811c1e93e25c689a68" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getSceneQueryStaticTimestamp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>scene query static timestamp </dd></dl>

</div>
</div><p>
<a class="anchor" name="17361190e6640cbd1a5a9bc82796d4fc"></a><!-- doxytag: member="PxScene::getSimulationEventCallback" ref="17361190e6640cbd1a5a9bc82796d4fc" args="(PxClientID client=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a>* PxScene::getSimulationEventCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the simulationEventCallback pointer set with <a class="el" href="classPxScene.html#06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client whose callback object is to be returned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current user notify pointer. See <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#06eb4fdf45e324c6110fd9fd5f28ca03" title="Sets a user notify object which receives special simulation events when they occur...">setSimulationEventCallback()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7abb1e1354ae3258b91fc097e9d682b8"></a><!-- doxytag: member="PxScene::getSimulationStatistics" ref="7abb1e1354ae3258b91fc097e9d682b8" args="(PxSimulationStatistics &amp;stats) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::getSimulationStatistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSimulationStatistics.html">PxSimulationStatistics</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stats</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this method to retrieve statistics for the current simulation step. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>stats</em>&nbsp;</td><td>Used to retrieve statistics for the current simulation step.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationStatistics.html" title="Class used to retrieve statistics for a simulation step.">PxSimulationStatistics</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd966317a1feb083e273fd8c12f454b5"></a><!-- doxytag: member="PxScene::getSolverBatchSize" ref="dd966317a1feb083e273fd8c12f454b5" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getSolverBatchSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Current number of actors required to spawn a separate rigid body solver thread.</dd></dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PS3 : Not applicable </li>
<li>XB360: Yes </li>
<li>WII : Yes</li>
</ul>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797" title="Defines the number of actors required to spawn a separate rigid body solver thread...">PxSceneDesc.solverBatchSize</a> <a class="el" href="classPxScene.html#ad9cc8bf329f4de4b407436f5cd38c98" title="Sets the number of actors required to spawn a separate rigid body solver thread.">setSolverBatchSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f6b4a69011e064c12f594a43fd10260"></a><!-- doxytag: member="PxScene::getTaskManager" ref="4f6b4a69011e064c12f594a43fd10260" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual physx::pxtask::TaskManager* PxScene::getTaskManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the task manager associated with this scene. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the task manager associated with the scene </dd></dl>

</div>
</div><p>
<a class="anchor" name="6003ed1a202d434ef64439741e3f2de2"></a><!-- doxytag: member="PxScene::getTimestamp" ref="6003ed1a202d434ef64439741e3f2de2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxScene::getTimestamp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the scene's internal timestamp, increased each time a simulation step is completed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>scene timestamp </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f92b0e0f1967c4051ba47df01671671"></a><!-- doxytag: member="PxScene::getVisualizationCullingBox" ref="8f92b0e0f1967c4051ba47df01671671" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classPxBounds3.html">PxBounds3</a>&amp; PxScene::getVisualizationCullingBox           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7c036458140a45b23facb9cf2a9cdb84"></a><!-- doxytag: member="PxScene::getVisualizationParameter" ref="7c036458140a45b23facb9cf2a9cdb84" args="(PxVisualizationParameter::Enum paramEnum) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxScene::getVisualizationParameter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>paramEnum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that lets you query debug visualization parameters. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>paramEnum</em>&nbsp;</td><td>The Parameter to retrieve. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the parameter.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#4055d302466a1f5cd9d481028b66b20a" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1479ae5b2c484e34d2f9215157efba3"></a><!-- doxytag: member="PxScene::overlapAny" ref="b1479ae5b2c484e34d2f9215157efba3" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, PxShape *&amp;hit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE bool PxScene::overlapAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test returning, for a given geometry, any overlapping object in the scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxSceneQueryHitType.html" title="Classification of scene query hits.">PxSceneQueryHitType</a>). Both trigger a hit.<p>
<a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6a2219d78d3978341876067470e9bc572" title="Generate all hits for meshes rather than just the first.">PxSceneQueryFilterFlag::eMESH_MULTIPLE</a> and <a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6aa120ccd2077d8e2b33c407e6203f174" title="Generate hits for exit points and back faces of tris - NOT CURRENTLY SUPPORTED.">PxSceneQueryFilterFlag::eBACKFACE</a> have no effect in this case</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Pointer to store the overlapping object to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to overlap. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if an overlap was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1997dd1b7ae2dc99e93fdbdc264fcf73"></a><!-- doxytag: member="PxScene::overlapMultiple" ref="1997dd1b7ae2dc99e93fdbdc264fcf73" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, PxShape **hitBuffer, PxU32 hitBufferSize, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a> PxScene::overlapMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxShape.html">PxShape</a> **&nbsp;</td>
          <td class="paramname"> <em>hitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>hitBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test overlap between a geometry and objects in the scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxSceneQueryHitType.html" title="Classification of scene query hits.">PxSceneQueryHitType</a>). Both get written to the hit buffer.<p>
<a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6a2219d78d3978341876067470e9bc572" title="Generate all hits for meshes rather than just the first.">PxSceneQueryFilterFlag::eMESH_MULTIPLE</a> and <a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6aa120ccd2077d8e2b33c407e6203f174" title="Generate hits for exit points and back faces of tris - NOT CURRENTLY SUPPORTED.">PxSceneQueryFilterFlag::eBACKFACE</a> have no effect in this case</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitBuffer</em>&nbsp;</td><td>Buffer to store the overlapping objects to. If the buffer overflows, an arbitrary subset of overlapping objects is stored (typically the query should be restarted with a larger buffer). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitBufferSize</em>&nbsp;</td><td>Size of the hit buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to overlap. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of hits in the buffer, or -1 if the buffer overflowed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="68f8e25d497c46cfe5a8f2a573dfd20c"></a><!-- doxytag: member="PxScene::raycastAny" ref="68f8e25d497c46cfe5a8f2a573dfd20c" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryHit &amp;hit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::raycastAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raycast returning any blocking hit, not necessarily the closest. 
<p>
Returns whether any rigid actor is hit along the ray.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Raycast hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> <a class="el" href="structPxSceneQueryHit.html" title="Scene query hit information.">PxSceneQueryHit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a7ed4b2542fa5195fcf71b92b544c45"></a><!-- doxytag: member="PxScene::raycastMultiple" ref="5a7ed4b2542fa5195fcf71b92b544c45" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxRaycastHit *hitBuffer, PxU32 hitBufferSize, bool &amp;blockingHit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a> PxScene::raycastMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> *&nbsp;</td>
          <td class="paramname"> <em>hitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>hitBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>blockingHit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raycast returning multiple results. 
<p>
Find all rigid actors that get hit along the ray. Each result contains data as specified by the outputFlags field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered.<p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitBuffer</em>&nbsp;</td><td>Raycast hit information buffer. If the buffer overflows, the blocking hit is returned as the last entry together with an arbitrary subset of the nearer touching hits (typically the query should be restarted with a larger buffer). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitBufferSize</em>&nbsp;</td><td>Size of the hit buffer. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>blockingHit</em>&nbsp;</td><td>True if a blocking hit was found. If found, it is the last in the buffer, preceded by any touching hits which are closer. Otherwise the touching hits are listed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be touching. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of hits in the buffer, or -1 if the buffer overflowed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxRaycastHit.html" title="Raycast hit information.">PxRaycastHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="486fdf6c044cd85432a8c505d022f784"></a><!-- doxytag: member="PxScene::raycastSingle" ref="486fdf6c044cd85432a8c505d022f784" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxRaycastHit &amp;hit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::raycastSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raycast returning a single result. 
<p>
Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Raycast hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxRaycastHit.html" title="Raycast hit information.">PxRaycastHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="61f68a8c516aea477cc5328b00c976ed"></a><!-- doxytag: member="PxScene::release" ref="61f68a8c516aea477cc5328b00c976ed" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the scene. 
<p>
Removes any actors, particle systems, and constraint shaders from this scene (if the user hasn't already done so).<p>
Be sure to not keep a reference to this object after calling release. Avoid release calls while the scene is simulating (in between <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> and <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> calls).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#6dcded7be00c17004432a04a78569db1" title="Creates a scene.">PxPhysics.createScene()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3626f6101e56b30ac641aadd813b04ed"></a><!-- doxytag: member="PxScene::removeActor" ref="3626f6101e56b30ac641aadd813b04ed" args="(PxActor &amp;actor)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeActor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxActor.html">PxActor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>actor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an actor from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the actor is not part of this scene (see <a class="el" href="classPxActor.html#2bf2e48b1960ef8e4fc1a437473bd7a3" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and a error is issued.<p>
You can not remove individual articulation links (see <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a>) from the scene. Use <a class="el" href="classPxScene.html#4f53c1ba66a089688d4704bd295a2ca5" title="Removes an articulation from this scene.">removeArticulation()</a> instead.<p>
If the actor is a <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> then all assigned <a class="el" href="classPxConstraint.html" title="a plugin class for implementing constraints">PxConstraint</a> objects will get removed from the scene automatically.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>actor</em>&nbsp;</td><td>Actor to remove from scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxActor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3df37bb8adfc75962d6dccbd4ceda5c"></a><!-- doxytag: member="PxScene::removeAggregate" ref="a3df37bb8adfc75962d6dccbd4ceda5c" args="(PxAggregate &amp;aggregate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeAggregate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxAggregate.html">PxAggregate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an aggregate from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the aggregate is not part of this scene (see <a class="el" href="classPxAggregate.html#a70f305e7f2934d99afd74d28b0c0194" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and a error is issued.<p>
If the aggregate contains actors, those actors are removed from the scene as well.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aggregate</em>&nbsp;</td><td>Aggregate to remove from scene.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxAggregate.html" title="Class to aggregate actors into a single broad phase entry.">PxAggregate</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f53c1ba66a089688d4704bd295a2ca5"></a><!-- doxytag: member="PxScene::removeArticulation" ref="4f53c1ba66a089688d4704bd295a2ca5" args="(PxArticulation &amp;articulation)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::removeArticulation           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxArticulation.html">PxArticulation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>articulation</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes an articulation from this scene. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the articulation is not part of this scene (see <a class="el" href="classPxArticulation.html#fd299e63283d38910c48243e6d9755dd" title="Retrieves the scene which this articulation belongs to.">PxArticulation::getScene</a>), the call is ignored and a error is issued.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>articulation</em>&nbsp;</td><td>Articulation to remove from scene. See <a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a></td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxArticulation.html" title="a tree structure of bodies connected by joints that is treated as a unit by the dynamics...">PxArticulation</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="43fd03c451d881d29080a53ee2e50914"></a><!-- doxytag: member="PxScene::saveToDesc" ref="43fd03c451d881d29080a53ee2e50914" args="(PxSceneDesc &amp;desc) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::saveToDesc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSceneDesc.html">PxSceneDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves the Scene descriptor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>desc</em>&nbsp;</td><td>The descriptor used to retrieve the state of the object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b3207044e1825469dbd1a19880baef14"></a><!-- doxytag: member="PxScene::setClientBehaviorBits" ref="b3207044e1825469dbd1a19880baef14" args="(PxClientID client, PxU32 clientBehaviorBits)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setClientBehaviorBits           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>clientBehaviorBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets behavior bits for a client. 
<p>
The behavior bits are a property of a client that determine when it receives callbacks. PxU32 is a combo of <a class="el" href="structPxClientBehaviorBit.html" title="Multiclient behavior bit flags for clients.">PxClientBehaviorBit</a>.<p>
It is permissible to change the behavior for PX_DEFAULT_CLIENT with this call. Initially all created clients, as well as PX_DEFAULT_CLIENT have all bits set to 0.<p>
Note that in addition to setting a client to listen to a particular foreign actor event type, the user must also configure actors to send that particular event type to foreign clients using <a class="el" href="classPxActor.html#718d55ddbac7d923544537c72f532d2b" title="Sets the behavior bits of the actor.">PxActor::setClientBehaviorBits()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxClientBehaviorBit.html" title="Multiclient behavior bit flags for clients.">PxClientBehaviorBit</a> <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12" title="An ID to identify different clients for multiclient support.">PxClientID</a> <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a> <a class="el" href="classPxScene.html#33266f793c6ce63e58a9d363492c2c2e" title="Retrieves behavior bits for a client.">getClientBehaviorBits()</a> <a class="el" href="classPxActor.html#718d55ddbac7d923544537c72f532d2b" title="Sets the behavior bits of the actor.">PxActor::setClientBehaviorBits()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eec3367a4461c1ab2e552acdb8c0609e"></a><!-- doxytag: member="PxScene::setContactModifyCallback" ref="eec3367a4461c1ab2e552acdb8c0609e" args="(PxContactModifyCallback *callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setContactModifyCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxContactModifyCallback.html">PxContactModifyCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a user callback object, which receives callbacks on all contacts generated for specified actors. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Asynchronous user contact modification callback. See <a class="el" href="classPxContactModifyCallback.html" title="An interface class that the user can implement in order to modify contact constraints...">PxContactModifyCallback</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4221eb7b6fd63257f4f3b503ac066a46"></a><!-- doxytag: member="PxScene::setDominanceGroupPair" ref="4221eb7b6fd63257f4f3b503ac066a46" args="(PxDominanceGroup group1, PxDominanceGroup group2, const PxConstraintDominance &amp;dominance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setDominanceGroupPair           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a>&nbsp;</td>
          <td class="paramname"> <em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxConstraintDominance.html">PxConstraintDominance</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dominance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies the dominance behavior of constraints between two actors with two certain dominance groups. 
<p>
It is possible to assign each actor to a dominance groups using <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a>.<p>
With dominance groups one can have all constraints (contacts and joints) created between actors act in one direction only. This is useful if you want to make sure that the movement of the rider of a vehicle or the pony tail of a character doesn't influence the object it is attached to, while keeping the motion of both inherently physical.<p>
Whenever a constraint (i.e. joint or contact) between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the <a class="el" href="structPxConstraintDominance.html" title="Expresses the dominance relationship of a constraint. For the time being only three...">PxConstraintDominance</a> setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).<p>
In the constraint, <a class="el" href="structPxConstraintDominance.html#b770ef41a7667105368606018dfd714c">PxConstraintDominance::dominance0</a> becomes the dominance setting for a0, and <a class="el" href="structPxConstraintDominance.html#e3ab5aee45c73c94eba8c7c3f57bf0cf">PxConstraintDominance::dominance1</a> becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the constraint. A dominanceN setting of 0.0f, will however prevent aN to be pushed or pulled by a(1-N) through the constraint. Thus, a <a class="el" href="structPxConstraintDominance.html" title="Expresses the dominance relationship of a constraint. For the time being only three...">PxConstraintDominance</a> of (1.0f, 0.0f) makes the interaction one-way.<p>
The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:<p>
if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt; g2, then (1.0f, 0.0f) is returned<p>
In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.<p>
These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.<p>
It is not possible to make the matrix asymetric, or to change the diagonal. In other words:<p>
it is not possible to change (g1, g2) if (g1==g2) if you set<p>
(g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:<p>
~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)<p>
These two restrictions are to make sure that constraints between two actors will always evaluate to the same dominance setting, regardless of which order the actors are passed to the constraint.<p>
Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake actors up automatically.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#bd7e9615f7f01dfe7821bd44deeb264d" title="Samples the dominance matrix.">getDominanceGroupPair()</a> <a class="el" href="group__physics.html#gf665154f3f66f7c4f65ca9015db8ee87">PxDominanceGroup</a> <a class="el" href="structPxConstraintDominance.html" title="Expresses the dominance relationship of a constraint. For the time being only three...">PxConstraintDominance</a> <a class="el" href="classPxActor.html#614c46687cf76eb219ce47927fc90824" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classPxActor.html#24602fee489b3e797ff0f82613eef755" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf2322887ca4db2fdea0229a44e2892c"></a><!-- doxytag: member="PxScene::setDynamicTreeRebuildRateHint" ref="bf2322887ca4db2fdea0229a44e2892c" args="(PxU32 dynamicTreeRebuildRateHint)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setDynamicTreeRebuildRateHint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>dynamicTreeRebuildRateHint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the rebuild rate of the dynamic tree pruning structure. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dynamicTreeRebuildRateHint</em>&nbsp;</td><td>Rebuild rate of the dynamic tree pruning structure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#c3270ea72968fc446cacb81a7ce683d3" title="Hint for how much work should be done per simulation frame to rebuild the pruning...">PxSceneDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classPxScene.html#e220420fdd08f0dabee8b30f5ef2de68" title="Retrieves the rebuild rate of the dynamic tree pruning structure.">getDynamicTreeRebuildRateHint()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6610c08a5a92c894dcac9d658e48b7de"></a><!-- doxytag: member="PxScene::setFlag" ref="6610c08a5a92c894dcac9d658e48b7de" args="(PxSceneFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53">PxSceneFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a scene flag. You can only set one flag at a time. 
<p>
Only the below flags are mutable. Trying to change the others will result in an error:<p>
<a class="el" href="structPxSceneFlag.html#b4c347372b4433d34d983da780916c53e0ef248584f038f344e4591a13e2f52e" title="Enables a second broad phase check after integration that makes it possible to prevent...">PxSceneFlag::eENABLE_SWEPT_INTEGRATION</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneFlag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="575ed34c73adbd61892d728a688479f3"></a><!-- doxytag: member="PxScene::setGravity" ref="575ed34c73adbd61892d728a688479f3" args="(const PxVec3 &amp;vec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setGravity           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a constant gravity for the entire scene. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>A new gravity vector(e.g. <a class="el" href="classPxVec3.html" title="3 Element vector class.">PxVec3</a>(0.0f,-9.8f,0.0f) ) <b>Range:</b> force vector</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#9b0de35c38c43b8aeff6e6f29bf0db20" title="Gravity vector.">PxSceneDesc.gravity</a> <a class="el" href="classPxScene.html#6fe48dbf9144be415d63f1d2f3ce0b16" title="Retrieves the current gravity setting.">getGravity()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="148be23880c4e2d67f9f772066a9f966"></a><!-- doxytag: member="PxScene::setNbContactDataBlocks" ref="148be23880c4e2d67f9f772066a9f966" args="(PxU32 numBlocks)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setNbContactDataBlocks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>numBlocks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set the cache blocks that can be used during <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a>. 
<p>
Each frame the simulation requires memory to store contact, friction, and contact cache data. This memory is used in blocks of 16K. Each frame the blocks used by the previous frame are freed, and may be retrieved by the application using <a class="el" href="classPxScene.html#336aeaed9954dc3008631a61423914da" title="Clear internal buffers and free memory.">PxScene::flush()</a><p>
This call will force allocation of cache blocks if the numBlocks parameter is greater than the currently allocated number of blocks, and less than the max16KContactDataBlocks parameter specified at scene creation time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numBlocks</em>&nbsp;</td><td>The number of blocks to allocate.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#625cdbae7d2149a9df472fb4f9c06f83" title="Setting to determine how many 16K blocks are initially reserved to store contact...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classPxSceneDesc.html#8791132cbe8cce32f051e5eaab774d35" title="Setting to determine how many 16K blocks are reserved to store contact, friction...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classPxScene.html#336aeaed9954dc3008631a61423914da" title="Clear internal buffers and free memory.">flush()</a> <a class="el" href="classPxScene.html#b6224a915d459fb6a1c0899a080f5697" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed</a> <a class="el" href="classPxScene.html#a3c625507d5cfaf0f1cb9d26f66be329" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="06eb4fdf45e324c6110fd9fd5f28ca03"></a><!-- doxytag: member="PxScene::setSimulationEventCallback" ref="06eb4fdf45e324c6110fd9fd5f28ca03" args="(PxSimulationEventCallback *callback, PxClientID client=PX_DEFAULT_CLIENT)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setSimulationEventCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSimulationEventCallback.html">PxSimulationEventCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>client</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a user notify object which receives special simulation events when they occur. 
<p>
Multiclient behavior: Unlike the <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> that can be specified in the <a class="el" href="classPxSceneDesc.html" title="Descriptor class for scenes. See PxScene.">PxSceneDesc</a>, this method lets the user associate additional callbacks with clients other than PX_DEFAULT_CLIENT. This way each client can register its own callback class. Each callback function has a somewhat differnt way of determining which clients' callbacks will be called in a certain event. Refer to the documentation of particular callback functions inside <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> for this information.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>User notification callback. See <a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client</em>&nbsp;</td><td>The client to be associated with this callback.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSimulationEventCallback.html" title="An interface class that the user can implement in order to receive simulation events...">PxSimulationEventCallback</a> <a class="el" href="classPxScene.html#17361190e6640cbd1a5a9bc82796d4fc" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback()...">getSimulationEventCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad9cc8bf329f4de4b407436f5cd38c98"></a><!-- doxytag: member="PxScene::setSolverBatchSize" ref="ad9cc8bf329f4de4b407436f5cd38c98" args="(PxU32 solverBatchSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setSolverBatchSize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>solverBatchSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the number of actors required to spawn a separate rigid body solver thread. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>solverBatchSize</em>&nbsp;</td><td>Number of actors required to spawn a separate rigid body solver thread.</td></tr>
  </table>
</dl>
<b>Platform:</b> <ul>
<li>PC SW: Yes </li>
<li>PS3 : Not applicable </li>
<li>XB360: Yes </li>
<li>WII : Yes</li>
</ul>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxSceneDesc.html#26b321b928708c10a047b38ec9127797" title="Defines the number of actors required to spawn a separate rigid body solver thread...">PxSceneDesc.solverBatchSize</a> <a class="el" href="classPxScene.html#dd966317a1feb083e273fd8c12f454b5" title="Retrieves the number of actors required to spawn a separate rigid body solver thread...">getSolverBatchSize()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b562ba2df953188a7e2b99f7ddcda5dc"></a><!-- doxytag: member="PxScene::setVisualizationCullingBox" ref="b562ba2df953188a7e2b99f7ddcda5dc" args="(const PxBounds3 &amp;box)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::setVisualizationCullingBox           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxBounds3.html">PxBounds3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>box</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4055d302466a1f5cd9d481028b66b20a"></a><!-- doxytag: member="PxScene::setVisualizationParameter" ref="4055d302466a1f5cd9d481028b66b20a" args="(PxVisualizationParameter::Enum param, PxReal value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::setVisualizationParameter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10">PxVisualizationParameter::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Function that lets you set debug visualization parameters. 
<p>
Returns false if the value passed is out of range for usage specified by the enum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>param</em>&nbsp;</td><td>Parameter to set. See <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set, see <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> for allowable values. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False if the parameter is out of range.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#7c036458140a45b23facb9cf2a9cdb84" title="Function that lets you query debug visualization parameters.">getVisualizationParameter</a> <a class="el" href="structPxVisualizationParameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b87a979561b8188f8f17bf177f27a95d"></a><!-- doxytag: member="PxScene::simulate" ref="b87a979561b8188f8f17bf177f27a95d" args="(PxReal elapsedTime, physx::pxtask::BaseTask *completionTask=NULL, void *scratchMemBlock=0, PxU32 scratchMemBlockSize=0, bool controlSimulation=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxScene::simulate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::pxtask::BaseTask *&nbsp;</td>
          <td class="paramname"> <em>completionTask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlock</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>scratchMemBlockSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>controlSimulation</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Advances the simulation by an elapsedTime time. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Large elapsedTime values can lead to instabilities. In such cases elapsedTime should be subdivided into smaller time intervals and <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> should be called multiple times for each interval.</dd></dl>
Calls to <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> should pair with calls to <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>: Each <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> invocation corresponds to exactly one <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> invocation; calling <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> twice without an intervening <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> or <a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> twice without an intervening <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a> causes an error condition.<p>
scene-&gt;<a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a>; ...do some processing until physics is computed... scene-&gt;<a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a>; ...now results of run may be retrieved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>elapsedTime</em>&nbsp;</td><td>Amount of time to advance simulation by. The parameter has to be larger than 0, else the resulting behavior will be undefined. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>completionTask</em>&nbsp;</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classPxScene.html#b87a979561b8188f8f17bf177f27a95d" title="Advances the simulation by an elapsedTime time.">simulate()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlock</em>&nbsp;</td><td>a memory region for <a class="el" href="namespacephysx.html">physx</a> to use for temporary data during simulation. This block may be reused by the application after fetchResults returns. Must be aligned on a 16-byte boundary </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchMemBlockSize</em>&nbsp;</td><td>the size of the scratch memory block. Must be a multiple of 16K. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>controlSimulation</em>&nbsp;</td><td>if true, the scene controls its TaskManager simulation state. Leave true unless the application is calling the TaskManager start/stopSimulation() methods itself.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxScene.html#b34e054ccf428a1cdbd81bf1e2b87fae">fetchResults()</a> <a class="el" href="classPxScene.html#6f45a8ee04f0bcd2c23b23daa176bee5" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ad1aa60da4c4f165291be7d1118b531"></a><!-- doxytag: member="PxScene::sweepAny" ref="3ad1aa60da4c4f165291be7d1118b531" args="(const PxGeometry **geometryList, const PxTransform *poseList, const PxFilterData *filterDataList, PxU32 geometryCount, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags queryFlags, PxSceneQueryHit &amp;hit, PxSceneQueryFilterFlags filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::sweepAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>geometryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>queryFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em> = <code>PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep of geometry compound returning any blocking hit, not necessarily the closest. 
<p>
The function sweeps all specified geometry objects through space and returns whether any rigid actor is hit along the sweep path.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryList</em>&nbsp;</td><td>Geometries of objects to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseList</em>&nbsp;</td><td>The world pose for each geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Filter data for each geometry object. NULL, if no filtering should be done, all hits are assumed to be blocking in that case. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryCount</em>&nbsp;</td><td>Number of geometry objects specified. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryFlags</em>&nbsp;</td><td>Combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> defining the query behavior </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Sweep hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Simple filter logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first. If no hit is found the sweep gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryHit.html" title="Scene query hit information.">PxSceneQueryHit</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4147b84f33ff7e1f3c4e562bdc8dd7a0"></a><!-- doxytag: member="PxScene::sweepAny" ref="4147b84f33ff7e1f3c4e562bdc8dd7a0" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags queryFlags, PxSceneQueryHit &amp;hit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::sweepAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>queryFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSceneQueryHit.html">PxSceneQueryHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep returning any blocking hit, not necessarily the closest. 
<p>
Returns whether any rigid actor is hit along the sweep path.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryFlags</em>&nbsp;</td><td>Combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> defining the query behavior </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Sweep hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first. If no hit is found the sweep gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryHit.html" title="Scene query hit information.">PxSceneQueryHit</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e0d09e2ed1553575e1ef2f2924f8b21"></a><!-- doxytag: member="PxScene::sweepMultiple" ref="8e0d09e2ed1553575e1ef2f2924f8b21" args="(const PxGeometry **geometryList, const PxTransform *poseList, const PxFilterData *filterDataList, PxU32 geometryCount, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxSweepHit *hitBuffer, PxU32 hitBufferSize, bool &amp;blockingHit, PxSceneQueryFilterFlags filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a> PxScene::sweepMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>geometryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSweepHit.html">PxSweepHit</a> *&nbsp;</td>
          <td class="paramname"> <em>hitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>hitBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>blockingHit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em> = <code>PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep of geometry compound returning multiple results. 
<p>
The function sweeps all specified geometry objects through space and finds all rigid actors that get hit along the sweep. Each result contains data as specified by the outputFlags field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered.<p>
If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryList</em>&nbsp;</td><td>Geometries of objects to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseList</em>&nbsp;</td><td>The world pose for each geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Filter data for each geometry object. NULL, if no filtering should be done, all hits are assumed to be blocking in that case. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryCount</em>&nbsp;</td><td>Number of geometry objects specified. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitBuffer</em>&nbsp;</td><td>Sweep hit information buffer. If the buffer overflows, the blocking hit is returned as the last entry together with an arbitrary subset of the nearer touching hits (typically the query should be restarted with a larger buffer). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitBufferSize</em>&nbsp;</td><td>Size of the hit buffer. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>blockingHit</em>&nbsp;</td><td>True if a blocking hit was found. If found, it is the last in the buffer, preceded by any touching hits which are closer. Otherwise the touching hits are listed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Simple filter logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be touching. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of hits in the buffer, or -1 if the buffer overflowed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb3acf236345ab8d643ef94f173e7bb3"></a><!-- doxytag: member="PxScene::sweepMultiple" ref="cb3acf236345ab8d643ef94f173e7bb3" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxSweepHit *hitBuffer, PxU32 hitBufferSize, bool &amp;blockingHit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd30c834d58a6d6b96437f322fb402dad">PxI32</a> PxScene::sweepMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSweepHit.html">PxSweepHit</a> *&nbsp;</td>
          <td class="paramname"> <em>hitBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>hitBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>blockingHit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep returning multiple results. 
<p>
Find all rigid actors that get hit along the sweep. Each result contains data as specified by the outputFlags field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered.<p>
If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hitBuffer</em>&nbsp;</td><td>Sweep hit information buffer. If the buffer overflows, the blocking hit is returned as the last entry together with an arbitrary subset of the nearer touching hits (typically the query should be restarted with a larger buffer). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hitBufferSize</em>&nbsp;</td><td>Size of the hit buffer. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>blockingHit</em>&nbsp;</td><td>True if a blocking hit was found. If found, it is the last in the buffer, preceded by any touching hits which are closer. Otherwise the touching hits are listed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be touching. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of hits in the buffer, or -1 if the buffer overflowed.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb7901989e0980b324ebcaa476344e45"></a><!-- doxytag: member="PxScene::sweepSingle" ref="bb7901989e0980b324ebcaa476344e45" args="(const PxGeometry **geometryList, const PxTransform *poseList, const PxFilterData *filterDataList, PxU32 geometryCount, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxSweepHit &amp;hit, PxSceneQueryFilterFlags filterFlags=PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC, PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::sweepSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>geometryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em> = <code>PxSceneQueryFilterFlag::eDYNAMIC|PxSceneQueryFilterFlag::eSTATIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep of geometry compound returning a single result. 
<p>
The function sweeps all specified geometry objects through space and returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryList</em>&nbsp;</td><td>Geometries of objects to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseList</em>&nbsp;</td><td>The world pose for each geometry object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Filter data for each geometry object. NULL, if no filtering should be done, all hits are assumed to be blocking in that case. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryCount</em>&nbsp;</td><td>Number of geometry objects specified. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Sweep hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Simple filter logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="71a99edf703ffc6f0ac7d0b40f3d62e1"></a><!-- doxytag: member="PxScene::sweepSingle" ref="71a99edf703ffc6f0ac7d0b40f3d62e1" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags, PxSweepHit &amp;hit, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFilterCallback *filterCall=NULL, const PxSceneQueryCache *cache=NULL, PxClientID queryClient=PX_DEFAULT_CLIENT) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxScene::sweepSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxSceneQueryFilterCallback.html">PxSceneQueryFilterCallback</a> *&nbsp;</td>
          <td class="paramname"> <em>filterCall</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td>
          <td class="paramname"> <em>queryClient</em> = <code><a class="el" href="PxClient_8h.html#8bc840c3fd493df8b6072d055d050fb4">PX_DEFAULT_CLIENT</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep returning a single result. 
<p>
Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>hit</em>&nbsp;</td><td>Sweep hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterCall</em>&nbsp;</td><td>Custom filtering logic (optional). Only used if the corresponding <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Sweep is performed against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>queryClient</em>&nbsp;</td><td>ID of the client doing the query (see <a class="el" href="classPxScene.html#285849425521dd0344f55b4a7c0a834a" title="Reserves a new client ID.">createClient()</a>) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if a blocking hit was found.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="classPxSceneQueryFilterCallback.html" title="Scene query filtering callbacks.">PxSceneQueryFilterCallback</a> <a class="el" href="structPxSceneQueryCache.html" title="Hit cache for scene queries.">PxSceneQueryCache</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="64fbe5f25cef90d47fcb1c6428efe15a"></a><!-- doxytag: member="PxScene::userData" ref="64fbe5f25cef90d47fcb1c6428efe15a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxScene.html#64fbe5f25cef90d47fcb1c6428efe15a">PxScene::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxScene_8h-source.html">PxScene.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
