<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: pxtask::CudaContextManager Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespacepxtask.html">pxtask</a>::<a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a>
  </div>
<div class="contents">
<h1>pxtask::CudaContextManager Class Reference</h1><!-- doxytag: class="pxtask::CudaContextManager" -->Manages memory, thread locks, and task scheduling for a CUDA context.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxCudaContextManager_8h-source.html">PxCudaContextManager.h</a>&gt;</code>
<p>

<p>
<a href="classpxtask_1_1CudaContextManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#331ba6aa1a2ebbfa9ab88897416ea9ce">acquireContext</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the CUDA context for the current thread.  <a href="#331ba6aa1a2ebbfa9ab88897416ea9ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#068f4f6cdb214eb253481dd54db95220">releaseContext</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the CUDA context from the current thread.  <a href="#068f4f6cdb214eb253481dd54db95220"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classpxtask_1_1CudaMemoryManager.html">CudaMemoryManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#bd739f6fb2e9fcca33d3326b046d3587">getMemoryManager</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classpxtask_1_1CudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">CudaMemoryManager</a> instance associated with this CUDA context.  <a href="#bd739f6fb2e9fcca33d3326b046d3587"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual class <a class="el" href="classpxtask_1_1GpuDispatcher.html">GpuDispatcher</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#dee361520389ffe20eb75e42f314ec2f">getGpuDispatcher</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> instance associated with this CUDA context.  <a href="#dee361520389ffe20eb75e42f314ec2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#4952a646c3706aad637a54e37f191082">contextIsValid</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Context manager has a valid CUDA context.  <a href="#4952a646c3706aad637a54e37f191082"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#a6603de0de342dc90cb6ce4bbbe6e2c1">supportsArchSM10</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">G80.  <a href="#a6603de0de342dc90cb6ce4bbbe6e2c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#74b04c98d6fc45fa568c497d887662b3">supportsArchSM11</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">G92.  <a href="#74b04c98d6fc45fa568c497d887662b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#bb8e9034871279572a90facdb4f37174">supportsArchSM12</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GT200.  <a href="#bb8e9034871279572a90facdb4f37174"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#db972ae398e213b718c2a84a7eec01d6">supportsArchSM13</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GT260.  <a href="#db972ae398e213b718c2a84a7eec01d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#82d8a38aca3e334be7dfd348aa2c1e35">supportsArchSM20</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GF100.  <a href="#82d8a38aca3e334be7dfd348aa2c1e35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#ebe39888226f40743846f2d5f5936c76">supportsArchSM30</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GK100.  <a href="#ebe39888226f40743846f2d5f5936c76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#6396078f7bef60d3895b7088653a194c">supportsArchSM35</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GK110.  <a href="#6396078f7bef60d3895b7088653a194c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#e3503e629cf1e0351a0bcedd1eabc007">isIntegrated</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if GPU is an integrated (MCP) part  <a href="#e3503e629cf1e0351a0bcedd1eabc007"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#611be7a909c0c386baf6c4f32bab30c6">hasDMAEngines</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if GPU can overlap kernels and copies  <a href="#611be7a909c0c386baf6c4f32bab30c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#900e2ad74defb1f5b54649ffd1e36e41">canMapHostMemory</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if GPU map host memory to GPU (0-copy)  <a href="#900e2ad74defb1f5b54649ffd1e36e41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#d2623d7a2024670e04873cb2f8eb985b">getDriverVersion</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns cached value of cuGetDriverVersion()  <a href="#d2623d7a2024670e04873cb2f8eb985b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#b0af39f5c1484fc8a7ff139112e3de37">getDeviceTotalMemBytes</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns cached value of device memory size  <a href="#b0af39f5c1484fc8a7ff139112e3de37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#53a752fe2a565df307c4d492557ad8ec">getMultiprocessorCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns cache value of SM unit count  <a href="#53a752fe2a565df307c4d492557ad8ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#757a0fa1ea3d6d2c1ce96379ab7459c3">getClockRate</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns cached value of SM clock frequency  <a href="#757a0fa1ea3d6d2c1ce96379ab7459c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#8c7197d84840d8310093f1d6a696f600">getSharedMemPerBlock</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns total amount of shared memory available per block in bytes  <a href="#8c7197d84840d8310093f1d6a696f600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#7db2629b5e0b3286f7767bd0762f05d2">getDeviceName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns device name retrieved from driver  <a href="#7db2629b5e0b3286f7767bd0762f05d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structpxtask_1_1CudaInteropMode.html#641d7ebb1cdaa3c951e09f6ec693a600">CudaInteropMode::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#0370478f0909490b9ae0c43b63d7b006">getInteropMode</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">interop mode the context was created with  <a href="#0370478f0909490b9ae0c43b63d7b006"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#f4df80e8d09bf12d610c51c2353e5b16">registerResourceInCudaGL</a> (<a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;resource, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> buffer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a rendering resource with CUDA.  <a href="#f4df80e8d09bf12d610c51c2353e5b16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#f37b98c80f4e68a5029459559b6a812f">registerResourceInCudaD3D</a> (<a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;resource, void *resourcePointer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a rendering resource with CUDA.  <a href="#f37b98c80f4e68a5029459559b6a812f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#0ac9a7806268023ddc16cdb870d1648b">unregisterResourceInCuda</a> (<a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> resource)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a rendering resource with CUDA.  <a href="#0ac9a7806268023ddc16cdb870d1648b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#4209b756359c02ffb7f418ba00a121de">usingDedicatedPhysXGPU</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the user has configured a dedicated PhysX GPU in the NV Control Panel.  <a href="#4209b756359c02ffb7f418ba00a121de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#da136000411a49ff3ab9bc1206d8e290">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>.  <a href="#da136000411a49ff3ab9bc1206d8e290"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html#502d596f1f3a3e98e38766b5c821d862">~CudaContextManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">protected destructor, use <a class="el" href="classpxtask_1_1CudaContextManager.html#da136000411a49ff3ab9bc1206d8e290" title="Release the CudaContextManager.">release()</a> method  <a href="#502d596f1f3a3e98e38766b5c821d862"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Manages memory, thread locks, and task scheduling for a CUDA context. 
<p>
A <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> manages access to a single CUDA context, allowing it to be shared between multiple scenes. Memory allocations are dynamic: starting with an initial heap size and growing on demand by a configurable page size. The context must be acquired from the manager before using any CUDA APIs.<p>
The <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> is based on the CUDA driver API and explictly does not support the the CUDA runtime API (aka, CUDART).<p>
To enable CUDA use by an APEX scene, a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> must be created (supplying your own CUDA context, or allowing a new context to be allocated for you), the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> for that context is retrieved via the <a class="el" href="classpxtask_1_1CudaContextManager.html#dee361520389ffe20eb75e42f314ec2f" title="Return the GpuDispatcher instance associated with this CUDA context.">getGpuDispatcher()</a> method, and this is assigned to the <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> that is given to the scene via its NxApexSceneDesc. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="502d596f1f3a3e98e38766b5c821d862"></a><!-- doxytag: member="pxtask::CudaContextManager::~CudaContextManager" ref="502d596f1f3a3e98e38766b5c821d862" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pxtask::CudaContextManager::~CudaContextManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
protected destructor, use <a class="el" href="classpxtask_1_1CudaContextManager.html#da136000411a49ff3ab9bc1206d8e290" title="Release the CudaContextManager.">release()</a> method 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="331ba6aa1a2ebbfa9ab88897416ea9ce"></a><!-- doxytag: member="pxtask::CudaContextManager::acquireContext" ref="331ba6aa1a2ebbfa9ab88897416ea9ce" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::CudaContextManager::acquireContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire the CUDA context for the current thread. 
<p>
Acquisitions are allowed to be recursive within a single thread. You can acquire the context multiple times so long as you release it the same count.<p>
The context must be acquired before using most CUDA functions.<p>
It is not necessary to acquire the CUDA context inside <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> launch functions, because the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will have already acquired the context for its worker thread. However it is not harmfull to (re)acquire the context in code that is shared between GpuTasks and non-task functions. 
</div>
</div><p>
<a class="anchor" name="900e2ad74defb1f5b54649ffd1e36e41"></a><!-- doxytag: member="pxtask::CudaContextManager::canMapHostMemory" ref="900e2ad74defb1f5b54649ffd1e36e41" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::canMapHostMemory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
true if GPU map host memory to GPU (0-copy) 
<p>

</div>
</div><p>
<a class="anchor" name="4952a646c3706aad637a54e37f191082"></a><!-- doxytag: member="pxtask::CudaContextManager::contextIsValid" ref="4952a646c3706aad637a54e37f191082" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::contextIsValid           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Context manager has a valid CUDA context. 
<p>
This method should be called after creating a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>, especially if the manager was responsible for allocating its own CUDA context (desc.ctx == NULL). If it returns false, there is no point in assigning this manager's <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> to a <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> as it will be unable to execute GpuTasks. 
</div>
</div><p>
<a class="anchor" name="757a0fa1ea3d6d2c1ce96379ab7459c3"></a><!-- doxytag: member="pxtask::CudaContextManager::getClockRate" ref="757a0fa1ea3d6d2c1ce96379ab7459c3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int pxtask::CudaContextManager::getClockRate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns cached value of SM clock frequency 
<p>

</div>
</div><p>
<a class="anchor" name="7db2629b5e0b3286f7767bd0762f05d2"></a><!-- doxytag: member="pxtask::CudaContextManager::getDeviceName" ref="7db2629b5e0b3286f7767bd0762f05d2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* pxtask::CudaContextManager::getDeviceName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns device name retrieved from driver 
<p>

</div>
</div><p>
<a class="anchor" name="b0af39f5c1484fc8a7ff139112e3de37"></a><!-- doxytag: member="pxtask::CudaContextManager::getDeviceTotalMemBytes" ref="b0af39f5c1484fc8a7ff139112e3de37" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t pxtask::CudaContextManager::getDeviceTotalMemBytes           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns cached value of device memory size 
<p>

</div>
</div><p>
<a class="anchor" name="d2623d7a2024670e04873cb2f8eb985b"></a><!-- doxytag: member="pxtask::CudaContextManager::getDriverVersion" ref="d2623d7a2024670e04873cb2f8eb985b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pxtask::CudaContextManager::getDriverVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns cached value of cuGetDriverVersion() 
<p>

</div>
</div><p>
<a class="anchor" name="dee361520389ffe20eb75e42f314ec2f"></a><!-- doxytag: member="pxtask::CudaContextManager::getGpuDispatcher" ref="dee361520389ffe20eb75e42f314ec2f" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual class <a class="el" href="classpxtask_1_1GpuDispatcher.html">GpuDispatcher</a>* pxtask::CudaContextManager::getGpuDispatcher           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> instance associated with this CUDA context. 
<p>

</div>
</div><p>
<a class="anchor" name="0370478f0909490b9ae0c43b63d7b006"></a><!-- doxytag: member="pxtask::CudaContextManager::getInteropMode" ref="0370478f0909490b9ae0c43b63d7b006" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structpxtask_1_1CudaInteropMode.html#641d7ebb1cdaa3c951e09f6ec693a600">CudaInteropMode::Enum</a> pxtask::CudaContextManager::getInteropMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
interop mode the context was created with 
<p>

</div>
</div><p>
<a class="anchor" name="bd739f6fb2e9fcca33d3326b046d3587"></a><!-- doxytag: member="pxtask::CudaContextManager::getMemoryManager" ref="bd739f6fb2e9fcca33d3326b046d3587" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpxtask_1_1CudaMemoryManager.html">CudaMemoryManager</a>* pxtask::CudaContextManager::getMemoryManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the <a class="el" href="classpxtask_1_1CudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">CudaMemoryManager</a> instance associated with this CUDA context. 
<p>

</div>
</div><p>
<a class="anchor" name="53a752fe2a565df307c4d492557ad8ec"></a><!-- doxytag: member="pxtask::CudaContextManager::getMultiprocessorCount" ref="53a752fe2a565df307c4d492557ad8ec" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pxtask::CudaContextManager::getMultiprocessorCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns cache value of SM unit count 
<p>

</div>
</div><p>
<a class="anchor" name="8c7197d84840d8310093f1d6a696f600"></a><!-- doxytag: member="pxtask::CudaContextManager::getSharedMemPerBlock" ref="8c7197d84840d8310093f1d6a696f600" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pxtask::CudaContextManager::getSharedMemPerBlock           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns total amount of shared memory available per block in bytes 
<p>

</div>
</div><p>
<a class="anchor" name="611be7a909c0c386baf6c4f32bab30c6"></a><!-- doxytag: member="pxtask::CudaContextManager::hasDMAEngines" ref="611be7a909c0c386baf6c4f32bab30c6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::hasDMAEngines           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
true if GPU can overlap kernels and copies 
<p>

</div>
</div><p>
<a class="anchor" name="e3503e629cf1e0351a0bcedd1eabc007"></a><!-- doxytag: member="pxtask::CudaContextManager::isIntegrated" ref="e3503e629cf1e0351a0bcedd1eabc007" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::isIntegrated           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
true if GPU is an integrated (MCP) part 
<p>

</div>
</div><p>
<a class="anchor" name="f37b98c80f4e68a5029459559b6a812f"></a><!-- doxytag: member="pxtask::CudaContextManager::registerResourceInCudaD3D" ref="f37b98c80f4e68a5029459559b6a812f" args="(CUgraphicsResource &amp;resource, void *resourcePointer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::registerResourceInCudaD3D           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>resourcePointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a rendering resource with CUDA. 
<p>
This function is called to register render resources (allocated from Direct3D) with CUDA so that the memory may be shared between the two systems. This is only required for render resources that are designed for interop use. In APEX, each render resource descriptor that could support interop has a 'registerInCUDA' boolean variable.<p>
The function must be called again any time your graphics device is reset, to re-register the resource.<p>
Returns true if the registration succeeded. A registered resource must be unregistered before it can be released.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resource</em>&nbsp;</td><td>[OUT] the handle to the resource that can be used with CUDA </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>resourcePointer</em>&nbsp;</td><td>[IN] A pointer to either IDirect3DResource9, or ID3D10Device, or ID3D11Resource to be registered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f4df80e8d09bf12d610c51c2353e5b16"></a><!-- doxytag: member="pxtask::CudaContextManager::registerResourceInCudaGL" ref="f4df80e8d09bf12d610c51c2353e5b16" args="(CUgraphicsResource &amp;resource, PxU32 buffer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::registerResourceInCudaGL           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>resource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a rendering resource with CUDA. 
<p>
This function is called to register render resources (allocated from OpenGL) with CUDA so that the memory may be shared between the two systems. This is only required for render resources that are designed for interop use. In APEX, each render resource descriptor that could support interop has a 'registerInCUDA' boolean variable.<p>
The function must be called again any time your graphics device is reset, to re-register the resource.<p>
Returns true if the registration succeeded. A registered resource must be unregistered before it can be released.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resource</em>&nbsp;</td><td>[OUT] the handle to the resource that can be used with CUDA </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[IN] GLuint buffer index to be mapped to cuda </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="da136000411a49ff3ab9bc1206d8e290"></a><!-- doxytag: member="pxtask::CudaContextManager::release" ref="da136000411a49ff3ab9bc1206d8e290" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::CudaContextManager::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>. 
<p>
When the manager instance is released, it also releases its <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> instance and <a class="el" href="classpxtask_1_1CudaMemoryManager.html" title="Allocator class for different kinds of CUDA related memory.">CudaMemoryManager</a>. Before the memory manager is released, it frees all allocated memory pages. If the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> created the CUDA context it was responsible for, it also frees that context.<p>
Do not release the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> if there are any scenes using its <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>. Those scenes must be released first since there is no safe way to remove a <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> from a <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> once the <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> has been given to a scene. 
</div>
</div><p>
<a class="anchor" name="068f4f6cdb214eb253481dd54db95220"></a><!-- doxytag: member="pxtask::CudaContextManager::releaseContext" ref="068f4f6cdb214eb253481dd54db95220" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::CudaContextManager::releaseContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release the CUDA context from the current thread. 
<p>
The CUDA context should be released as soon as practically possible, to allow other CPU threads (including the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>) to work efficiently. 
</div>
</div><p>
<a class="anchor" name="a6603de0de342dc90cb6ce4bbbe6e2c1"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM10" ref="a6603de0de342dc90cb6ce4bbbe6e2c1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM10           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
G80. 
<p>

</div>
</div><p>
<a class="anchor" name="74b04c98d6fc45fa568c497d887662b3"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM11" ref="74b04c98d6fc45fa568c497d887662b3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM11           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
G92. 
<p>

</div>
</div><p>
<a class="anchor" name="bb8e9034871279572a90facdb4f37174"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM12" ref="bb8e9034871279572a90facdb4f37174" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM12           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GT200. 
<p>

</div>
</div><p>
<a class="anchor" name="db972ae398e213b718c2a84a7eec01d6"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM13" ref="db972ae398e213b718c2a84a7eec01d6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM13           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GT260. 
<p>

</div>
</div><p>
<a class="anchor" name="82d8a38aca3e334be7dfd348aa2c1e35"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM20" ref="82d8a38aca3e334be7dfd348aa2c1e35" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM20           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GF100. 
<p>

</div>
</div><p>
<a class="anchor" name="ebe39888226f40743846f2d5f5936c76"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM30" ref="ebe39888226f40743846f2d5f5936c76" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM30           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GK100. 
<p>

</div>
</div><p>
<a class="anchor" name="6396078f7bef60d3895b7088653a194c"></a><!-- doxytag: member="pxtask::CudaContextManager::supportsArchSM35" ref="6396078f7bef60d3895b7088653a194c" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::supportsArchSM35           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
GK110. 
<p>

</div>
</div><p>
<a class="anchor" name="0ac9a7806268023ddc16cdb870d1648b"></a><!-- doxytag: member="pxtask::CudaContextManager::unregisterResourceInCuda" ref="0ac9a7806268023ddc16cdb870d1648b" args="(CUgraphicsResource resource)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaContextManager::unregisterResourceInCuda           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PxCudaContextManager_8h.html#c0c4e1704647178d9c5ba3be46517dcd">CUgraphicsResource</a>&nbsp;</td>
          <td class="paramname"> <em>resource</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregister a rendering resource with CUDA. 
<p>
If a render resource was successfully registered with CUDA using the registerResourceInCuda***() methods, this function must be called to unregister the resource before the it can be released. 
</div>
</div><p>
<a class="anchor" name="4209b756359c02ffb7f418ba00a121de"></a><!-- doxytag: member="pxtask::CudaContextManager::usingDedicatedPhysXGPU" ref="4209b756359c02ffb7f418ba00a121de" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int pxtask::CudaContextManager::usingDedicatedPhysXGPU           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the user has configured a dedicated PhysX GPU in the NV Control Panel. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If using CUDA Interop, this will always return false </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if there is a dedicated PhysX GPU <p>
0 if there is NOT a dedicated PhysX GPU <p>
-1 if the routine is not implemented </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCudaContextManager_8h-source.html">PxCudaContextManager.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
