<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxBatchQuery Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxBatchQuery Class Reference<br>
<small>
[<a class="el" href="group__scenequery.html">Scenequery</a>]</small>
</h1><!-- doxytag: class="PxBatchQuery" -->Batched queries object. This is used to perform several queries at the same time.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxBatchQuery_8h-source.html">PxBatchQuery.h</a>&gt;</code>
<p>

<p>
<a href="classPxBatchQuery-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#44d0c3cc22363a3b1cc9f42f64bc51eb">execute</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes batched queries.  <a href="#44d0c3cc22363a3b1cc9f42f64bc51eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae">PxBatchQueryPreFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#5c88db06732dd07d95fe006df755e094">getPreFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the prefilter shader in use for this scene query.  <a href="#5c88db06732dd07d95fe006df755e094"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br class="typebreak">
<a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85">PxBatchQueryPostFilterShader</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#f12d7a7693f8f4101f51cb5582386a08">getPostFilterShader</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the postfilter shader in use for this scene query.  <a href="#f12d7a7693f8f4101f51cb5582386a08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#279f956d9c09cb6d0b59ff5103982c37">getFilterShaderData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the shared global filter data in use for this scene query.  <a href="#279f956d9c09cb6d0b59ff5103982c37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#7213f11f610f088b8d98a075c795d61a">getFilterShaderDataSize</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>).  <a href="#7213f11f610f088b8d98a075c795d61a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#d3c803532f5f6df1a67fcd356c9d18a3">getOwnerClient</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the client specified with <a class="el" href="classPxBatchQueryDesc.html#2c353d9d12acf7cc754a1456db2f7ab6" title="Immutable client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> at creation time.  <a href="#d3c803532f5f6df1a67fcd356c9d18a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#623fdf0b33e7d51c1b5ca278d8f19a75">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Releases <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> from PxSceneQueryManager.  <a href="#623fdf0b33e7d51c1b5ca278d8f19a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#20632a4c03e53493e39a0e64448897ce">raycastAny</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance=PX_MAX_F32, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether any object of type objectsType is hit along the ray.  <a href="#20632a4c03e53493e39a0e64448897ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#ac1860cf71e51849699f917cf62d7c27">raycastSingle</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance=PX_MAX_F32, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first object of type objectsType that is hit along the ray.  <a href="#ac1860cf71e51849699f917cf62d7c27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#fac52261caebfbc6f3aeb3ba1a66a3a6">raycastMultiple</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;origin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance=PX_MAX_F32, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find all objects of type objectsType which a ray intersects.  <a href="#fac52261caebfbc6f3aeb3ba1a66a3a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#62e86c48640b393d31d6ed56ed5eeed3">overlapMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxShapes=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test overlap between a geometry and objects in the scene. Returns all objects of type objectsType which overlap the world-space sphere.  <a href="#62e86c48640b393d31d6ed56ed5eeed3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#26d1da0ded3f7d542bac40325f7bdf3d">overlapAny</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test returning, for a given geometry, any overlapping object in the scene. Returns any object of type objectsType which overlap the world-space sphere.  <a href="#26d1da0ded3f7d542bac40325f7bdf3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#5e002dc1872a0b54841a72433b73aaf3">sweepSingle</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweeps returning a single result.  <a href="#5e002dc1872a0b54841a72433b73aaf3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#682de05ec97cefbfe993946bd4f6b824">linearCompoundGeometrySweepSingle</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> **geometryList, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseList, const <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> geometryCount, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with a compound of geometry objects.  <a href="#682de05ec97cefbfe993946bd4f6b824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#28fd9a0463371729b24884555ea8322a">sweepMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;filterData=<a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>(), void *userData=NULL, const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep returning multiple results.  <a href="#28fd9a0463371729b24884555ea8322a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74">linearCompoundGeometrySweepMultiple</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> **geometryList, const <a class="el" href="classPxTransform.html">PxTransform</a> *poseList, const <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> geometryCount, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *cache=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with a compound of geometry objects, returning all overlaps.  <a href="#6de1720a86b3c9bd92d34137c5086e74"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxBatchQuery.html#117dd25a3366f03dbb748a5afcf26117">~PxBatchQuery</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Batched queries object. This is used to perform several queries at the same time. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxSceneQueryManager </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="117dd25a3366f03dbb748a5afcf26117"></a><!-- doxytag: member="PxBatchQuery::~PxBatchQuery" ref="117dd25a3366f03dbb748a5afcf26117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxBatchQuery::~PxBatchQuery           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="44d0c3cc22363a3b1cc9f42f64bc51eb"></a><!-- doxytag: member="PxBatchQuery::execute" ref="44d0c3cc22363a3b1cc9f42f64bc51eb" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::execute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Executes batched queries. 
<p>

</div>
</div><p>
<a class="anchor" name="279f956d9c09cb6d0b59ff5103982c37"></a><!-- doxytag: member="PxBatchQuery::getFilterShaderData" ref="279f956d9c09cb6d0b59ff5103982c37" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* PxBatchQuery::getFilterShaderData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the shared global filter data in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Shared filter data for filter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html#7213f11f610f088b8d98a075c795d61a" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData).">getFilterShaderDataSize()</a> <a class="el" href="classPxBatchQueryDesc.html#5f0ec12e1149c7960b9360c53615853c" title="Shared global filter data which will get passed into the filter shader.">PxBatchQueryDesc.filterShaderData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7213f11f610f088b8d98a075c795d61a"></a><!-- doxytag: member="PxBatchQuery::getFilterShaderDataSize" ref="7213f11f610f088b8d98a075c795d61a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxBatchQuery::getFilterShaderDataSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the size of the shared global filter data (<a class="el" href="classPxSceneDesc.html#d9ceb142127cc259aa2f5d322a1494e2" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>). 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Size of shared filter data [bytes].</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html#279f956d9c09cb6d0b59ff5103982c37" title="Gets the shared global filter data in use for this scene query.">getFilterShaderData()</a> <a class="el" href="classPxBatchQueryDesc.html#35d9cb33ded71261de0c7695d75ecba9" title="Size (in bytes) of the shared global filter data filterShaderData.">PxBatchQueryDesc.filterShaderDataSize</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3c803532f5f6df1a67fcd356c9d18a3"></a><!-- doxytag: member="PxBatchQuery::getOwnerClient" ref="d3c803532f5f6df1a67fcd356c9d18a3" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="PxClient_8h.html#cb0e5a85de6c250f2a54db46e3aa0a12">PxClientID</a> PxBatchQuery::getOwnerClient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the client specified with <a class="el" href="classPxBatchQueryDesc.html#2c353d9d12acf7cc754a1456db2f7ab6" title="Immutable client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> at creation time. 
<p>
It is not possible to change this value after creating the scene query.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQueryDesc.html#2c353d9d12acf7cc754a1456db2f7ab6" title="Immutable client that creates and owns this scene query.">PxBatchQueryDesc::ownerClient</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f12d7a7693f8f4101f51cb5582386a08"></a><!-- doxytag: member="PxBatchQuery::getPostFilterShader" ref="f12d7a7693f8f4101f51cb5582386a08" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85">PxBatchQueryPostFilterShader</a> PxBatchQuery::getPostFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the postfilter shader in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Postfilter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxBatchQueryDesc.preFilterShade <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c88db06732dd07d95fe006df755e094"></a><!-- doxytag: member="PxBatchQuery::getPreFilterShader" ref="5c88db06732dd07d95fe006df755e094" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae">PxBatchQueryPreFilterShader</a> PxBatchQuery::getPreFilterShader           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the prefilter shader in use for this scene query. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Prefilter shader.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxBatchQueryDesc.preFilterShade <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6de1720a86b3c9bd92d34137c5086e74"></a><!-- doxytag: member="PxBatchQuery::linearCompoundGeometrySweepMultiple" ref="6de1720a86b3c9bd92d34137c5086e74" args="(const PxGeometry **geometryList, const PxTransform *poseList, const PxFilterData *filterDataList, PxU32 geometryCount, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFilterFlags filterFlags, PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const PxSweepCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::linearCompoundGeometrySweepMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>geometryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a linear sweep through space with a compound of geometry objects, returning all overlaps. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Supported geometries are: <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a>, <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a>, <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a>, <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a>. <p>
If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
The function sweeps all specified geometry objects through space and reports all objects in the scene which intersect. Apart from the number of objects intersected in this way, and the objects intersected, information on the closest intersection is put in an <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> structure which is stored in the user allocated buffer in <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> . See <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryList</em>&nbsp;</td><td>List of pointers to the geometry objects to sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseList</em>&nbsp;</td><td>The world pose for each geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Filter data for each geometry object. NULL, if no filtering should be done </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryCount</em>&nbsp;</td><td>Number of geometry objects specified </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Filter logic settings. See <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> they are interested in. See <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Sweep cache to use with the query</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> PxSceneQueryReport <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="classPxBatchQuery.html#682de05ec97cefbfe993946bd4f6b824" title="Performs a linear sweep through space with a compound of geometry objects.">linearCompoundGeometrySweepSingle</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="682de05ec97cefbfe993946bd4f6b824"></a><!-- doxytag: member="PxBatchQuery::linearCompoundGeometrySweepSingle" ref="682de05ec97cefbfe993946bd4f6b824" args="(const PxGeometry **geometryList, const PxTransform *poseList, const PxFilterData *filterDataList, PxU32 geometryCount, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFilterFlags filterFlags, PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const PxSweepCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::linearCompoundGeometrySweepSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> **&nbsp;</td>
          <td class="paramname"> <em>geometryList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>poseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>geometryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a linear sweep through space with a compound of geometry objects. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Supported geometries are: <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a>, <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a>, <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a>, <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a>. <p>
If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
The function sweeps all specified geometry objects through space and reports any objects in the scene which intersect. Apart from the number of objects intersected in this way, and the objects intersected, information on the closest intersection is put in an <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> structure which is stored in the user allocated buffer in <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a> . See <a class="el" href="classPxBatchQueryDesc.html" title="Descriptor class for PxBatchQuery.">PxBatchQueryDesc</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryList</em>&nbsp;</td><td>List of pointers to the geometry objects to sweep </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poseList</em>&nbsp;</td><td>The world pose for each geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Filter data for each geometry object. NULL, if no filtering should be done </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometryCount</em>&nbsp;</td><td>Number of geometry objects specified </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Filter logic settings. See <a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Allows the user to specify which field of <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> they are interested in. See <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Sweep cache to use with the query</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterFlag.html" title="Filtering flags for scene queries.">PxSceneQueryFilterFlag</a> <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> PxSceneQueryReport <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> <a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74" title="Performs a linear sweep through space with a compound of geometry objects, returning...">linearCompoundGeometrySweepMultiple</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="26d1da0ded3f7d542bac40325f7bdf3d"></a><!-- doxytag: member="PxBatchQuery::overlapAny" ref="26d1da0ded3f7d542bac40325f7bdf3d" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), void *userData=NULL, const PxSceneQueryCache *cache=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE void PxBatchQuery::overlapAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test returning, for a given geometry, any overlapping object in the scene. Returns any object of type objectsType which overlap the world-space sphere. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxSceneQueryHitType.html" title="Classification of scene query hits.">PxSceneQueryHitType</a>). Both get written to the hit buffer.<p>
<a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6a2219d78d3978341876067470e9bc572" title="Generate all hits for meshes rather than just the first.">PxSceneQueryFilterFlag::eMESH_MULTIPLE</a> and <a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6aa120ccd2077d8e2b33c407e6203f174" title="Generate hits for exit points and back faces of tris - NOT CURRENTLY SUPPORTED.">PxSceneQueryFilterFlag::eBACKFACE</a> have no effect in this case</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. See <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="62e86c48640b393d31d6ed56ed5eeed3"></a><!-- doxytag: member="PxBatchQuery::overlapMultiple" ref="62e86c48640b393d31d6ed56ed5eeed3" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), void *userData=NULL, const PxSceneQueryCache *cache=NULL, PxU32 maxShapes=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::overlapMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxShapes</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test overlap between a geometry and objects in the scene. Returns all objects of type objectsType which overlap the world-space sphere. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Filtering: Overlap tests do not distinguish between touching and blocking hit types (see <a class="el" href="structPxSceneQueryHitType.html" title="Classification of scene query hits.">PxSceneQueryHitType</a>). Both get written to the hit buffer.<p>
<a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6a2219d78d3978341876067470e9bc572" title="Generate all hits for meshes rather than just the first.">PxSceneQueryFilterFlag::eMESH_MULTIPLE</a> and <a class="el" href="structPxSceneQueryFilterFlag.html#1d5002f3fa0ee3f05c7d88379008c1b6aa120ccd2077d8e2b33c407e6203f174" title="Generate hits for exit points and back faces of tris - NOT CURRENTLY SUPPORTED.">PxSceneQueryFilterFlag::eBACKFACE</a> have no effect in this case</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. See <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxShapes</em>&nbsp;</td><td>user-defined limit on number of reported shapes (0 to report all shapes)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="20632a4c03e53493e39a0e64448897ce"></a><!-- doxytag: member="PxBatchQuery::raycastAny" ref="20632a4c03e53493e39a0e64448897ce" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, PxReal distance=PX_MAX_F32, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), void *userData=NULL, const PxSceneQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::raycastAny           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>PX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns whether any object of type objectsType is hit along the ray. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of the ray is normalized.<p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>filterData which is passed to the filer shader. See <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxRaycastHit.html" title="Raycast hit information.">PxRaycastHit</a> <a class="el" href="classPxBatchQuery.html#ac1860cf71e51849699f917cf62d7c27" title="Returns the first object of type objectsType that is hit along the ray.">raycastSingle()</a> <a class="el" href="classPxBatchQuery.html#fac52261caebfbc6f3aeb3ba1a66a3a6" title="Find all objects of type objectsType which a ray intersects.">raycastMultiple()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fac52261caebfbc6f3aeb3ba1a66a3a6"></a><!-- doxytag: member="PxBatchQuery::raycastMultiple" ref="fac52261caebfbc6f3aeb3ba1a66a3a6" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, PxReal distance=PX_MAX_F32, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const PxSceneQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::raycastMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>PX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find all objects of type objectsType which a ray intersects. 
<p>
hintFlags is a combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> flags.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of the ray is normalized.<p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>filterData which is passed to the filer shader. See <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxRaycastHit.html" title="Raycast hit information.">PxRaycastHit</a> <a class="el" href="classPxBatchQuery.html#20632a4c03e53493e39a0e64448897ce" title="Returns whether any object of type objectsType is hit along the ray.">raycastAny()</a> <a class="el" href="classPxBatchQuery.html#ac1860cf71e51849699f917cf62d7c27" title="Returns the first object of type objectsType that is hit along the ray.">raycastSingle()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac1860cf71e51849699f917cf62d7c27"></a><!-- doxytag: member="PxBatchQuery::raycastSingle" ref="ac1860cf71e51849699f917cf62d7c27" args="(const PxVec3 &amp;origin, const PxVec3 &amp;unitDir, PxReal distance=PX_MAX_F32, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, void *userData=NULL, const PxSceneQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::raycastSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em> = <code>PX_MAX_F32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first object of type objectsType that is hit along the ray. 
<p>
The world space intersection point, and the distance along the ray are also provided. hintFlags is a combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> flags.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Make certain that the direction vector of the ray is normalized.<p>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>origin</em>&nbsp;</td><td>Origin of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the ray. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>filterData which is passed to the filer shader. See <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a>, <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxRaycastHit.html" title="Raycast hit information.">PxRaycastHit</a> <a class="el" href="classPxBatchQuery.html#20632a4c03e53493e39a0e64448897ce" title="Returns whether any object of type objectsType is hit along the ray.">raycastAny()</a> <a class="el" href="classPxBatchQuery.html#fac52261caebfbc6f3aeb3ba1a66a3a6" title="Find all objects of type objectsType which a ray intersects.">raycastMultiple()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="623fdf0b33e7d51c1b5ca278d8f19a75"></a><!-- doxytag: member="PxBatchQuery::release" ref="623fdf0b33e7d51c1b5ca278d8f19a75" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Releases <a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> from PxSceneQueryManager. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxSceneQueryManager </dd></dl>

</div>
</div><p>
<a class="anchor" name="28fd9a0463371729b24884555ea8322a"></a><!-- doxytag: member="PxBatchQuery::sweepMultiple" ref="28fd9a0463371729b24884555ea8322a" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), void *userData=NULL, const PxSceneQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::sweepMultiple           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep returning multiple results. 
<p>
Find all rigid actors that get hit along the sweep. Each result contains data as specified by the outputFlags field.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Touching hits are not ordered.<p>
If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e002dc1872a0b54841a72433b73aaf3"></a><!-- doxytag: member="PxBatchQuery::sweepSingle" ref="5e002dc1872a0b54841a72433b73aaf3" args="(const PxGeometry &amp;geometry, const PxTransform &amp;pose, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFlags outputFlags=PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV, const PxSceneQueryFilterData &amp;filterData=PxSceneQueryFilterData(), void *userData=NULL, const PxSceneQueryCache *cache=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxBatchQuery::sweepSingle           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>outputFlags</em> = <code>PxSceneQueryFlag::eIMPACT|PxSceneQueryFlag::eNORMAL|PxSceneQueryFlag::eDISTANCE|PxSceneQueryFlag::eUV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>filterData</em> = <code><a class="el" href="structPxSceneQueryFilterData.html">PxSceneQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPxSceneQueryCache.html">PxSceneQueryCache</a> *&nbsp;</td>
          <td class="paramname"> <em>cache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweeps returning a single result. 
<p>
Returns the first rigid actor that is hit along the ray. Data for a blocking hit will be returned as specified by the outputFlags field. Touching hits will be ignored.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a shape from the scene is already overlapping with the query shape in its starting position, behavior is controlled by the <a class="el" href="structPxSceneQueryFlag.html#870184de09e7892e22a92d773a554e5df24db6df9f1ef83469f0048cf8e582a3" title="Enable/disable initial overlap tests in sweeps. Also mark returned hits as initially...">PxSceneQueryFlag::eINITIAL_OVERLAP</a> flag.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>Pose of the sweep object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputFlags</em>&nbsp;</td><td>Specifies which properties should be written to the hit information. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterData</em>&nbsp;</td><td>Filtering data and simple logic. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Cached hit shape (optional). Ray is tested against cached shape first then against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__scenequery.html#g2dc54d958235a00e66cc0785d23b1ce1" title="collection of set bits defined in PxSceneQueryFlag.">PxSceneQueryFlags</a> <a class="el" href="structPxSceneQueryFilterData.html" title="Scene query filtering data.">PxSceneQueryFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxBatchQuery_8h-source.html">PxBatchQuery.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
