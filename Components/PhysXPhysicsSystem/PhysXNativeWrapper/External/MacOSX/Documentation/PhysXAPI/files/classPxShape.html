<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxShape Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxShape Class Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><!-- doxytag: class="PxShape" --><!-- doxytag: inherits="PxSerializable" -->Abstract class for collision shapes.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxShape_8h-source.html">PxShape.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for PxShape:</div>
<div class="dynsection">
<p><center><img src="classPxShape__inherit__graph.png" border="0" usemap="#PxShape__inherit__map" alt="Inheritance graph"></center>
<map name="PxShape__inherit__map">
<area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="5,5,112,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for PxShape:</div>
<div class="dynsection">
<p><center><img src="classPxShape__coll__graph.png" border="0" usemap="#PxShape__coll__map" alt="Collaboration graph"></center>
<map name="PxShape__coll__map">
<area shape="rect" href="classPxSerializable.html" title="Base class for serializable objects." alt="" coords="84,96,191,123"><area shape="rect" href="classPxFlags.html" title="PxFlags\&lt; PxSerialFlag::Enum, PxU16 \&gt;" alt="" coords="6,5,270,32"></map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classPxShape-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#165dc6eaf5c58997b90b06176220be37">release</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the shape.  <a href="#165dc6eaf5c58997b90b06176220be37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxGeometryType.html#efc79f72c4c479192ac19d41a6f30ed5">PxGeometryType::Enum</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20">getGeometryType</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the geometry type of the shape.  <a href="#8365c22a5780649bd890703b3ebc1f20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#c6112e8c0ee9803eb3436bbaf673d98a">setGeometry</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;geometry)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the geometry of the shape.  <a href="#c6112e8c0ee9803eb3436bbaf673d98a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#531b866a02c9dc59131bc9887c065ff8">getGeometry</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the geometry from the shape in a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> wrapper class.  <a href="#531b866a02c9dc59131bc9887c065ff8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#e4fe68bfc7be057dae8d0c3eac5a725c">getBoxGeometry</a> (<a class="el" href="classPxBoxGeometry.html">PxBoxGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#e4fe68bfc7be057dae8d0c3eac5a725c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#d36c41170461ca897fa70433d23268fa">getSphereGeometry</a> (<a class="el" href="classPxSphereGeometry.html">PxSphereGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#d36c41170461ca897fa70433d23268fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#8515335ab379ef0709b083ea09ce0a00">getCapsuleGeometry</a> (<a class="el" href="classPxCapsuleGeometry.html">PxCapsuleGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#8515335ab379ef0709b083ea09ce0a00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#fe05ad6f093d762abaf03e3e0c1de704">getPlaneGeometry</a> (<a class="el" href="classPxPlaneGeometry.html">PxPlaneGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#fe05ad6f093d762abaf03e3e0c1de704"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#80bed1030a3740c7d033f65d97ee2ec4">getConvexMeshGeometry</a> (<a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#80bed1030a3740c7d033f65d97ee2ec4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#e10e641c3e5d77993440abe64c1446ea">getTriangleMeshGeometry</a> (<a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#e10e641c3e5d77993440abe64c1446ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3709d51079c4c809415d31087ebac65b">getHeightFieldGeometry</a> (<a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;geometry) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the geometry of the shape.  <a href="#3709d51079c4c809415d31087ebac65b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxRigidActor.html">PxRigidActor</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#9420fb0e20e20c5eb30b58b22b6b0d18">getActor</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the actor which this shape is associated with.  <a href="#9420fb0e20e20c5eb30b58b22b6b0d18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#92094013e48f0fc6f691cab6fc7e1204">getWorldBounds</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the shape.  <a href="#92094013e48f0fc6f691cab6fc7e1204"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3a6cfeffd66041c78fc046db852a7b31">setMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> *const *materials, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> materialCount)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns material(s) to the shape.  <a href="#3a6cfeffd66041c78fc046db852a7b31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3404d60b2b1cd25e0fbd7ca3c04bdae8">getNbMaterials</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of materials assigned to the shape.  <a href="#3404d60b2b1cd25e0fbd7ca3c04bdae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#ff2d73a45797ccbae25fcf4d580bd6da">getMaterials</a> (<a class="el" href="classPxMaterial.html">PxMaterial</a> **userBuffer, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> bufferSize) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve all the material pointers associated with the shape.  <a href="#ff2d73a45797ccbae25fcf4d580bd6da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#77dcd61c00720726ffcce1fe370f0042">getMaterialFromInternalFaceIndex</a> (<a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> faceIndex) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve material from given triangle index.  <a href="#77dcd61c00720726ffcce1fe370f0042"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27">setContactOffset</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> contactOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the contact offset.  <a href="#07c638b68e14de5e284a03dbcc128d27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3f0686821f3f8fe92103e31c293f118b">getContactOffset</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the contact offset.  <a href="#3f0686821f3f8fe92103e31c293f118b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b">setRestOffset</a> (<a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> restOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the rest offset.  <a href="#413afb25b39a7a0cf0981aa01c6d7f8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#060ff01d827d559fc8b11385a161eca0">getRestOffset</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the rest offset.  <a href="#060ff01d827d559fc8b11385a161eca0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#3c879df184ef40514589c5aa3d1f2a33">setFlag</a> (<a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a> flag, bool value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets shape flags.  <a href="#3c879df184ef40514589c5aa3d1f2a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#fc179cb4b2146af98c76623d2fc0db6e">setFlags</a> (<a class="el" href="classPxFlags.html">PxShapeFlags</a> inFlags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets shape flags.  <a href="#fc179cb4b2146af98c76623d2fc0db6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715">getFlags</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves shape flags.  <a href="#cd44b1c761c14e6319475797ec4f9715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508">setName</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a>.  <a href="#51a289ac174c48ccc8d0b09d3fd90508"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959">getName</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieves the name string set with <a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <a href="#800c362a0a6c6c120525876f56378959"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#ea80dc76611b2c04b6af5575e915cf5b">raycast</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;rayOrigin, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;rayDir, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> maxDist, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> hintFlags, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> maxHits, <a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> *rayHits, bool firstHit, const <a class="el" href="classPxTransform.html">PxTransform</a> *shapePose=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raycast test against the shape.  <a href="#ea80dc76611b2c04b6af5575e915cf5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#4f86100c4d5314eac287670c66cac2ae">overlap</a> (const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;otherGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;otherGeomPose, const <a class="el" href="classPxTransform.html">PxTransform</a> *shapePose=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test overlap between the shape and a geometry object.  <a href="#4f86100c4d5314eac287670c66cac2ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#eec4ec7805542271d77e9991fc47db7b">sweep</a> (const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;otherGeom, const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;otherGeomPose, <a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;sweepHit, <a class="el" href="classPxFlags.html">PxSceneQueryFlags</a> hintFlags, const <a class="el" href="classPxTransform.html">PxTransform</a> *shapePose=NULL) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sweep a geometry object against the shape.  <a href="#eec4ec7805542271d77e9991fc47db7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#534106ef0a978dfb710a6b8e7c9443bd">getConcreteTypeName</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns string name of dynamic type.  <a href="#534106ef0a978dfb710a6b8e7c9443bd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Pose Manipulation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#9f32c7cea3b5701de3f815cd64c978df">setLocalPose</a> (const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;pose)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the pose of the shape in actor space, i.e. relative to the actor they are owned by.  <a href="#9f32c7cea3b5701de3f815cd64c978df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classPxTransform.html">PxTransform</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#f455638230d515adbfb561f1064e70a1">getLocalPose</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by.  <a href="#f455638230d515adbfb561f1064e70a1"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Filtering</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#a0c62176ed01c9fb14c26ad7c393963c">setSimulationFilterData</a> (const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the user definable collision filter data.  <a href="#a0c62176ed01c9fb14c26ad7c393963c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#bfa95e009f300060ba648637fb685686">getSimulationFilterData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the shape's collision filter data.  <a href="#bfa95e009f300060ba648637fb685686"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#282790ded1919929e38f0d3f32ff7e9a">resetFiltering</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the object to reset interactions and re-run collision filters in the next simulation step.  <a href="#282790ded1919929e38f0d3f32ff7e9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#c98191c26e55ecebfd9eb4553c969fab">setQueryFilterData</a> (const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the user definable query filter data.  <a href="#c98191c26e55ecebfd9eb4553c969fab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#b6cbdfa3d01aa384f4d0109a591d1f12">getQueryFilterData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the shape's Query filter data.  <a href="#b6cbdfa3d01aa384f4d0109a591d1f12"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#557b80df942f039122b0ee750d29c552">userData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object.  <a href="#557b80df942f039122b0ee750d29c552"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#cfd714c1862ec698431eaccf1250dc86">PxShape</a> (<a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PX_INLINE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#1182001467d5d453f302e62d748abc31">PxShape</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#7d037f8803d4dff457564e9903452e94">~PxShape</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxShape.html#1bcf5d308c093487d38bf773f5e3f1c2">isKindOf</a> (const char *name) const </td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Abstract class for collision shapes. 
<p>
An instance can be created by calling the createShape() method of the <a class="el" href="classPxRigidActor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies...">PxRigidActor</a> class, or by adding the shape descriptors into the PxRigidActorDesc class before creating the actor.<p>
<h3>Visualizations</h3>
<p>
<ul>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10714f24bab39d1bbe8b131bd10ef5552b" title="Visualize bounds (AABBs in world space).">PxVisualizationParameter::eCOLLISION_AABBS</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb10515f4c3c72ee88d7507b52d6ccd14eab" title="Shape visualization.">PxVisualizationParameter::eCOLLISION_SHAPES</a> </li>
<li><a class="el" href="structPxVisualizationParameter.html#dce8e8a77c144356b0968d2b9f79eb100ad9dcb10f5f3d6ded3baecfc1e387d3" title="Shape axis visualization.">PxVisualizationParameter::eCOLLISION_AXES</a></li>
</ul>
The NVIDIA PhysX SDK users guide describes which shape geometries can collide with each other (direct link: <a href="PhysXDocumentation.chm::/Guide/collision_Interactions.html">users guide</a>)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#4023bdc10613959dec2b9ef947814866" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActor.createShape()</a> <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a> <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a> <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a> <a class="el" href="classPxPlaneGeometry.html" title="Class describing a plane geometry.">PxPlaneGeometry</a> <a class="el" href="classPxConvexMeshGeometry.html" title="Convex mesh geometry class.">PxConvexMeshGeometry</a> <a class="el" href="classPxTriangleMeshGeometry.html" title="Triangle mesh geometry class.">PxTriangleMeshGeometry</a> <a class="el" href="classPxHeightFieldGeometry.html" title="Height field geometry class.">PxHeightFieldGeometry</a> </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cfd714c1862ec698431eaccf1250dc86"></a><!-- doxytag: member="PxShape::PxShape" ref="cfd714c1862ec698431eaccf1250dc86" args="(PxRefResolver &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PxShape::PxShape           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRefResolver.html">PxRefResolver</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1182001467d5d453f302e62d748abc31"></a><!-- doxytag: member="PxShape::PxShape" ref="1182001467d5d453f302e62d748abc31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PX_INLINE PxShape::PxShape           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7d037f8803d4dff457564e9903452e94"></a><!-- doxytag: member="PxShape::~PxShape" ref="7d037f8803d4dff457564e9903452e94" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxShape::~PxShape           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="9420fb0e20e20c5eb30b58b22b6b0d18"></a><!-- doxytag: member="PxShape::getActor" ref="9420fb0e20e20c5eb30b58b22b6b0d18" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxRigidActor.html">PxRigidActor</a>&amp; PxShape::getActor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the actor which this shape is associated with. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The actor this shape is associated with.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidStatic.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK...">PxRigidStatic</a>, <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>, <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00064">PxShapeExt::getGlobalPose()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e4fe68bfc7be057dae8d0c3eac5a725c"></a><!-- doxytag: member="PxShape::getBoxGeometry" ref="e4fe68bfc7be057dae8d0c3eac5a725c" args="(PxBoxGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getBoxGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxBoxGeometry.html">PxBoxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8515335ab379ef0709b083ea09ce0a00"></a><!-- doxytag: member="PxShape::getCapsuleGeometry" ref="8515335ab379ef0709b083ea09ce0a00" args="(PxCapsuleGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getCapsuleGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxCapsuleGeometry.html">PxCapsuleGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="534106ef0a978dfb710a6b8e7c9443bd"></a><!-- doxytag: member="PxShape::getConcreteTypeName" ref="534106ef0a978dfb710a6b8e7c9443bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxShape::getConcreteTypeName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns string name of dynamic type. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>class name of most derived type of this object. </dd></dl>

<p>Reimplemented from <a class="el" href="classPxSerializable.html#2a5e41e56b01a2113bb2a9fed0ad0795">PxSerializable</a>.</p>

</div>
</div><p>
<a class="anchor" name="3f0686821f3f8fe92103e31c293f118b"></a><!-- doxytag: member="PxShape::getContactOffset" ref="3f0686821f3f8fe92103e31c293f118b" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxShape::getContactOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the contact offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The contact offset of the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27" title="Sets the contact offset.">setContactOffset()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="80bed1030a3740c7d033f65d97ee2ec4"></a><!-- doxytag: member="PxShape::getConvexMeshGeometry" ref="80bed1030a3740c7d033f65d97ee2ec4" args="(PxConvexMeshGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getConvexMeshGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxConvexMeshGeometry.html">PxConvexMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd44b1c761c14e6319475797ec4f9715"></a><!-- doxytag: member="PxShape::getFlags" ref="cd44b1c761c14e6319475797ec4f9715" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxFlags.html">PxShapeFlags</a> PxShape::getFlags           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves shape flags. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The values of the shape flags.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#3c879df184ef40514589c5aa3d1f2a33" title="Sets shape flags.">setFlag()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="531b866a02c9dc59131bc9887c065ff8"></a><!-- doxytag: member="PxShape::getGeometry" ref="531b866a02c9dc59131bc9887c065ff8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxGeometryHolder.html">PxGeometryHolder</a> PxShape::getGeometry           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the geometry from the shape in a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> wrapper class. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classPxGeometryHolder.html" title="Geometry holder class.">PxGeometryHolder</a> object containing the geometry;</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> <a class="el" href="classPxShape.html#c6112e8c0ee9803eb3436bbaf673d98a" title="Adjust the geometry of the shape.">setGeometry()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8365c22a5780649bd890703b3ebc1f20"></a><!-- doxytag: member="PxShape::getGeometryType" ref="8365c22a5780649bd890703b3ebc1f20" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxGeometryType.html#efc79f72c4c479192ac19d41a6f30ed5">PxGeometryType::Enum</a> PxShape::getGeometryType           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the geometry type of the shape. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Type of shape geometry.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3709d51079c4c809415d31087ebac65b"></a><!-- doxytag: member="PxShape::getHeightFieldGeometry" ref="3709d51079c4c809415d31087ebac65b" args="(PxHeightFieldGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getHeightFieldGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxHeightFieldGeometry.html">PxHeightFieldGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f455638230d515adbfb561f1064e70a1"></a><!-- doxytag: member="PxShape::getLocalPose" ref="f455638230d515adbfb561f1064e70a1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxTransform.html">PxTransform</a> PxShape::getLocalPose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the pose of the shape in actor space, i.e. relative to the actor they are owned by. 
<p>
This transformation is identity by default.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pose of shape relative to the actor's frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#9f32c7cea3b5701de3f815cd64c978df" title="Sets the pose of the shape in actor space, i.e. relative to the actor they are owned...">setLocalPose()</a> </dd></dl>

<p>Referenced by <a class="el" href="PxShapeExt_8h-source.html#l00064">PxShapeExt::getGlobalPose()</a>.</p>

</div>
</div><p>
<a class="anchor" name="77dcd61c00720726ffcce1fe370f0042"></a><!-- doxytag: member="PxShape::getMaterialFromInternalFaceIndex" ref="77dcd61c00720726ffcce1fe370f0042" args="(PxU32 faceIndex) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxMaterial.html">PxMaterial</a>* PxShape::getMaterialFromInternalFaceIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>faceIndex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve material from given triangle index. 
<p>
The input index is the internal triangle index as used inside the SDK. This is the index returned to users by various SDK functions such as raycasts.<p>
This function is only useful for triangle meshes or heightfields, which have per-triangle materials. For other shapes the function returns the single material associated with the shape, regardless of the index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>faceIndex</em>&nbsp;</td><td>The internal triangle index whose material you want to retrieve. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Material from input triangle</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html">PxMaterial</a> <a class="el" href="classPxShape.html#3404d60b2b1cd25e0fbd7ca3c04bdae8" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Deletes the material.">PxMaterial::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ff2d73a45797ccbae25fcf4d580bd6da"></a><!-- doxytag: member="PxShape::getMaterials" ref="ff2d73a45797ccbae25fcf4d580bd6da" args="(PxMaterial **userBuffer, PxU32 bufferSize) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxShape::getMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> **&nbsp;</td>
          <td class="paramname"> <em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve all the material pointers associated with the shape. 
<p>
You can retrieve the number of material pointers by calling <a class="el" href="classPxShape.html#3404d60b2b1cd25e0fbd7ca3c04bdae8" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a><p>
Note: Removing materials with <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Deletes the material.">PxMaterial::release()</a> will invalidate the pointer of the released material.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>userBuffer</em>&nbsp;</td><td>The buffer to store the material pointers. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufferSize</em>&nbsp;</td><td>Size of provided user buffer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of material pointers written to the buffer.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html">PxMaterial</a> <a class="el" href="classPxShape.html#3404d60b2b1cd25e0fbd7ca3c04bdae8" title="Returns the number of materials assigned to the shape.">getNbMaterials()</a> <a class="el" href="classPxMaterial.html#c0635989d3c9a12d55d25fe468e91256" title="Deletes the material.">PxMaterial::release()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="800c362a0a6c6c120525876f56378959"></a><!-- doxytag: member="PxShape::getName" ref="800c362a0a6c6c120525876f56378959" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* PxShape::getName           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
retrieves the name string set with <a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name associated with the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#51a289ac174c48ccc8d0b09d3fd90508" title="Sets a name string for the object that can be retrieved with getName().">setName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3404d60b2b1cd25e0fbd7ca3c04bdae8"></a><!-- doxytag: member="PxShape::getNbMaterials" ref="3404d60b2b1cd25e0fbd7ca3c04bdae8" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxShape::getNbMaterials           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of materials assigned to the shape. 
<p>
You can use <a class="el" href="classPxShape.html#ff2d73a45797ccbae25fcf4d580bd6da" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> to retrieve the material pointers.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of materials associated with this shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxMaterial.html">PxMaterial</a> <a class="el" href="classPxShape.html#ff2d73a45797ccbae25fcf4d580bd6da" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe05ad6f093d762abaf03e3e0c1de704"></a><!-- doxytag: member="PxShape::getPlaneGeometry" ref="fe05ad6f093d762abaf03e3e0c1de704" args="(PxPlaneGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getPlaneGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxPlaneGeometry.html">PxPlaneGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b6cbdfa3d01aa384f4d0109a591d1f12"></a><!-- doxytag: member="PxShape::getQueryFilterData" ref="b6cbdfa3d01aa384f4d0109a591d1f12" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a> PxShape::getQueryFilterData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the shape's Query filter data. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#c98191c26e55ecebfd9eb4553c969fab" title="Sets the user definable query filter data.">setQueryFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="060ff01d827d559fc8b11385a161eca0"></a><!-- doxytag: member="PxShape::getRestOffset" ref="060ff01d827d559fc8b11385a161eca0" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> PxShape::getRestOffset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the rest offset. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The rest offset of the shape.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b" title="Sets the rest offset.">setRestOffset()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bfa95e009f300060ba648637fb685686"></a><!-- doxytag: member="PxShape::getSimulationFilterData" ref="bfa95e009f300060ba648637fb685686" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structPxFilterData.html">PxFilterData</a> PxShape::getSimulationFilterData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the shape's collision filter data. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#a0c62176ed01c9fb14c26ad7c393963c" title="Sets the user definable collision filter data.">setSimulationFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d36c41170461ca897fa70433d23268fa"></a><!-- doxytag: member="PxShape::getSphereGeometry" ref="d36c41170461ca897fa70433d23268fa" args="(PxSphereGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getSphereGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxSphereGeometry.html">PxSphereGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e10e641c3e5d77993440abe64c1446ea"></a><!-- doxytag: member="PxShape::getTriangleMeshGeometry" ref="e10e641c3e5d77993440abe64c1446ea" args="(PxTriangleMeshGeometry &amp;geometry) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::getTriangleMeshGeometry           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxTriangleMeshGeometry.html">PxTriangleMeshGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fetch the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the type of geometry to extract does not match the geometry type of the shape then the method will return false and the passed in geometry descriptor is not modified.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>The descriptor to save the shape's geometry data to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success else false</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="92094013e48f0fc6f691cab6fc7e1204"></a><!-- doxytag: member="PxShape::getWorldBounds" ref="92094013e48f0fc6f691cab6fc7e1204" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPxBounds3.html">PxBounds3</a> PxShape::getWorldBounds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the axis aligned bounding box enclosing the shape. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The shape's bounding box.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBounds3.html" title="Class representing 3D range or axis aligned bounding box.">PxBounds3</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1bcf5d308c093487d38bf773f5e3f1c2"></a><!-- doxytag: member="PxShape::isKindOf" ref="1bcf5d308c093487d38bf773f5e3f1c2" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::isKindOf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>Reimplemented from <a class="el" href="classPxSerializable.html#6b6d98ad5d2dd045de560930c3789415">PxSerializable</a>.</p>

<p>References <a class="el" href="PxSerialFramework_8h-source.html#l00572">PxSerializable::isKindOf()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f86100c4d5314eac287670c66cac2ae"></a><!-- doxytag: member="PxShape::overlap" ref="4f86100c4d5314eac287670c66cac2ae" args="(const PxGeometry &amp;otherGeom, const PxTransform &amp;otherGeomPose, const PxTransform *shapePose=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::overlap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>otherGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>otherGeomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>shapePose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test overlap between the shape and a geometry object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherGeom</em>&nbsp;</td><td>The other geometry object to test overlap with </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherGeomPose</em>&nbsp;</td><td>Pose of the other geometry object </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapePose</em>&nbsp;</td><td>Optional pose for the <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> object. If NULL, the shape's global pose is used. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the shape overlaps the geometry object</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea80dc76611b2c04b6af5575e915cf5b"></a><!-- doxytag: member="PxShape::raycast" ref="ea80dc76611b2c04b6af5575e915cf5b" args="(const PxVec3 &amp;rayOrigin, const PxVec3 &amp;rayDir, PxReal maxDist, PxSceneQueryFlags hintFlags, PxU32 maxHits, PxRaycastHit *rayHits, bool firstHit, const PxTransform *shapePose=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> PxShape::raycast           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rayOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rayDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>maxDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>hintFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>maxHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxRaycastHit.html">PxRaycastHit</a> *&nbsp;</td>
          <td class="paramname"> <em>rayHits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>firstHit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>shapePose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Raycast test against the shape. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rayOrigin</em>&nbsp;</td><td>The origin of the ray to test the geometry object against </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rayDir</em>&nbsp;</td><td>The direction of the ray to test the geometry object against </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Maximum ray length </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Specification of the kind of information to retrieve on hit. Combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> flags </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxHits</em>&nbsp;</td><td>max number of returned hits = size of 'rayHits' buffer </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>rayHits</em>&nbsp;</td><td>Raycast hits information </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>firstHit</em>&nbsp;</td><td>Set to false if the closest hit point should be computed, else the query aborts as soon as the first valid hit point is found. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapePose</em>&nbsp;</td><td>Optional pose for the <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> object. If NULL, the shape's global pose is used. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of hits between the ray and the shape</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>RaycastHit <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="165dc6eaf5c58997b90b06176220be37"></a><!-- doxytag: member="PxShape::release" ref="165dc6eaf5c58997b90b06176220be37" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the shape. 
<p>
Do not keep a reference to the deleted instance.<p>
For static rigid actors it is not possible to release all shapes associated with the actor. An attempt to remove the last shape will be ignored.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidActor.html#4023bdc10613959dec2b9ef947814866" title="Creates a new shape with default properties and a list of materials and adds it to...">PxRigidActor::createShape()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="282790ded1919929e38f0d3f32ff7e9a"></a><!-- doxytag: member="PxShape::resetFiltering" ref="282790ded1919929e38f0d3f32ff7e9a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::resetFiltering           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks the object to reset interactions and re-run collision filters in the next simulation step. 
<p>
This call forces the object to remove all existing collision interactions, to search anew for existing contact pairs and to run the collision filters again for found collision pairs.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>All persistent state of existing interactions will be lost and can not be retrieved even if the same collison pair is found again in the next step. This will mean, for example, that you will not get notified about persistent contact for such an interaction (see <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f69f6e6373fe2f024618f752c388ef6b1" title="Call contact report callback or trigger callback while this collision pair is in...">PxPairFlag::eNOTIFY_TOUCH_PERSISTS</a>), the contact pair will be interpreted as newly found instead.<p>
Lost touch contact reports will be sent for every collision pair which includes this shape, if they have been requested through <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f201281be698379417370bf7b0aeeb78e" title="Call contact report callback or trigger callback when this collision pair stops to...">PxPairFlag::eNOTIFY_TOUCH_LOST</a> or <a class="el" href="structPxPairFlag.html#60e71a2948b030140f840766a3f7ac2f517ae07b413b27ad008f766170051ae6" title="Call contact report callback when the contact force between the actors of this collision...">PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST</a>.<p>
This is an expensive operation, don't use it if you don't have to.<p>
Can be used to retrieve collision pairs that were killed by the collision filters (see <a class="el" href="structPxFilterFlag.html#8de424e04d86b5772436423b0dc58083ee697d6e40f98c73eb8f5cb5201f1ca9" title="Ignore the collision pair as long as the bounding volumes of the pair objects overlap...">PxFilterFlag::eKILL</a>)</dd></dl>
<b>Sleeping:</b> Does wake up the actor.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__physics.html#g9db06e901a760fb02c06f27bf3e474b3" title="Filter shader to specify handling of collision pairs.">PxSimulationFilterShader</a> <a class="el" href="classPxSimulationFilterCallback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="07c638b68e14de5e284a03dbcc128d27"></a><!-- doxytag: member="PxShape::setContactOffset" ref="07c638b68e14de5e284a03dbcc128d27" args="(PxReal contactOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setContactOffset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>contactOffset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the contact offset. 
<p>
Shapes whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive and greater than the rest offset. Having a contactOffset greater than than the restOffset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated. This prevents jitter that would occur if the constraint were enforced only when shapes were within the rest distance.<p>
<b>Default:</b> 0.02f * <a class="el" href="classPxTolerancesScale.html#7d93bf20de0e5b54783eda5bb64effeb">PxTolerancesScale::length</a><p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contactOffset</em>&nbsp;</td><td><b>Range:</b> (maximum(0,restOffset),inf)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#3f0686821f3f8fe92103e31c293f118b" title="Retrieves the contact offset.">getContactOffset</a> <a class="el" href="classPxTolerancesScale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are...">PxTolerancesScale</a> <a class="el" href="classPxShape.html#413afb25b39a7a0cf0981aa01c6d7f8b" title="Sets the rest offset.">setRestOffset</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c879df184ef40514589c5aa3d1f2a33"></a><!-- doxytag: member="PxShape::setFlag" ref="3c879df184ef40514589c5aa3d1f2a33" args="(PxShapeFlag::Enum flag, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setFlag           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a">PxShapeFlag::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets shape flags. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>At least one of the following flags has to remain set: <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a>, <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1aef2b90024dc86be72b68bbaf94a5821d" title="The shape is a trigger which can send reports whenever other shapes enter/leave its...">PxShapeFlag::eTRIGGER_SHAPE</a>, <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1abc7ec24b00ed57f3914482f0706c6273" title="The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...).">PxShapeFlag::eSCENE_QUERY_SHAPE</a></dd></dl>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>The shape flag to enable/disable. See <a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>True to set the flag. False to clear the flag specified in flag.</td></tr>
  </table>
</dl>
<b>Default:</b> <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a1b3a6f33eb84ee2dc74eac63aa86f2a4" title="Enable debug renderer for this shape.">PxShapeFlag::eVISUALIZATION</a> | <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> | <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1abc7ec24b00ed57f3914482f0706c6273" title="The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...).">PxShapeFlag::eSCENE_QUERY_SHAPE</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715" title="Retrieves shape flags.">getFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc179cb4b2146af98c76623d2fc0db6e"></a><!-- doxytag: member="PxShape::setFlags" ref="fc179cb4b2146af98c76623d2fc0db6e" args="(PxShapeFlags inFlags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setFlags           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxShapeFlags</a>&nbsp;</td>
          <td class="paramname"> <em>inFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets shape flags. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxShapeFlag.html" title="Flags which affect the behavior of PxShapes.">PxShapeFlag</a> <a class="el" href="classPxShape.html#cd44b1c761c14e6319475797ec4f9715" title="Retrieves shape flags.">getFlags()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6112e8c0ee9803eb3436bbaf673d98a"></a><!-- doxytag: member="PxShape::setGeometry" ref="c6112e8c0ee9803eb3436bbaf673d98a" args="(const PxGeometry &amp;geometry)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setGeometry           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust the geometry of the shape. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The type of the passed in geometry must match the geometry type of the shape. It is not allowed to change the geometry type of a shape.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>geometry</em>&nbsp;</td><td>New geometry of the shape.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="structPxGeometryType.html" title="A geometry type.">PxGeometryType</a> <a class="el" href="classPxShape.html#8365c22a5780649bd890703b3ebc1f20" title="Get the geometry type of the shape.">getGeometryType()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f32c7cea3b5701de3f815cd64c978df"></a><!-- doxytag: member="PxShape::setLocalPose" ref="9f32c7cea3b5701de3f815cd64c978df" args="(const PxTransform &amp;pose)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setLocalPose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pose</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the pose of the shape in actor space, i.e. relative to the actor they are owned by. 
<p>
This transformation is identity by default.<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<em>Note:</em> Does not automatically update the inertia properties of the owning actor (if applicable); use the PhysX extensions method <a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a> to do this.<p>
<b>Default:</b> the identity transform<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pose</em>&nbsp;</td><td>The new transform from the actor frame to the shape frame. <b>Range:</b> rigid body transform</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#f455638230d515adbfb561f1064e70a1" title="Retrieves the pose of the shape in actor space, i.e. relative to the actor they are...">getLocalPose()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a6cfeffd66041c78fc046db852a7b31"></a><!-- doxytag: member="PxShape::setMaterials" ref="3a6cfeffd66041c78fc046db852a7b31" args="(PxMaterial *const *materials, PxU32 materialCount)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setMaterials           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxMaterial.html">PxMaterial</a> *const *&nbsp;</td>
          <td class="paramname"> <em>materials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>materialCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns material(s) to the shape. 
<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materials</em>&nbsp;</td><td>List of material pointers to assign to the shape. See <a class="el" href="classPxMaterial.html">PxMaterial</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>materialCount</em>&nbsp;</td><td>The number of materials provided.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxPhysics.html#35c1965ae47b24e119c6a2d8ce25477e" title="Creates a new material with default properties.">PxPhysics.createMaterial()</a> <a class="el" href="classPxShape.html#ff2d73a45797ccbae25fcf4d580bd6da" title="Retrieve all the material pointers associated with the shape.">getMaterials()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="51a289ac174c48ccc8d0b09d3fd90508"></a><!-- doxytag: member="PxShape::setName" ref="51a289ac174c48ccc8d0b09d3fd90508" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setName           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets a name string for the object that can be retrieved with <a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a>. 
<p>
This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.<p>
<b>Default:</b> NULL<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name string to set the objects name to.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#800c362a0a6c6c120525876f56378959" title="retrieves the name string set with setName().">getName()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c98191c26e55ecebfd9eb4553c969fab"></a><!-- doxytag: member="PxShape::setQueryFilterData" ref="c98191c26e55ecebfd9eb4553c969fab" args="(const PxFilterData &amp;data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setQueryFilterData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user definable query filter data. 
<p>
<b>Default:</b> (0,0,0,0)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#b6cbdfa3d01aa384f4d0109a591d1f12" title="Retrieves the shape&#39;s Query filter data.">getQueryFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="413afb25b39a7a0cf0981aa01c6d7f8b"></a><!-- doxytag: member="PxShape::setRestOffset" ref="413afb25b39a7a0cf0981aa01c6d7f8b" args="(PxReal restOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setRestOffset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>restOffset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the rest offset. 
<p>
Two shapes will come to rest at a distance equal to the sum of their restOffset values. If the restOffset is 0, they should converge to touching exactly. Having a restOffset greater than zero is useful to have objects slide smoothly, so that they do not get hung up on irregularities of each others' surfaces.<p>
<b>Default:</b> 0.0f<p>
<b>Sleeping:</b> Does <b>NOT</b> wake the associated actor up automatically.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restOffset</em>&nbsp;</td><td><b>Range:</b> (-inf,contactOffset)</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#060ff01d827d559fc8b11385a161eca0" title="Retrieves the rest offset.">getRestOffset</a> <a class="el" href="classPxShape.html#07c638b68e14de5e284a03dbcc128d27" title="Sets the contact offset.">setContactOffset</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0c62176ed01c9fb14c26ad7c393963c"></a><!-- doxytag: member="PxShape::setSimulationFilterData" ref="a0c62176ed01c9fb14c26ad7c393963c" args="(const PxFilterData &amp;data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PxShape::setSimulationFilterData           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPxFilterData.html">PxFilterData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the user definable collision filter data. 
<p>
<b>Sleeping:</b> Does wake up the actor if the filter data change causes a formerly suppressed collision pair to be enabled.<p>
<b>Default:</b> (0,0,0,0)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxShape.html#bfa95e009f300060ba648637fb685686" title="Retrieves the shape&#39;s collision filter data.">getSimulationFilterData()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="eec4ec7805542271d77e9991fc47db7b"></a><!-- doxytag: member="PxShape::sweep" ref="eec4ec7805542271d77e9991fc47db7b" args="(const PxVec3 &amp;unitDir, const PxReal distance, const PxGeometry &amp;otherGeom, const PxTransform &amp;otherGeomPose, PxSweepHit &amp;sweepHit, PxSceneQueryFlags hintFlags, const PxTransform *shapePose=NULL) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PxShape::sweep           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxGeometry.html">PxGeometry</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>otherGeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>otherGeomPose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxSweepHit.html">PxSweepHit</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sweepHit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFlags</a>&nbsp;</td>
          <td class="paramname"> <em>hintFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxTransform.html">PxTransform</a> *&nbsp;</td>
          <td class="paramname"> <em>shapePose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sweep a geometry object against the shape. 
<p>
Currently only box, sphere, capsule and convex mesh shapes are supported, i.e. the swept geometry object must be one of those types.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction along which the geometry object should be swept. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherGeom</em>&nbsp;</td><td>The geometry object to sweep against the shape </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>otherGeomPose</em>&nbsp;</td><td>Pose of the geometry object </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sweepHit</em>&nbsp;</td><td>The sweep hit information. Only valid if this method returns true. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Specification of the kind of information to retrieve on hit. Combination of <a class="el" href="structPxSceneQueryFlag.html" title="Scene query specification.">PxSceneQueryFlag</a> flags </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapePose</em>&nbsp;</td><td>Optional pose for the <a class="el" href="classPxShape.html" title="Abstract class for collision shapes.">PxShape</a> object. If NULL, the shape's global pose is used. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the swept geometry object hits the shape</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxGeometry.html" title="A geometry object.">PxGeometry</a> <a class="el" href="classPxTransform.html" title="class representing a rigid euclidean transform as a quaternion and a vector">PxTransform</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="557b80df942f039122b0ee750d29c552"></a><!-- doxytag: member="PxShape::userData" ref="557b80df942f039122b0ee750d29c552" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classPxShape.html#557b80df942f039122b0ee750d29c552">PxShape::userData</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
user can assign this to whatever, usually to create a 1:1 relationship with a user object. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxShape_8h-source.html">PxShape.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
