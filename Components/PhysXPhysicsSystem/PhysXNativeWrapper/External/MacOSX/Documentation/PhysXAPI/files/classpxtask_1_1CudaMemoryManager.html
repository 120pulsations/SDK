<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: pxtask::CudaMemoryManager Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespacepxtask.html">pxtask</a>::<a class="el" href="classpxtask_1_1CudaMemoryManager.html">CudaMemoryManager</a>
  </div>
<div class="contents">
<h1>pxtask::CudaMemoryManager Class Reference</h1><!-- doxytag: class="pxtask::CudaMemoryManager" -->Allocator class for different kinds of CUDA related memory.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxCudaMemoryManager_8h-source.html">PxCudaMemoryManager.h</a>&gt;</code>
<p>

<p>
<a href="classpxtask_1_1CudaMemoryManager-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classpxtask_1_1NvCudaBuffer.html">NvCudaBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#74b444ef18021949f7b2a48b9a6f5d70">alloc</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory of given type and size. Returns a CudaBuffer if successful. Returns NULL if failed.  <a href="#74b444ef18021949f7b2a48b9a6f5d70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#4aa31626f5eceb59d6c5dca1abc66b5b">alloc</a> (<a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a> memorySpace, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic heap allocator without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>.  <a href="#4aa31626f5eceb59d6c5dca1abc66b5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#0a3d8e8d090335394ee9352b316a63d0">free</a> (<a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a> memorySpace, <a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a> addr)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic heap deallocator without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>.  <a href="#0a3d8e8d090335394ee9352b316a63d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#cdfcdb0fbec175afe289eb0189d263d5">realloc</a> (<a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a> memorySpace, <a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a> addr, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Basic heap realloc without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>.  <a href="#cdfcdb0fbec175afe289eb0189d263d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#a6eb1906679cab0279e878960f4d062e">getStats</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type, <a class="el" href="structpxtask_1_1CudaMemoryManagerStats.html">CudaMemoryManagerStats</a> &amp;outStats)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve stats for the memory of given type. See <a class="el" href="structpxtask_1_1CudaMemoryManagerStats.html" title="Memory statistics struct returned by CudaMemMgr::getStats().">CudaMemoryManagerStats</a>.  <a href="#a6eb1906679cab0279e878960f4d062e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#a670e0ca2ae27679b950fc6849ceeb43">reserve</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type, size_t size)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#d530bced0885bd14e996ad2760d39cd6">setPageSize</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type, size_t size)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#32214ee9e3fd14b873f64befbb48ce4d">setMaxMemorySize</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type, size_t size)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#016660b844badfd01b5d4029a99b119e">getBaseSize</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the base size. The base memory block stays persistently allocated over the SDKs life time.  <a href="#016660b844badfd01b5d4029a99b119e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#1f74412ce82feb9856133c802eb1856d">getPageSize</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the currently set page size. The memory grows and shrinks in blocks of size (2^n pageSize).  <a href="#1f74412ce82feb9856133c802eb1856d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#66f3fda658b7f07a25c2a4bb31a83fa3">getMaxMemorySize</a> (const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the upper limit until which the manager is allowed to allocate additional pages from the CUDA driver.  <a href="#66f3fda658b7f07a25c2a4bb31a83fa3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html#3ab9a3258d2ed44ed6acc5f738797630">~CudaMemoryManager</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">protected destructor  <a href="#3ab9a3258d2ed44ed6acc5f738797630"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Allocator class for different kinds of CUDA related memory. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="3ab9a3258d2ed44ed6acc5f738797630"></a><!-- doxytag: member="pxtask::CudaMemoryManager::~CudaMemoryManager" ref="3ab9a3258d2ed44ed6acc5f738797630" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pxtask::CudaMemoryManager::~CudaMemoryManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
protected destructor 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4aa31626f5eceb59d6c5dca1abc66b5b"></a><!-- doxytag: member="pxtask::CudaMemoryManager::alloc" ref="4aa31626f5eceb59d6c5dca1abc66b5b" args="(CudaBufferMemorySpace::Enum memorySpace, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a> pxtask::CudaMemoryManager::alloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED)&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Basic heap allocator without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="74b444ef18021949f7b2a48b9a6f5d70"></a><!-- doxytag: member="pxtask::CudaMemoryManager::alloc" ref="74b444ef18021949f7b2a48b9a6f5d70" args="(const CudaBufferType &amp;type, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpxtask_1_1NvCudaBuffer.html">NvCudaBuffer</a>* pxtask::CudaMemoryManager::alloc           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED)&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate memory of given type and size. Returns a CudaBuffer if successful. Returns NULL if failed. 
<p>

</div>
</div><p>
<a class="anchor" name="0a3d8e8d090335394ee9352b316a63d0"></a><!-- doxytag: member="pxtask::CudaMemoryManager::free" ref="0a3d8e8d090335394ee9352b316a63d0" args="(CudaBufferMemorySpace::Enum memorySpace, CudaBufferPtr addr)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaMemoryManager::free           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Basic heap deallocator without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="016660b844badfd01b5d4029a99b119e"></a><!-- doxytag: member="pxtask::CudaMemoryManager::getBaseSize" ref="016660b844badfd01b5d4029a99b119e" args="(const CudaBufferType &amp;type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t pxtask::CudaMemoryManager::getBaseSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the base size. The base memory block stays persistently allocated over the SDKs life time. 
<p>

</div>
</div><p>
<a class="anchor" name="66f3fda658b7f07a25c2a4bb31a83fa3"></a><!-- doxytag: member="pxtask::CudaMemoryManager::getMaxMemorySize" ref="66f3fda658b7f07a25c2a4bb31a83fa3" args="(const CudaBufferType &amp;type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t pxtask::CudaMemoryManager::getMaxMemorySize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the upper limit until which the manager is allowed to allocate additional pages from the CUDA driver. 
<p>

</div>
</div><p>
<a class="anchor" name="1f74412ce82feb9856133c802eb1856d"></a><!-- doxytag: member="pxtask::CudaMemoryManager::getPageSize" ref="1f74412ce82feb9856133c802eb1856d" args="(const CudaBufferType &amp;type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t pxtask::CudaMemoryManager::getPageSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the currently set page size. The memory grows and shrinks in blocks of size (2^n pageSize). 
<p>

</div>
</div><p>
<a class="anchor" name="a6eb1906679cab0279e878960f4d062e"></a><!-- doxytag: member="pxtask::CudaMemoryManager::getStats" ref="a6eb1906679cab0279e878960f4d062e" args="(const CudaBufferType &amp;type, CudaMemoryManagerStats &amp;outStats)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::CudaMemoryManager::getStats           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpxtask_1_1CudaMemoryManagerStats.html">CudaMemoryManagerStats</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outStats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve stats for the memory of given type. See <a class="el" href="structpxtask_1_1CudaMemoryManagerStats.html" title="Memory statistics struct returned by CudaMemMgr::getStats().">CudaMemoryManagerStats</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="cdfcdb0fbec175afe289eb0189d263d5"></a><!-- doxytag: member="pxtask::CudaMemoryManager::realloc" ref="cdfcdb0fbec175afe289eb0189d263d5" args="(CudaBufferMemorySpace::Enum memorySpace, CudaBufferPtr addr, size_t size, NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED))=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaMemoryManager::realloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html#a855d5b0feabfa58ebd70206ce116d93">CudaBufferMemorySpace::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>memorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a>&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NV_ALLOC_INFO_PARAMS_DECL(NULL, 0, NULL, UNASSIGNED)&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Basic heap realloc without <a class="el" href="classpxtask_1_1NvCudaBuffer.html" title="Buffer which keeps informations about allocated piece of memory.">NvCudaBuffer</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="a670e0ca2ae27679b950fc6849ceeb43"></a><!-- doxytag: member="pxtask::CudaMemoryManager::reserve" ref="a670e0ca2ae27679b950fc6849ceeb43" args="(const CudaBufferType &amp;type, size_t size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaMemoryManager::reserve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ensure that a given amount of free memory is available. Triggers CUDA allocations in size of (2^n * pageSize) if necessary. Returns false if page allocations failed. 
</div>
</div><p>
<a class="anchor" name="32214ee9e3fd14b873f64befbb48ce4d"></a><!-- doxytag: member="pxtask::CudaMemoryManager::setMaxMemorySize" ref="32214ee9e3fd14b873f64befbb48ce4d" args="(const CudaBufferType &amp;type, size_t size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaMemoryManager::setMaxMemorySize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the upper limit until which pages of a given memory type can be allocated. Reducing the max when it is already hit does not shrink the memory until it is deallocated by releasing the buffers which own the memory. 
</div>
</div><p>
<a class="anchor" name="d530bced0885bd14e996ad2760d39cd6"></a><!-- doxytag: member="pxtask::CudaMemoryManager::setPageSize" ref="d530bced0885bd14e996ad2760d39cd6" args="(const CudaBufferType &amp;type, size_t size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::CudaMemoryManager::setPageSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the page size. The managed memory grows by blocks 2^n * pageSize. Page allocations trigger CUDA driver allocations, so the page size should be reasonably big. Returns false if input size was invalid, i.e. not power of two. Default is 2 MB. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxCudaMemoryManager_8h-source.html">PxCudaMemoryManager.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
