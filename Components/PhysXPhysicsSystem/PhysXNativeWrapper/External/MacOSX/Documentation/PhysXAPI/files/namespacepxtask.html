<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: pxtask Namespace Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>pxtask Namespace Reference<br>
<small>
[<a class="el" href="group__physics.html">Physics</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CpuDispatcher.html">CpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classpxtask_1_1CpuDispatcher.html" title="A CpuDispatcher is responsible for scheduling the execution of tasks passed to it...">CpuDispatcher</a> is responsible for scheduling the execution of tasks passed to it by the SDK.  <a href="classpxtask_1_1CpuDispatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1CudaInteropMode.html">CudaInteropMode</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Possible graphic/CUDA interoperability modes for context.  <a href="structpxtask_1_1CudaInteropMode.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManagerDesc.html">CudaContextManagerDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Descriptor used to create a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>.  <a href="classpxtask_1_1CudaContextManagerDesc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manages memory, thread locks, and task scheduling for a CUDA context.  <a href="classpxtask_1_1CudaContextManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1ScopedCudaLock.html">ScopedCudaLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience class for holding CUDA lock within a scope.  <a href="classpxtask_1_1ScopedCudaLock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1AllocId.html">AllocId</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ID of the Feature which owns/allocated memory from the heap.  <a href="structpxtask_1_1AllocId.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1CudaBufferMemorySpace.html">CudaBufferMemorySpace</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">memory type managed by a heap  <a href="structpxtask_1_1CudaBufferMemorySpace.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1AllocInfo.html">AllocInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class to track allocation statistics, see PxgMirrored  <a href="classpxtask_1_1AllocInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1AllocIdStats.html">AllocIdStats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">statistics collected per AllocationId by HeapManager.  <a href="structpxtask_1_1AllocIdStats.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1CudaBufferFlags.html">CudaBufferFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hint flag to tell how the buffer will be used.  <a href="structpxtask_1_1CudaBufferFlags.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1CudaMemoryManagerStats.html">CudaMemoryManagerStats</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory statistics struct returned by CudaMemMgr::getStats().  <a href="structpxtask_1_1CudaMemoryManagerStats.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1CudaBufferType.html">CudaBufferType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer type: made of hint flags and the memory space (Device Memory, Pinned Host Memory, ...).  <a href="structpxtask_1_1CudaBufferType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1NvCudaBuffer.html">NvCudaBuffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Buffer which keeps informations about allocated piece of memory.  <a href="classpxtask_1_1NvCudaBuffer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1CudaMemoryManager.html">CudaMemoryManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocator class for different kinds of CUDA related memory.  <a href="classpxtask_1_1CudaMemoryManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1GpuCopyDesc.html">GpuCopyDesc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Input descriptor for the GpuDispatcher's built-in copy kernel.  <a href="structpxtask_1_1GpuCopyDesc.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuCopyDescQueue.html">GpuCopyDescQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container class for queueing <a class="el" href="structpxtask_1_1GpuCopyDesc.html" title="Input descriptor for the GpuDispatcher&#39;s built-in copy kernel.">GpuCopyDesc</a> instances in pinned (non-pageable) CPU memory.  <a href="classpxtask_1_1GpuCopyDescQueue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html">GpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> dispatcher.  <a href="classpxtask_1_1GpuDispatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1GpuTaskHint.html">GpuTaskHint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define the 'flavor' of a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a>.  <a href="structpxtask_1_1GpuTaskHint.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuTask.html">GpuTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classpxtask_1_1Task.html" title="A BaseTask implementation with deferred execution and full dependencies.">Task</a> implementation for launching CUDA work.  <a href="classpxtask_1_1GpuTask.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1SpuDispatcher.html">SpuDispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classpxtask_1_1SpuDispatcher.html" title="A SpuDispatcher.">SpuDispatcher</a>.  <a href="classpxtask_1_1SpuDispatcher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1SpuTask.html">SpuTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A task to be executed on one or more SPUs.  <a href="classpxtask_1_1SpuTask.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1BaseTask.html">BaseTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class of all task types.  <a href="classpxtask_1_1BaseTask.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1Task.html">Task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classpxtask_1_1BaseTask.html" title="Base class of all task types.">BaseTask</a> implementation with deferred execution and full dependencies.  <a href="classpxtask_1_1Task.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1LightCpuTask.html">LightCpuTask</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classpxtask_1_1BaseTask.html" title="Base class of all task types.">BaseTask</a> implementation with immediate execution and simple dependencies.  <a href="classpxtask_1_1LightCpuTask.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpxtask_1_1TaskType.html">TaskType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies the type of each heavyweight <a class="el" href="classpxtask_1_1Task.html" title="A BaseTask implementation with deferred execution and full dependencies.">Task</a> object.  <a href="structpxtask_1_1TaskType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1TaskManager.html">TaskManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> interface.  <a href="classpxtask_1_1TaskManager.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">CudaBufferPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepxtask.html#7b3fd96a79e26af97d758f5efed18d19">TaskID</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepxtask.html#8e55cd6fa3bb267751abfa3d046fb478">getSuggestedCudaDeviceOrdinal</a> (<a class="el" href="classPxErrorCallback.html">PxErrorCallback</a> &amp;errc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ask the NVIDIA control panel which GPU has been selected for use by PhysX. Returns -1 if no PhysX capable GPU is found or GPU PhysX has been disabled.  <a href="#8e55cd6fa3bb267751abfa3d046fb478"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepxtask.html#2358d2828a706be307f29adc7ff03103">createCudaContextManager</a> (<a class="el" href="classPxFoundation.html">PxFoundation</a> &amp;foundation, const <a class="el" href="classpxtask_1_1CudaContextManagerDesc.html">CudaContextManagerDesc</a> &amp;desc, physx::PxProfileZoneManager *mgr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a CUDA Context manager, complete with heaps and task dispatcher. You only need one CUDA context manager per GPU device you intend to use for CUDA tasks. If mgr is NULL, no profiling of CUDA code will be possible.  <a href="#2358d2828a706be307f29adc7ff03103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepxtask.html#c7638636df83c50b77177b8156b504b8">loadPhysxGPUModule</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get handle of <a class="el" href="namespacephysx.html">physx</a> GPU module  <a href="#c7638636df83c50b77177b8156b504b8"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="bf10afd9ba50f72a4b44f23eb7883a9b"></a><!-- doxytag: member="pxtask::CudaBufferPtr" ref="bf10afd9ba50f72a4b44f23eb7883a9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacepxtask.html#bf10afd9ba50f72a4b44f23eb7883a9b">pxtask::CudaBufferPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7b3fd96a79e26af97d758f5efed18d19"></a><!-- doxytag: member="pxtask::TaskID" ref="7b3fd96a79e26af97d758f5efed18d19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long <a class="el" href="namespacepxtask.html#7b3fd96a79e26af97d758f5efed18d19">pxtask::TaskID</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="2358d2828a706be307f29adc7ff03103"></a><!-- doxytag: member="pxtask::createCudaContextManager" ref="2358d2828a706be307f29adc7ff03103" args="(PxFoundation &amp;foundation, const CudaContextManagerDesc &amp;desc, physx::PxProfileZoneManager *mgr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a>* pxtask::createCudaContextManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxFoundation.html">PxFoundation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>foundation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CudaContextManagerDesc &amp;&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">physx::PxProfileZoneManager *&nbsp;</td>
          <td class="paramname"> <em>mgr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate a CUDA Context manager, complete with heaps and task dispatcher. You only need one CUDA context manager per GPU device you intend to use for CUDA tasks. If mgr is NULL, no profiling of CUDA code will be possible. 
<p>

</div>
</div><p>
<a class="anchor" name="8e55cd6fa3bb267751abfa3d046fb478"></a><!-- doxytag: member="pxtask::getSuggestedCudaDeviceOrdinal" ref="8e55cd6fa3bb267751abfa3d046fb478" args="(PxErrorCallback &amp;errc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pxtask::getSuggestedCudaDeviceOrdinal           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxErrorCallback.html">PxErrorCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>errc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ask the NVIDIA control panel which GPU has been selected for use by PhysX. Returns -1 if no PhysX capable GPU is found or GPU PhysX has been disabled. 
<p>

</div>
</div><p>
<a class="anchor" name="c7638636df83c50b77177b8156b504b8"></a><!-- doxytag: member="pxtask::loadPhysxGPUModule" ref="c7638636df83c50b77177b8156b504b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pxtask::loadPhysxGPUModule           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get handle of <a class="el" href="namespacephysx.html">physx</a> GPU module 
<p>

</div>
</div><p>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
