<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: PxRigidBodyExt Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
<div class="contents">
<h1>PxRigidBodyExt Class Reference<br>
<small>
[<a class="el" href="group__extensions.html">Extensions</a>]</small>
</h1><!-- doxytag: class="PxRigidBodyExt" -->utility functions for use with <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> and subclasses  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxRigidBodyExt_8h-source.html">PxRigidBodyExt.h</a>&gt;</code>
<p>

<p>
<a href="classPxRigidBodyExt-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2">updateMassAndInertia</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *shapeDensities, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> shapeDensityCount, const <a class="el" href="classPxVec3.html">PxVec3</a> *massLocalPose=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computation of mass properties for a rigid body actor.  <a href="#c4c7289f0a4917e56efe9a5e5e257cd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#00f706a62511b62c164c10598b5fb795">updateMassAndInertia</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> density, const <a class="el" href="classPxVec3.html">PxVec3</a> *massLocalPose=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computation of mass properties for a rigid body actor.  <a href="#00f706a62511b62c164c10598b5fb795"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#d4b981d0b1ea512e9f8a18d2b4409122">setMassAndUpdateInertia</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *shapeMasses, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> shapeMassCount, const <a class="el" href="classPxVec3.html">PxVec3</a> *massLocalPose=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computation of mass properties for a rigid body actor.  <a href="#d4b981d0b1ea512e9f8a18d2b4409122"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#3761da349b5833efb1cdf649c8241d07">setMassAndUpdateInertia</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> mass, const <a class="el" href="classPxVec3.html">PxVec3</a> *massLocalPose=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computation of mass properties for a rigid body actor.  <a href="#3761da349b5833efb1cdf649c8241d07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#0e3a81ec184fe8981dbbcebff6da1f61">addForceAtPos</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool wakeup=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor.  <a href="#0e3a81ec184fe8981dbbcebff6da1f61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#732d9246bc10aef4aa76f4a6c941c7c5">addForceAtLocalPos</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool wakeup=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor.  <a href="#732d9246bc10aef4aa76f4a6c941c7c5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#0df8ee24ebf8b840909bdb09c8d90717">addLocalForceAtPos</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool wakeup=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor.  <a href="#0df8ee24ebf8b840909bdb09c8d90717"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#ce7be55938f260ee769b993c6c90d288">addLocalForceAtLocalPos</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;force, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos, <a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a> mode=PxForceMode::eFORCE, bool wakeup=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor.  <a href="#ce7be55938f260ee769b993c6c90d288"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#cce31159814673df7781eb62ee032ef2">getVelocityAtPos</a> (const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the velocity of a point given in world coordinates if it were attached to the specified body and moving with it.  <a href="#cce31159814673df7781eb62ee032ef2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#b79486496528ea623774e7a9b021633d">getLocalVelocityAtLocalPos</a> (const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the velocity of a point given in local coordinates if it were attached to the specified body and moving with it.  <a href="#b79486496528ea623774e7a9b021633d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classPxVec3.html">PxVec3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#fed73713b7c1032a7ce921c7de25a278">getVelocityAtOffset</a> (const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;pos)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the velocity of a point (offset from the origin of the body) given in world coordinates if it were attached to the specified body and moving with it.  <a href="#fed73713b7c1032a7ce921c7de25a278"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#b940307ae809b7a606a94b10e9ccccf0">linearSweepSingle</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, <a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> &amp;batchQuery, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags, bool useShapeFilterData=true, <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList=NULL, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> filterDataCount=0, void *userData=NULL, const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *sweepCache=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with the body's geometry objects.  <a href="#b940307ae809b7a606a94b10e9ccccf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPxRigidBodyExt.html#3489ef4430d0a8931fa5d6fbf121163b">linearSweepMultiple</a> (<a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;body, <a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> &amp;batchQuery, const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;unitDir, const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> distance, <a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a> filterFlags, bool useShapeFilterData=true, <a class="el" href="structPxFilterData.html">PxFilterData</a> *filterDataList=NULL, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> filterDataCount=0, void *userData=NULL, const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *sweepCache=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a linear sweep through space with the body's geometry objects, returning all overlaps.  <a href="#3489ef4430d0a8931fa5d6fbf121163b"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
utility functions for use with <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> and subclasses 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> <a class="el" href="classPxRigidDynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> <a class="el" href="classPxArticulationLink.html" title="a component of an articulation that represents a rigid body">PxArticulationLink</a> </dd></dl>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="732d9246bc10aef4aa76f4a6c941c7c5"></a><!-- doxytag: member="PxRigidBodyExt::addForceAtLocalPos" ref="732d9246bc10aef4aa76f4a6c941c7c5" args="(PxRigidBody &amp;body, const PxVec3 &amp;force, const PxVec3 &amp;pos, PxForceMode::Enum mode=PxForceMode::eFORCE, bool wakeup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::addForceAtLocalPos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeup</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to apply the force to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). Only eFORCE and eIMPULSE are supported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <p>
<a class="el" href="classPxRigidBodyExt.html#0e3a81ec184fe8981dbbcebff6da1f61" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classPxRigidBodyExt.html#0df8ee24ebf8b840909bdb09c8d90717" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtPos()</a> <a class="el" href="classPxRigidBodyExt.html#ce7be55938f260ee769b993c6c90d288" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtLocalPos()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e3a81ec184fe8981dbbcebff6da1f61"></a><!-- doxytag: member="PxRigidBodyExt::addForceAtPos" ref="0e3a81ec184fe8981dbbcebff6da1f61" args="(PxRigidBody &amp;body, const PxVec3 &amp;force, const PxVec3 &amp;pos, PxForceMode::Enum mode=PxForceMode::eFORCE, bool wakeup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::addForceAtPos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeup</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to apply the force to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). Only eFORCE and eIMPULSE are supported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <p>
<a class="el" href="classPxRigidBodyExt.html#732d9246bc10aef4aa76f4a6c941c7c5" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classPxRigidBodyExt.html#0df8ee24ebf8b840909bdb09c8d90717" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtPos()</a> <a class="el" href="classPxRigidBodyExt.html#ce7be55938f260ee769b993c6c90d288" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtLocalPos()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce7be55938f260ee769b993c6c90d288"></a><!-- doxytag: member="PxRigidBodyExt::addLocalForceAtLocalPos" ref="ce7be55938f260ee769b993c6c90d288" args="(PxRigidBody &amp;body, const PxVec3 &amp;force, const PxVec3 &amp;pos, PxForceMode::Enum mode=PxForceMode::eFORCE, bool wakeup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::addLocalForceAtLocalPos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeup</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in local coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to apply the force to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). Only eFORCE and eIMPULSE are supported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <p>
<a class="el" href="classPxRigidBodyExt.html#0e3a81ec184fe8981dbbcebff6da1f61" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classPxRigidBodyExt.html#732d9246bc10aef4aa76f4a6c941c7c5" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classPxRigidBodyExt.html#0df8ee24ebf8b840909bdb09c8d90717" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtPos()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0df8ee24ebf8b840909bdb09c8d90717"></a><!-- doxytag: member="PxRigidBodyExt::addLocalForceAtPos" ref="0df8ee24ebf8b840909bdb09c8d90717" args="(PxRigidBody &amp;body, const PxVec3 &amp;force, const PxVec3 &amp;pos, PxForceMode::Enum mode=PxForceMode::eFORCE, bool wakeup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::addLocalForceAtPos           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxForceMode.html#adaaafefe0478d829b816154c676e545">PxForceMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>PxForceMode::eFORCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeup</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies a force (or impulse) defined in the actor local coordinate frame, acting at a particular point in global coordinates, to the actor. 
<p>
Note that if the force does not act along the center of mass of the actor, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.<p>
<a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> determines if the force is to be conventional or impulsive.<p>
<b>Sleeping:</b> This call wakes the actor if it is sleeping and the wakeup parameter is true (default).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to apply the force to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a>). Only eFORCE and eIMPULSE are supported. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeup</em>&nbsp;</td><td>Specify if the call should wake up the actor.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structPxForceMode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that...">PxForceMode</a> <p>
<a class="el" href="classPxRigidBodyExt.html#0e3a81ec184fe8981dbbcebff6da1f61" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classPxRigidBodyExt.html#732d9246bc10aef4aa76f4a6c941c7c5" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classPxRigidBodyExt.html#ce7be55938f260ee769b993c6c90d288" title="Applies a force (or impulse) defined in the actor local coordinate frame, acting...">addLocalForceAtLocalPos()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b79486496528ea623774e7a9b021633d"></a><!-- doxytag: member="PxRigidBodyExt::getLocalVelocityAtLocalPos" ref="b79486496528ea623774e7a9b021633d" args="(const PxRigidBody &amp;body, const PxVec3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBodyExt::getLocalVelocityAtLocalPos           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the velocity of a point given in local coordinates if it were attached to the specified body and moving with it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body the point is attached to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position we wish to determine the velocity for, defined in the local frame. <b>Range:</b> position vector </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The velocity of point in the local frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getLocalPointVelocity() </dd></dl>

</div>
</div><p>
<a class="anchor" name="fed73713b7c1032a7ce921c7de25a278"></a><!-- doxytag: member="PxRigidBodyExt::getVelocityAtOffset" ref="fed73713b7c1032a7ce921c7de25a278" args="(const PxRigidBody &amp;body, const PxVec3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBodyExt::getVelocityAtOffset           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the velocity of a point (offset from the origin of the body) given in world coordinates if it were attached to the specified body and moving with it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body the point is attached to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position (offset from the origin of the body) we wish to determine the velocity for, defined in the global frame. <b>Range:</b> position vector </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The velocity of point (offset from the origin of the body) in the global frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getLocalPointVelocity() </dd></dl>

</div>
</div><p>
<a class="anchor" name="cce31159814673df7781eb62ee032ef2"></a><!-- doxytag: member="PxRigidBodyExt::getVelocityAtPos" ref="cce31159814673df7781eb62ee032ef2" args="(const PxRigidBody &amp;body, const PxVec3 &amp;pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classPxVec3.html">PxVec3</a> PxRigidBodyExt::getVelocityAtPos           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the velocity of a point given in world coordinates if it were attached to the specified body and moving with it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body the point is attached to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>Position we wish to determine the velocity for, defined in the global frame. <b>Range:</b> position vector </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The velocity of point in the global frame.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>getLocalPointVelocity() </dd></dl>

</div>
</div><p>
<a class="anchor" name="3489ef4430d0a8931fa5d6fbf121163b"></a><!-- doxytag: member="PxRigidBodyExt::linearSweepMultiple" ref="3489ef4430d0a8931fa5d6fbf121163b" args="(PxRigidBody &amp;body, PxBatchQuery &amp;batchQuery, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFilterFlags filterFlags, bool useShapeFilterData=true, PxFilterData *filterDataList=NULL, PxU32 filterDataCount=0, void *userData=NULL, const PxSweepCache *sweepCache=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::linearSweepMultiple           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>batchQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useShapeFilterData</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>filterDataCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *&nbsp;</td>
          <td class="paramname"> <em>sweepCache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a linear sweep through space with the body's geometry objects, returning all overlaps. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Supported geometries are: <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a>, <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a>, <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a>. Other geometry types will be ignored. <p>
Internally this call is mapped to <a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74" title="Performs a linear sweep through space with a compound of geometry objects, returning...">PxBatchQuery::linearCompoundGeometrySweepMultiple()</a>.</dd></dl>
The function sweeps all geometry objects of the body through space and reports all objects in the scene which intersect. Apart from the number of objects intersected in this way, and the objects intersected, information on the closest intersection is put in an <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> structure which can be processed in the callback. See <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchQuery</em>&nbsp;</td><td>The scene query object to process the query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Choose if to sweep against static, dynamic or both types of objects, or other filter logic. See <a class="el" href="group__scenequery.html#g1053f2a90c18d39bf7dad2f8f283ec4a" title="Collection of set bits defined in PxSceneQueryFilterFlag.">PxSceneQueryFilterFlags</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>useShapeFilterData</em>&nbsp;</td><td>True if the filter data of the body shapes should be used for the query. False if no filtering is needed or separate filter data is provided. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Custom filter data to use for each geometry object of the body. Only considered if useShapeFilterData is false. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataCount</em>&nbsp;</td><td>Number of filter data entries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sweepCache</em>&nbsp;</td><td>Sweep cache to use with the query</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the all overlapping objects.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> <a class="el" href="classPxBatchQuery.html#6de1720a86b3c9bd92d34137c5086e74" title="Performs a linear sweep through space with a compound of geometry objects, returning...">PxBatchQuery::linearCompoundGeometrySweepMultiple</a> <a class="el" href="group__scenequery.html#g1053f2a90c18d39bf7dad2f8f283ec4a" title="Collection of set bits defined in PxSceneQueryFilterFlag.">PxSceneQueryFilterFlags</a> <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b940307ae809b7a606a94b10e9ccccf0"></a><!-- doxytag: member="PxRigidBodyExt::linearSweepSingle" ref="b940307ae809b7a606a94b10e9ccccf0" args="(PxRigidBody &amp;body, PxBatchQuery &amp;batchQuery, const PxVec3 &amp;unitDir, const PxReal distance, PxSceneQueryFilterFlags filterFlags, bool useShapeFilterData=true, PxFilterData *filterDataList=NULL, PxU32 filterDataCount=0, void *userData=NULL, const PxSweepCache *sweepCache=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void PxRigidBodyExt::linearSweepSingle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxBatchQuery.html">PxBatchQuery</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>batchQuery</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPxFlags.html">PxSceneQueryFilterFlags</a>&nbsp;</td>
          <td class="paramname"> <em>filterFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useShapeFilterData</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPxFilterData.html">PxFilterData</a> *&nbsp;</td>
          <td class="paramname"> <em>filterDataList</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>filterDataCount</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxSweepCache.html">PxSweepCache</a> *&nbsp;</td>
          <td class="paramname"> <em>sweepCache</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a linear sweep through space with the body's geometry objects. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Supported geometries are: <a class="el" href="classPxBoxGeometry.html" title="Class representing the geometry of a box.">PxBoxGeometry</a>, <a class="el" href="classPxSphereGeometry.html" title="A class representing the geometry of a sphere.">PxSphereGeometry</a>, <a class="el" href="classPxCapsuleGeometry.html" title="Class representing the geometry of a capsule.">PxCapsuleGeometry</a>. Other geometry types will be ignored. <p>
Internally this call is mapped to <a class="el" href="classPxBatchQuery.html#682de05ec97cefbfe993946bd4f6b824" title="Performs a linear sweep through space with a compound of geometry objects.">PxBatchQuery::linearCompoundGeometrySweepSingle()</a>.</dd></dl>
The function sweeps all specified geometry objects through space and reports any objects in the scene which intersect. Apart from the number of objects intersected in this way, and the objects intersected, information on the closest intersection is put in an <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> structure which can be processed in the callback. See <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body to sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>batchQuery</em>&nbsp;</td><td>The scene query object to process the query. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>unitDir</em>&nbsp;</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>distance</em>&nbsp;</td><td>Sweep distance. Needs to be larger than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterFlags</em>&nbsp;</td><td>Choose if to sweep against static, dynamic or both types of objects, or other filter logic. See <a class="el" href="group__scenequery.html#g1053f2a90c18d39bf7dad2f8f283ec4a" title="Collection of set bits defined in PxSceneQueryFilterFlag.">PxSceneQueryFilterFlags</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>useShapeFilterData</em>&nbsp;</td><td>True if the filter data of the body shapes should be used for the query. False if no filtering is needed or separate filter data is provided. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataList</em>&nbsp;</td><td>Custom filter data to use for each geometry object of the body. Only considered if useShapeFilterData is false. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterDataCount</em>&nbsp;</td><td>Number of filter data entries </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>userData</em>&nbsp;</td><td>user can assign this to a value of his choice, usually to identify this particular query </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sweepCache</em>&nbsp;</td><td>Sweep cache to use with the query</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns the closest overlapping object.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxBatchQuery.html" title="Batched queries object. This is used to perform several queries at the same time...">PxBatchQuery</a> <a class="el" href="classPxBatchQuery.html#682de05ec97cefbfe993946bd4f6b824" title="Performs a linear sweep through space with a compound of geometry objects.">PxBatchQuery::linearCompoundGeometrySweepSingle</a> <a class="el" href="group__scenequery.html#g1053f2a90c18d39bf7dad2f8f283ec4a" title="Collection of set bits defined in PxSceneQueryFilterFlag.">PxSceneQueryFilterFlags</a> <a class="el" href="structPxFilterData.html" title="PxFilterData is user-definable data which gets passed into the collision filtering...">PxFilterData</a> <a class="el" href="group__scenequery.html#g78d9cfe64610234a5293f8ca9407a6ae" title="Batched query prefiltering shader.">PxBatchQueryPreFilterShader</a> <a class="el" href="group__scenequery.html#g1c5651acda960fff16b5b04fe8810f85" title="Batched query postfiltering shader.">PxBatchQueryPostFilterShader</a> <a class="el" href="structPxSweepHit.html" title="This structure captures results for a single sweep query.">PxSweepHit</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3761da349b5833efb1cdf649c8241d07"></a><!-- doxytag: member="PxRigidBodyExt::setMassAndUpdateInertia" ref="3761da349b5833efb1cdf649c8241d07" args="(PxRigidBody &amp;body, PxReal mass, const PxVec3 *massLocalPose=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool PxRigidBodyExt::setMassAndUpdateInertia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>massLocalPose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computation of mass properties for a rigid body actor. 
<p>
This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the user-supplied value, and the inertia and center of mass are computed according to the rigid body's shapes and the input mass.<p>
If no collision shapes are found, the inertia tensor is set to (1,1,1)<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">updateMassAndInertia</a> for more details.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The the rigid body for which to set the mass and centre of mass local pose properties. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mass</em>&nbsp;</td><td>The mass of the body. Must be greater than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>massLocalPose</em>&nbsp;</td><td>The center of mass relative to the actor frame. If set to null then (0,0,0) is assumed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean. True on success else false.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">PxRigidBody::setCMassLocalPose</a> PxRigidBody::setMassSpaceInertia <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">PxRigidBody::setMass</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4b981d0b1ea512e9f8a18d2b4409122"></a><!-- doxytag: member="PxRigidBodyExt::setMassAndUpdateInertia" ref="d4b981d0b1ea512e9f8a18d2b4409122" args="(PxRigidBody &amp;body, const PxReal *shapeMasses, PxU32 shapeMassCount, const PxVec3 *massLocalPose=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool PxRigidBodyExt::setMassAndUpdateInertia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *&nbsp;</td>
          <td class="paramname"> <em>shapeMasses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>shapeMassCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>massLocalPose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computation of mass properties for a rigid body actor. 
<p>
This method sets the mass, inertia and center of mass of a rigid body. The mass is set to the sum of all user-supplied shape mass values, and the inertia and center of mass are computed according to the rigid body's shapes and the per shape mass input values.<p>
If no collision shapes are found, the inertia tensor is set to (1,1,1)<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If a single mass value should be used for the actor as a whole then the overloaded method <a class="el" href="classPxRigidBodyExt.html#d4b981d0b1ea512e9f8a18d2b4409122" title="Computation of mass properties for a rigid body actor.">setMassAndUpdateInertia()</a> with a single mass parameter can be used instead.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">updateMassAndInertia</a> for more details.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The the rigid body for which to set the mass and centre of mass local pose properties. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeMasses</em>&nbsp;</td><td>The per shape mass values. There must be one entry for each shape which has the <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> set. Other shapes are ignored. The mass values must be greater than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeMassCount</em>&nbsp;</td><td>The number of provided mass values. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>massLocalPose</em>&nbsp;</td><td>The center of mass relative to the actor frame. If set to null then (0,0,0) is assumed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean. True on success else false.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classPxRigidBody.html#b152773926fe7b222d61e982c3cb6adf" title="Sets the pose of the center of mass relative to the actor.">PxRigidBody::setCMassLocalPose</a> PxRigidBody::setMassSpaceInertia <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">PxRigidBody::setMass</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="00f706a62511b62c164c10598b5fb795"></a><!-- doxytag: member="PxRigidBodyExt::updateMassAndInertia" ref="00f706a62511b62c164c10598b5fb795" args="(PxRigidBody &amp;body, PxReal density, const PxVec3 *massLocalPose=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool PxRigidBodyExt::updateMassAndInertia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a>&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>massLocalPose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computation of mass properties for a rigid body actor. 
<p>
See previous method for details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>The density of the body. Used to compute the mass of the body. The density must be greater than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>massLocalPose</em>&nbsp;</td><td>The center of mass relative to the actor frame. If set to null then (0,0,0) is assumed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean. True on success else false.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBody::setMassLocalPose PxRigidBody::setMassSpaceInertia <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">PxRigidBody::setMass</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4c7289f0a4917e56efe9a5e5e257cd2"></a><!-- doxytag: member="PxRigidBodyExt::updateMassAndInertia" ref="c4c7289f0a4917e56efe9a5e5e257cd2" args="(PxRigidBody &amp;body, const PxReal *shapeDensities, PxU32 shapeDensityCount, const PxVec3 *massLocalPose=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool PxRigidBodyExt::updateMassAndInertia           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPxRigidBody.html">PxRigidBody</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__foundation.html#gd567a025d5e084c3b953c7ad755fc2b6">PxReal</a> *&nbsp;</td>
          <td class="paramname"> <em>shapeDensities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>shapeDensityCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPxVec3.html">PxVec3</a> *&nbsp;</td>
          <td class="paramname"> <em>massLocalPose</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computation of mass properties for a rigid body actor. 
<p>
To simulate a dynamic rigid actor, the SDK needs a mass and an inertia tensor.<p>
This method offers functionality to compute the necessary mass and inertia properties based on the shapes declared in the <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> descriptor and some additionally specified parameters. For each shape, the shape geometry, the shape positioning within the actor and the specified shape density are used to compute the body's mass and inertia properties.<p>
<ul>
<li>
Shapes without <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> set are ignored. </li>
<li>
Shapes with plane, triangle mesh or heightfield geometry and <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> set are not allowed for <a class="el" href="classPxRigidBody.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> collision </li>
</ul>
<p>
This method will set the mass, center of mass, and inertia tensor<p>
if no collision shapes are found, the inertia tensor is set to (1,1,1) and the mass to 1<p>
if massLocalPose is non-NULL, the rigid body's center of mass parameter will be set to the user provided value (massLocalPose) and the inertia tensor will be resolved at that point.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If all shapes of the actor have the same density then the overloaded method <a class="el" href="classPxRigidBodyExt.html#c4c7289f0a4917e56efe9a5e5e257cd2" title="Computation of mass properties for a rigid body actor.">updateMassAndInertia()</a> with a single density parameter can be used instead.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>body</em>&nbsp;</td><td>The rigid body. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeDensities</em>&nbsp;</td><td>The per shape densities. There must be one entry for each shape which has the <a class="el" href="structPxShapeFlag.html#6edb481aaa3a998c5d6dd3fc4ad87f1a7fa4fea0eecda9cc80a7aaa11a22df52" title="The shape will partake in collision in the physical simulation.">PxShapeFlag::eSIMULATION_SHAPE</a> set. Other shapes are ignored. The density values must be greater than 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeDensityCount</em>&nbsp;</td><td>The number of provided density values. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>massLocalPose</em>&nbsp;</td><td>The center of mass relative to the actor frame. If set to null then (0,0,0) is assumed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Boolean. True on success else false.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>PxRigidBody::setMassLocalPose PxRigidBody::setMassSpaceInertia <a class="el" href="classPxRigidBody.html#8a697a7a4b9bdd2c83a68e84b9bc3a35" title="Sets the mass of a dynamic actor.">PxRigidBody::setMass</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxRigidBodyExt_8h-source.html">PxRigidBodyExt.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
