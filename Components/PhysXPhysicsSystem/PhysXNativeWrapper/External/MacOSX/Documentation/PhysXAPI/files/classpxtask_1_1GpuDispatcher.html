<html>
	<head>
		<title>PhysX SDK 3.2 API Reference: pxtask::GpuDispatcher Class Reference</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<LINK HREF="NVIDIA.css" REL="stylesheet" TYPE="text/css">
	</head>

	<body bgcolor="#FFFFFF">
		<div id="header">
			<img alt="" src="images/PhysXlogo.png" align="middle"> <br>
			<center>
				<a class="qindex" href="main.html">Main Page</a> &nbsp; 
				<a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; 
				<a class="qindex" href="annotated.html">Compound List</a> &nbsp; 
				<a class="qindex" href="functions.html">Compound Members</a> &nbsp;  
			</center>
		</div>
<!-- Generated by Doxygen 1.5.8 -->
  <div class="navpath"><a class="el" href="namespacepxtask.html">pxtask</a>::<a class="el" href="classpxtask_1_1GpuDispatcher.html">GpuDispatcher</a>
  </div>
<div class="contents">
<h1>pxtask::GpuDispatcher Class Reference</h1><!-- doxytag: class="pxtask::GpuDispatcher" -->A <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> dispatcher.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="PxGpuDispatcher_8h-source.html">PxGpuDispatcher.h</a>&gt;</code>
<p>

<p>
<a href="classpxtask_1_1GpuDispatcher-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#66cc06a77ed990c09572908dbc5853f4">startSimulation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record the start of a simulation step.  <a href="#66cc06a77ed990c09572908dbc5853f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#b2480c847e804d4446d0ea38c03b90c7">startGroup</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record the start of a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> batch submission.  <a href="#b2480c847e804d4446d0ea38c03b90c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#aa55ad675f276a738695f3069815fab3">submitTask</a> (<a class="el" href="classpxtask_1_1Task.html">Task</a> &amp;task)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> for execution.  <a href="#aa55ad675f276a738695f3069815fab3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#fe2ac7f661b8cb56bb00a780953a493a">finishGroup</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record the end of a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> batch submission.  <a href="#fe2ac7f661b8cb56bb00a780953a493a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#75e432eac881d05e17f139127921d0e2">addCompletionPrereq</a> (<a class="el" href="classpxtask_1_1BaseTask.html">BaseTask</a> &amp;task)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a CUDA completion prerequisite dependency to a task.  <a href="#75e432eac881d05e17f139127921d0e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#e491fc0a9e5233ffd86a1c998a29afad">getCudaContextManager</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> associated with this <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>.  <a href="#e491fc0a9e5233ffd86a1c998a29afad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#90c4936cf7a9eb23be1b0d39dd017c4b">stopSimulation</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Record the end of a simulation frame.  <a href="#90c4936cf7a9eb23be1b0d39dd017c4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#f66cc749e7d65c95d089f44e6735f933">failureDetected</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if a CUDA call has returned a non-recoverable error.  <a href="#f66cc749e7d65c95d089f44e6735f933"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#a489f44e0f188fd0deb0c1a14038f1f2">forceFailureMode</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> into failure mode.  <a href="#a489f44e0f188fd0deb0c1a14038f1f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#774e2cdc7953cc1f9d91731318a6d346">getCurrentProfileBuffer</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the current in-use profile buffer.  <a href="#774e2cdc7953cc1f9d91731318a6d346"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__foundation.html#g1062e3989bd862873cdf0d4f7286d11d">PxU16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#df462801561f6cf3777d6a17190de281">registerKernelNames</a> (const char **, <a class="el" href="group__foundation.html#g1062e3989bd862873cdf0d4f7286d11d">PxU16</a> count)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register kernel names with PlatformAnalyzer.  <a href="#df462801561f6cf3777d6a17190de281"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#9a86fb18ab749a7a18d0c59196959c5a">launchCopyKernel</a> (<a class="el" href="structpxtask_1_1GpuCopyDesc.html">GpuCopyDesc</a> *desc, <a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a> count, <a class="el" href="PxGpuDispatcher_8h.html#b946c7f02e09efd788a204718015d88a">CUstream</a> stream)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Launch a copy kernel with arbitrary number of copy commands.  <a href="#9a86fb18ab749a7a18d0c59196959c5a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxtask_1_1GpuDispatcher.html#0c280320cb765185aa34cfe1703a1cee">~GpuDispatcher</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">protected destructor  <a href="#0c280320cb765185aa34cfe1703a1cee"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> dispatcher. 
<p>
A <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> executes GpuTasks submitted by one or more TaskManagers (one or more scenes). It maintains a CPU worker thread which waits on <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> "groups" to be submitted. The submission API is explicitly sessioned so that GpuTasks are dispatched together as a group whenever possible to improve parallelism on the GPU.<p>
A <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> cannot be allocated ad-hoc, they are created as a result of creating a <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>. Every <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> has a <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> instance that can be queried. In this way, each <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> is tied to exactly one CUDA context.<p>
A scene will use CPU fallback Tasks for GpuTasks if the <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> provided to it does not have a <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>. For this reason, the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> must be assigned to the <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> before the <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> is given to a scene.<p>
Multiple TaskManagers may safely share a single <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> instance, thus enabling scenes to share a CUDA context.<p>
Only <a class="el" href="classpxtask_1_1GpuDispatcher.html#f66cc749e7d65c95d089f44e6735f933" title="Returns true if a CUDA call has returned a non-recoverable error.">failureDetected()</a> is intended for use by the user. The rest of the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> public methods are reserved for internal use by only both TaskManagers and GpuTasks. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0c280320cb765185aa34cfe1703a1cee"></a><!-- doxytag: member="pxtask::GpuDispatcher::~GpuDispatcher" ref="0c280320cb765185aa34cfe1703a1cee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual pxtask::GpuDispatcher::~GpuDispatcher           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
protected destructor 
<p>
GpuDispatchers are allocated and freed by their <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="75e432eac881d05e17f139127921d0e2"></a><!-- doxytag: member="pxtask::GpuDispatcher::addCompletionPrereq" ref="75e432eac881d05e17f139127921d0e2" args="(BaseTask &amp;task)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::addCompletionPrereq           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpxtask_1_1BaseTask.html">BaseTask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>task</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a CUDA completion prerequisite dependency to a task. 
<p>
A <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> calls this function to add a prerequisite dependency on another task (usually a CpuTask) preventing that task from starting until all of the CUDA kernels and copies already launched have been completed. The <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will increment that task's reference count, blocking its execution, until the CUDA work is complete.<p>
This is generally only required when a CPU task is expecting the results of the CUDA kernels to have been copied into host memory.<p>
This mechanism is not at all not required to ensure CUDA kernels and copies are issued in the correct order. Kernel issue order is determined by normal task dependencies. The rule of thumb is to only use a blocking completion prerequisite if the task in question depends on a completed GPU-&gt;Host DMA.<p>
The <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> issues a blocking event record to CUDA for the purposes of tracking the already submitted CUDA work. When this event is resolved, the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> manually decrements the reference count of the specified task, allowing it to execute (assuming it does not have other pending prerequisites). 
</div>
</div><p>
<a class="anchor" name="f66cc749e7d65c95d089f44e6735f933"></a><!-- doxytag: member="pxtask::GpuDispatcher::failureDetected" ref="f66cc749e7d65c95d089f44e6735f933" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool pxtask::GpuDispatcher::failureDetected           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if a CUDA call has returned a non-recoverable error. 
<p>
A return value of true indicates a fatal error has occurred. To protect itself, the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> enters a fall through mode that allows GpuTasks to complete without being executed. This allows simulations to continue but leaves GPU content static or corrupted.<p>
The user may try to recover from these failures by deleting GPU content so the visual artifacts are mimimized. But there is no way to recover the state of the GPU actors before the failure. Once a CUDA context is in this state, the only recourse is to create a new CUDA context, a new scene, and start over.<p>
This is our "Best Effort" attempt to not turn a soft failure into a hard failure because continued use of a CUDA context after it has returned an error will usually result in a driver reset. However if the initial failure was serious enough, a reset may have already occurred by the time we learn of it. 
</div>
</div><p>
<a class="anchor" name="fe2ac7f661b8cb56bb00a780953a493a"></a><!-- doxytag: member="pxtask::GpuDispatcher::finishGroup" ref="fe2ac7f661b8cb56bb00a780953a493a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::finishGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Record the end of a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> batch submission. 
<p>
A <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> calls this function to notify the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> that it is done submitting a group of GpuTasks (GpuTasks which were all make ready to run by the same prerequisite dependency becoming resolved). If no other group submissions are in progress, the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will execute the set of ready tasks. 
</div>
</div><p>
<a class="anchor" name="a489f44e0f188fd0deb0c1a14038f1f2"></a><!-- doxytag: member="pxtask::GpuDispatcher::forceFailureMode" ref="a489f44e0f188fd0deb0c1a14038f1f2" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::forceFailureMode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Force the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> into failure mode. 
<p>
This API should be used if user code detects a non-recoverable CUDA error. This ensures the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> does not launch any further CUDA work. Subsequent calls to <a class="el" href="classpxtask_1_1GpuDispatcher.html#f66cc749e7d65c95d089f44e6735f933" title="Returns true if a CUDA call has returned a non-recoverable error.">failureDetected()</a> will return true. 
</div>
</div><p>
<a class="anchor" name="e491fc0a9e5233ffd86a1c998a29afad"></a><!-- doxytag: member="pxtask::GpuDispatcher::getCudaContextManager" ref="e491fc0a9e5233ffd86a1c998a29afad" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classpxtask_1_1CudaContextManager.html">CudaContextManager</a>* pxtask::GpuDispatcher::getCudaContextManager           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> associated with this <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>. 
<p>
Every <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a> has one <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a>, and every <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> has one <a class="el" href="classpxtask_1_1CudaContextManager.html" title="Manages memory, thread locks, and task scheduling for a CUDA context.">CudaContextManager</a>. 
</div>
</div><p>
<a class="anchor" name="774e2cdc7953cc1f9d91731318a6d346"></a><!-- doxytag: member="pxtask::GpuDispatcher::getCurrentProfileBuffer" ref="774e2cdc7953cc1f9d91731318a6d346" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* pxtask::GpuDispatcher::getCurrentProfileBuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to the current in-use profile buffer. 
<p>
The returned pointer should be passed to all kernel launches to enable CTA/Warp level profiling. If a data collector is not attached, or CTA profiling is not enabled, the pointer will be zero. 
</div>
</div><p>
<a class="anchor" name="9a86fb18ab749a7a18d0c59196959c5a"></a><!-- doxytag: member="pxtask::GpuDispatcher::launchCopyKernel" ref="9a86fb18ab749a7a18d0c59196959c5a" args="(GpuCopyDesc *desc, PxU32 count, CUstream stream)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::launchCopyKernel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpxtask_1_1GpuCopyDesc.html">GpuCopyDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g07326f81f9e8f494487f0ff1e50c0d17">PxU32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PxGpuDispatcher_8h.html#b946c7f02e09efd788a204718015d88a">CUstream</a>&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Launch a copy kernel with arbitrary number of copy commands. 
<p>
This method is intended to be called from Kernel GpuTasks, but it can function outside of that context as well.<p>
If count is 1, the descriptor is passed to the kernel as arguments, so it may be declared on the stack.<p>
If count is greater than 1, the kernel will read the descriptors out of host memory. Because of this, the descriptor array must be located in page locked (pinned) memory. The provided descriptors may be modified by this method (converting host pointers to their GPU mapped equivalents) and should be considered *owned* by CUDA until the current batch of work has completed, so descriptor arrays should not be freed or modified until you have received a completion notification.<p>
If your GPU does not support mapping of page locked memory (SM&gt;=1.1), this function degrades to calling CUDA copy methods. 
</div>
</div><p>
<a class="anchor" name="df462801561f6cf3777d6a17190de281"></a><!-- doxytag: member="pxtask::GpuDispatcher::registerKernelNames" ref="df462801561f6cf3777d6a17190de281" args="(const char **, PxU16 count)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__foundation.html#g1062e3989bd862873cdf0d4f7286d11d">PxU16</a> pxtask::GpuDispatcher::registerKernelNames           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__foundation.html#g1062e3989bd862873cdf0d4f7286d11d">PxU16</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register kernel names with PlatformAnalyzer. 
<p>
The returned PxU16 must be stored and used as a base offset for the ID passed to the KERNEL_START|STOP_EVENT macros. 
</div>
</div><p>
<a class="anchor" name="b2480c847e804d4446d0ea38c03b90c7"></a><!-- doxytag: member="pxtask::GpuDispatcher::startGroup" ref="b2480c847e804d4446d0ea38c03b90c7" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::startGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Record the start of a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> batch submission. 
<p>
A <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> calls this function to notify the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> that one or more GpuTasks are about to be submitted for execution. The <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will not read the incoming task queue until it receives one <a class="el" href="classpxtask_1_1GpuDispatcher.html#fe2ac7f661b8cb56bb00a780953a493a" title="Record the end of a GpuTask batch submission.">finishGroup()</a> call for each <a class="el" href="classpxtask_1_1GpuDispatcher.html#b2480c847e804d4446d0ea38c03b90c7" title="Record the start of a GpuTask batch submission.">startGroup()</a> call. This is to ensure as many GpuTasks as possible are executed together as a group, generating optimal parallelism on the GPU. 
</div>
</div><p>
<a class="anchor" name="66cc06a77ed990c09572908dbc5853f4"></a><!-- doxytag: member="pxtask::GpuDispatcher::startSimulation" ref="66cc06a77ed990c09572908dbc5853f4" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::startSimulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Record the start of a simulation step. 
<p>
A <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> calls this function to record the beginning of a simulation step. The <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> uses this notification to initialize the profiler state. 
</div>
</div><p>
<a class="anchor" name="90c4936cf7a9eb23be1b0d39dd017c4b"></a><!-- doxytag: member="pxtask::GpuDispatcher::stopSimulation" ref="90c4936cf7a9eb23be1b0d39dd017c4b" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::stopSimulation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Record the end of a simulation frame. 
<p>
A <a class="el" href="classpxtask_1_1TaskManager.html" title="The TaskManager interface.">TaskManager</a> calls this function to record the completion of its dependency graph. If profiling is enabled, the <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will trigger the retrieval of profiling data from the GPU at this point. 
</div>
</div><p>
<a class="anchor" name="aa55ad675f276a738695f3069815fab3"></a><!-- doxytag: member="pxtask::GpuDispatcher::submitTask" ref="aa55ad675f276a738695f3069815fab3" args="(Task &amp;task)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void pxtask::GpuDispatcher::submitTask           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpxtask_1_1Task.html">Task</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>task</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Submit a <a class="el" href="classpxtask_1_1GpuTask.html" title="Task implementation for launching CUDA work.">GpuTask</a> for execution. 
<p>
Submitted tasks are pushed onto an incoming queue. The <a class="el" href="classpxtask_1_1GpuDispatcher.html" title="A GpuTask dispatcher.">GpuDispatcher</a> will take the contents of this queue every time the pending group count reaches 0 and run the group of submitted GpuTasks as an interleaved group. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="PxGpuDispatcher_8h-source.html">PxGpuDispatcher.h</a></ul>
</div>

<hr style="width: 100%; height: 2px;"><br>
Copyright &copy; 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved. <a href="http://www.nvidia.com ">www.nvidia.com</a>
</body>
</html>
