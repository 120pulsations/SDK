

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Shapes and Geometries &mdash; NVIDIA PhysX SDK Documentation</title>
    <link rel="stylesheet" href="../_static/nvidia.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="NVIDIA PhysX SDK Documentation" href="../index.html" />
    <link rel="up" title="User&#39;s Guide" href="Index.html" />
    <link rel="next" title="Joints" href="Joints.html" />
    <link rel="prev" title="Scenes, Materials, and Actors" href="ScenesAndActors.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Joints.html" title="Joints"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="ScenesAndActors.html" title="Scenes, Materials, and Actors"
             accesskey="P">previous</a> |</li>
        <li><a href="../Index.html">NVIDIA PhysX SDK Documentation</a> &raquo;</li>
          <li><a href="Index.html" accesskey="U">User's Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="shapes-and-geometries">
<span id="shapes"></span><h1>Shapes and Geometries<a class="headerlink" href="#shapes-and-geometries" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>Shapes<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Shapes describe the spatial extent and collision properties of actors. A PxShape is owned by the PxActor through which it was created, and is released along with the actor. Each shape contains a PxGeometry object and a reference to a PxMaterial, which must both be specified upon creation. A shape may also have a transform relative to its parent actor. To create an actor with several shapes (sometimes referred to as a <em>compound</em>), just call PxRigidActor::createShape() several times.  There are no persistence requirements on the PxGeometry instance that is passed as a function argument in PxRigidActor::createShape().  The PhysX SDK takes a copy of the PxGeometry object rather than maintaining a reference to it.</p>
<p>There are some restrictions on the geometry types that may be specified for a shape, depending on the type of the parent actor.  Actors of type PxRigidStatic may have any kind of supported shape; that is, sphere, capsule, box, convex mesh, triangle mesh, plane or heightfield.  The shapes permitted for actors of type PxRigidDynamic depends on whether or not the actor is kinematic.  PxRigidDynamic actors that have been set up as kinematic may be given any of the supported shapes, just as with PxRigidStatic actors.  Dynamic actors, on the other hand, will not accept heightfields or triangle meshes or planes.  Actors of type PxArticulationLink have the same restrictions as non-kinematic PxRigidDynamic instances in that they are also forbidden to accept heightfields and triangle meshes and planes.  To complete the discussion it is worth noting that actors of type PxCloth, PxParticleFluid and PxParticleSystem do not accept shapes at all because their collison is handled by systems special to these actor types.</p>
<p>The PhysX SDK supports contacts between all possible combinations of shape pair except for combinations where both shapes are a plane or a heightfield or a triangle mesh.  The collision of two meshes, for example, is not supported. Similarly, collision between a plane and a heightfield or between two heightfields remains unsupported by the sdk.</p>
</div>
<div class="section" id="simulation-shapes-and-scene-query-shapes">
<h2>Simulation Shapes and Scene Query Shapes<a class="headerlink" href="#simulation-shapes-and-scene-query-shapes" title="Permalink to this headline">¶</a></h2>
<p>PxShape instances are configured by default to participate in the intersection tests that determine the contacting features of shape pairs.  They are also configured by default to participate in scene query tests.  It is possible to configure PxShape instances to participate or not in both types of test.  This can be done before or after the shape's actor has been added to the scene.</p>
<p>The following pseudo-code configures a PxShape instance so that it no longer participates in shape pair intersection tests:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">disableShapeInShapePairIntersectionTests</span><span class="p">(</span><span class="n">PxShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">shape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A PxShape instance can be configured to participate in shape pair intersection tests as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">enableShapeInShapePairIntersectionTests</span><span class="p">(</span><span class="n">PxShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">shape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To disable a PxShape instance from scene query tests:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">disableShapeInSceneQueryTests</span><span class="p">(</span><span class="n">PxShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">shape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSCENE_QUERY_SHAPE</span><span class="p">,</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, a PxShape instance can be re-enabled in scene query tests:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">enableShapeInSceneQueryTests</span><span class="p">(</span><span class="n">PxShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">shape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSCENE_QUERY_SHAPE</span><span class="p">,</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="trigger-shapes">
<h2>Trigger Shapes<a class="headerlink" href="#trigger-shapes" title="Permalink to this headline">¶</a></h2>
<p>PxShape instances can be configured as trigger shapes.  Trigger shapes play no part in the simulation of the scene (though they can be configured to participate in scene queries).  Instead, their role is to report that there has been an overlap with another shape.  This does not involve generating the contact features of the intersection.  As a result, contact reports are not available for trigger shapes.  A further point to note is that because trigger points play no part in the simulation it makes no sense for the eSIMULATION_SHAPE and eTRIGGER_SHAPE flags to be simultaneously raised.  To avoid any ambiguity the sdk will act to prevent these flags being simultaneously raised; that is, if the eSIMULATION_SHAPE(eTRIGGER_SHAPE) flag is raised then attempts to raise the eTRIGGER_SHAPE(eSIMULATION_SHAPE) flag will be rejected.  When this occurs an error is passed to the error stream.</p>
<p>Trigger shapes have been used in SampleSubmarine to determine if the submarine has reached the treasure.  In the following code the PxActor representing the treasure has its solitary shape configured as a trigger shapes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxShape</span><span class="o">*</span> <span class="n">treasureShape</span><span class="p">;</span>
<span class="n">gTreasureActor</span><span class="o">-&gt;</span><span class="n">getShapes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">treasureShape</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">treasureShape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="n">treasureShape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eTRIGGER_SHAPE</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The overlaps with trigger shapes are reported in SampleSubmarine through the implementation of PxSimulationEventCallback::onTrigger in the PxSampleSubmarine class, a sub-class of PxSimulationEventCallback:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">SampleSubmarine</span><span class="o">::</span><span class="n">onTrigger</span><span class="p">(</span><span class="n">PxTriggerPair</span><span class="o">*</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">PxU32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ignore pairs when shapes have been deleted</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PxTriggerPairFlag</span><span class="o">::</span><span class="n">eDELETED_SHAPE_TRIGGER</span> <span class="o">|</span> <span class="n">PxTriggerPairFlag</span><span class="o">::</span><span class="n">eDELETED_SHAPE_OTHER</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="k">if</span><span class="p">((</span><span class="o">&amp;</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">otherShape</span><span class="o">-&gt;</span><span class="n">getActor</span><span class="p">()</span> <span class="o">==</span> <span class="n">mSubmarineActor</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">triggerShape</span><span class="o">-&gt;</span><span class="n">getActor</span><span class="p">()</span> <span class="o">==</span> <span class="n">gTreasureActor</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">gTreasureFound</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code above iterates through all pairs of overlapping shapes that involve a trigger shape.  If it is found that the treasure has been touched by the submarine then the flag gTreasureFound is set true.</p>
</div>
<div class="section" id="kinematic-triangle-meshes-planes-heighfields">
<h2>Kinematic triangle meshes (planes, heighfields)<a class="headerlink" href="#kinematic-triangle-meshes-planes-heighfields" title="Permalink to this headline">¶</a></h2>
<p>It is possible to create a kinematic PxRigidDynamic which can have a triangle mesh (plane, heighfield) shape. If this shape has a simulation shape flag, this actor must stay kinematic. If you change the flag to not simulated, you can switch even the kinematic flag.</p>
<p>To setup kinematic triangle mesh see following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">meshActor</span> <span class="o">=</span> <span class="n">getPhysics</span><span class="p">().</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="o">::</span><span class="n">createIdentity</span><span class="p">());</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">meshShape</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">meshActor</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">setRigidDynamicFlag</span><span class="p">(</span><span class="n">PxRigidDynamicFlag</span><span class="o">::</span><span class="n">eKINEMATIC</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        <span class="n">PxTriangleMeshGeometry</span> <span class="n">triGeom</span><span class="p">;</span>
        <span class="n">triGeom</span><span class="p">.</span><span class="n">triangleMesh</span> <span class="o">=</span> <span class="n">triangleMesh</span><span class="p">;</span>
        <span class="n">meshShape</span> <span class="o">=</span> <span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">triGeom</span><span class="p">,</span> <span class="n">defaultMaterial</span><span class="p">);</span>
        <span class="n">getScene</span><span class="p">().</span><span class="n">addActor</span><span class="p">(</span><span class="o">*</span><span class="n">meshActor</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To switch a kinematic triangle mesh actor to a dynamic actor:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">meshActor</span> <span class="o">=</span> <span class="n">getPhysics</span><span class="p">().</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="o">::</span><span class="n">createIdentity</span><span class="p">());</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">meshShape</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">meshActor</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">setRigidDynamicFlag</span><span class="p">(</span><span class="n">PxRigidDynamicFlag</span><span class="o">::</span><span class="n">eKINEMATIC</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        <span class="n">PxTriangleMeshGeometry</span> <span class="n">triGeom</span><span class="p">;</span>
        <span class="n">triGeom</span><span class="p">.</span><span class="n">triangleMesh</span> <span class="o">=</span> <span class="n">triangleMesh</span><span class="p">;</span>
        <span class="n">meshShape</span> <span class="o">=</span> <span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">triGeom</span><span class="p">,</span> <span class="n">defaultMaterial</span><span class="p">);</span>
        <span class="n">getScene</span><span class="p">().</span><span class="n">addActor</span><span class="p">(</span><span class="o">*</span><span class="n">meshActor</span><span class="p">);</span>

        <span class="n">PxConvexMeshGeometry</span> <span class="n">convexGeom</span> <span class="o">=</span> <span class="n">PxConvexMeshGeometry</span><span class="p">(</span><span class="n">convexBox</span><span class="p">);</span>
        <span class="n">convexShape</span> <span class="o">=</span> <span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">convexGeom</span><span class="p">,</span><span class="n">defaultMaterial</span><span class="p">);</span>
        <span class="n">convexShape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// ... now switch to dynamic</span>

<span class="n">meshShape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="n">convexShape</span><span class="o">-&gt;</span><span class="n">setFlag</span><span class="p">(</span><span class="n">PxShapeFlag</span><span class="o">::</span><span class="n">eSIMULATION_SHAPE</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="n">meshActor</span><span class="o">-&gt;</span><span class="n">setRigidDynamicFlag</span><span class="p">(</span><span class="n">PxRigidDynamicFlag</span><span class="o">::</span><span class="n">eKINEMATIC</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="geometries">
<h2>Geometries<a class="headerlink" href="#geometries" title="Permalink to this headline">¶</a></h2>
<p>The PxGeometry class defines a volume or surface with a fixed position and orientation. Typically, as when used in a shape or scene query, a transform specifies the frame in which the geometry is interpreted.</p>
<p>For bulk objects, such as a convex mesh, triangle mesh or height field, PhysX allows multiple PxGeometry objects to refer to a single mesh or height field, and supports per-instance scaling.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Each mesh (or height field) is reference counted, and the reference count refers to the number of PxShapes whose geometries reference the mesh, rather than the number of PxGeometry objects.</p>
</div>
<div class="section" id="spheres">
<h3>Spheres<a class="headerlink" href="#spheres" title="Permalink to this headline">¶</a></h3>
<p>A PxSphereGeometry is specified by one attribute, its radius, and is centered at the origin.</p>
</div>
<div class="section" id="capsules">
<h3>Capsules<a class="headerlink" href="#capsules" title="Permalink to this headline">¶</a></h3>
<p>A PxCapsuleGeometry is centered at the origin. It is specified by a radius and a half-height value by which its axis extends along the positive and negative X-axis.</p>
<p>To create a dynamic actor whose geometry is a capsule standing upright, the shape needs a relative transform that rotates it around the Z-axis by a quarter-circle. By doing this, the capsule will extend along the Y-axis of the actor instead of the X-axis. Setting up the shape and actor is otherwise the same as for the sphere:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">aCapsuleActor</span> <span class="o">=</span> <span class="n">thePhysics</span><span class="o">-&gt;</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">PxTransform</span><span class="p">(</span><span class="n">position</span><span class="p">));</span>
<span class="n">PxTransform</span> <span class="n">relativePose</span><span class="p">(</span><span class="n">PxQuat</span><span class="p">(</span><span class="n">PxHalfPi</span><span class="p">,</span> <span class="n">PxVec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)));</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">aCapsuleShape</span> <span class="o">=</span> <span class="n">aCapsuleActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">PxCapsuleGeometry</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">halfHeight</span><span class="p">),</span> <span class="n">aMaterial</span><span class="p">,</span> <span class="n">relativePose</span><span class="p">);</span>
<span class="n">PxRigidBodyExt</span><span class="o">::</span><span class="n">updateMassAndInertia</span><span class="p">(</span><span class="o">*</span><span class="n">aCapsuleActor</span><span class="p">,</span> <span class="n">capsuleDensity</span><span class="p">);</span>
<span class="n">aScene</span><span class="o">-&gt;</span><span class="n">addActor</span><span class="p">(</span><span class="n">aCapsuleActor</span><span class="p">);</span>
</pre></div>
</div>
<p>The function PxTransformFromSegment() converts from a line segment defining the capsule axis to a transform and halfheight.</p>
</div>
<div class="section" id="boxes">
<h3>Boxes<a class="headerlink" href="#boxes" title="Permalink to this headline">¶</a></h3>
<p>A PxBoxGeometry has three attributes, the three extents halved:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxShape</span><span class="o">*</span> <span class="n">aBoxShape</span> <span class="o">=</span> <span class="n">aBoxActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">PxBoxGeometry</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">aMaterial</span><span class="p">);</span>
</pre></div>
</div>
<p>Where a, b and c are the side lengths of the resulting box.</p>
</div>
<div class="section" id="planes">
<h3>Planes<a class="headerlink" href="#planes" title="Permalink to this headline">¶</a></h3>
<p>Planes divide space into &quot;above&quot; and &quot;below&quot; them. Everything &quot;below&quot; the plane will collide with it.</p>
<p>The Plane lies on the YZ plane with &quot;above&quot; pointing towards positive X. To convert from a plane equation to an equivalent transform, use the function PxTransformFromPlaneEquation(). PxPlaneEquationFromTransform() performs the reverse conversion.</p>
<p>A PxPlaneGeometry has no attributes, since the shape's pose entirely defines the plane's collision volume.</p>
<p>Shapes with a PxPlaneGeometry may only be created for static actors.</p>
</div>
<div class="section" id="convex-meshes">
<h3>Convex Meshes<a class="headerlink" href="#convex-meshes" title="Permalink to this headline">¶</a></h3>
<p>Creating a PxConvexMesh requires cooking. It is assumed here that the cooking library has already been initialized (see <a class="reference internal" href="Startup.html#startup"><em>Startup and Shutdown</em></a>.)</p>
<p>The following steps explain how to create a simple square pyramid.</p>
<p>First, define the vertices of the convex object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="n">PxVec3</span> <span class="n">convexVerts</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">PxVec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">PxVec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">PxVec3</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">PxVec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">PxVec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)};</span>
</pre></div>
</div>
<p>Then construct a description of the convex data layout:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxConvexMeshDesc</span> <span class="n">convexDesc</span><span class="p">;</span>
<span class="n">convexDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">count</span>     <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">convexDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">stride</span>    <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">);</span>
<span class="n">convexDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">data</span>      <span class="o">=</span> <span class="n">convexVerts</span><span class="p">;</span>
<span class="n">convexDesc</span><span class="p">.</span><span class="n">flags</span>            <span class="o">=</span> <span class="n">PxConvexFlag</span><span class="o">::</span><span class="n">eCOMPUTE_CONVEX</span><span class="p">;</span>
</pre></div>
</div>
<p>Now use the cooking library to construct a PxConvexMesh:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxToolkit</span><span class="o">::</span><span class="n">MemoryOutputStream</span> <span class="n">buf</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">cooking</span><span class="p">.</span><span class="n">cookConvexMesh</span><span class="p">(</span><span class="n">convexDesc</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">PxToolkit</span><span class="o">::</span><span class="n">MemoryInputData</span> <span class="n">input</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">getData</span><span class="p">(),</span> <span class="n">buf</span><span class="p">.</span><span class="n">getSize</span><span class="p">());</span>
<span class="n">PxConvexMesh</span><span class="o">*</span> <span class="n">convexMesh</span> <span class="o">=</span> <span class="n">thePhysics</span><span class="o">-&gt;</span><span class="n">createConvexMesh</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, create a shape using a PxConvexMeshGeometry which instances the mesh:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxShape</span><span class="o">*</span> <span class="n">aConvexShape</span> <span class="o">=</span> <span class="n">aConvexActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">PxConvexMeshGeometry</span><span class="p">(</span><span class="n">convexMesh</span><span class="p">),</span> <span class="n">aMaterial</span><span class="p">);</span>
</pre></div>
</div>
<p>A user can optionally provide a per-instance PxMeshScale in the PxConvexMeshGeometry. The default scale is the identity.</p>
<p>The default convex hull generation code is selected when using the PxConvexFlag::eCOMPUTE_CONVEX flag alone. The algorithm tries to create a convex hull as close to the source vertices as possible. This can sometimes fail when the source data is geometrically challenging, for example if it contains a lot of vertices close to each-other, etc. An error is reported to the error stream in case of failure. If this happens, the best option is to switch to an alternative hull generation routine using the PxConvexFlag::eCOMPUTE_CONVEX|PxConvexFlag::eINFLATE_CONVEX flags, both together. This allows the code to inflate the source data by a margin - defined by PxCookingParams::skinWidth -, which gives the code more freedom to correct the problematic geometry. Alternatively it is possible for users to provide an already created hull, by filling up both PxConvexMeshDesc::points and PxConvexMeshDesc::triangles, and omitting the PxConvexFlag::eCOMPUTE_CONVEX flag. Some checks are still performed to make sure the provided hull is valid, so the cooking call can still fail at that point.</p>
<p>In any case the number of vertices and the number of convex polygons in the final cooked hull are both limited to 256.</p>
</div>
<div class="section" id="height-fields">
<h3>Height Fields<a class="headerlink" href="#height-fields" title="Permalink to this headline">¶</a></h3>
<p>As the name suggests, terrains can be described by just the height values on a regular, rectangular sampling grid:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxHeightFieldSample</span><span class="o">*</span> <span class="n">samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">PxHeightFieldSample</span><span class="o">*</span><span class="p">)</span><span class="n">alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PxHeightFieldSample</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">numRows</span><span class="o">*</span><span class="n">numCols</span><span class="p">));</span>
</pre></div>
</div>
<p>Each sample consists of a 16 bit integer height value, two materials (for the two triangles in the samples rectangle) and a tesselation flag. The flag and materials refer to the cell below and to the right of the sample point, and indicate along which diagonal to split it into triangles, and the materials of those triangles.  A special predefined material <tt class="docutils literal"><span class="pre">PxHeightFieldMaterial::eHOLE</span></tt> specifies a hole in the height field. See the reference documentation for PxHeightFieldSample for more details.</p>
<p>To tell the system the number of sampled heights in each direction, use a descriptor to instantiate a PxHeightField object:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxHeightFieldDesc</span> <span class="n">hfDesc</span><span class="p">;</span>
<span class="n">hfDesc</span><span class="p">.</span><span class="n">format</span>             <span class="o">=</span> <span class="n">PxHeightFieldFormat</span><span class="o">::</span><span class="n">eS16_TM</span><span class="p">;</span>
<span class="n">hfDesc</span><span class="p">.</span><span class="n">nbColumns</span>          <span class="o">=</span> <span class="n">numCols</span><span class="p">;</span>
<span class="n">hfDesc</span><span class="p">.</span><span class="n">nbRows</span>             <span class="o">=</span> <span class="n">numRows</span><span class="p">;</span>
<span class="n">hfDesc</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">data</span>       <span class="o">=</span> <span class="n">samples</span><span class="p">;</span>
<span class="n">hfDesc</span><span class="p">.</span><span class="n">samples</span><span class="p">.</span><span class="n">stride</span>     <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PxHeightFieldSample</span><span class="p">);</span>

<span class="n">PxHeightField</span><span class="o">*</span> <span class="n">aHeightField</span> <span class="o">=</span> <span class="n">thePhysics</span><span class="o">-&gt;</span><span class="n">createHeightField</span><span class="p">(</span><span class="n">hfDesc</span><span class="p">);</span>
</pre></div>
</div>
<p>Now create a PxHeightFieldGeometry and a shape:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxHeightFieldGeometry</span> <span class="n">hfGeom</span><span class="p">(</span><span class="n">aHeightField</span><span class="p">,</span> <span class="n">PxMeshGeometryFlags</span><span class="p">(),</span> <span class="n">heightScale</span><span class="p">,</span> <span class="n">rowScale</span><span class="p">,</span> <span class="n">colScale</span><span class="p">);</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">aHeightFieldShape</span> <span class="o">=</span> <span class="n">aHeightFieldActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">hfGeom</span><span class="p">,</span> <span class="n">aMaterialArray</span><span class="p">,</span> <span class="n">nbMaterials</span><span class="p">);</span>
</pre></div>
</div>
<p>The row and column scales tell the system how far apart the sampled points lie in the associated direction. The height scale scales the integer height values to a floating point range.</p>
<p>The variant of createShape() used here specifies an array of materials for the height field, which will be indexed by the material indices of each cell to resolve collisions with that cell. The single-material variant of createShape() may be used instead, but the height field material indices must all be a single value or the special value <tt class="docutils literal"><span class="pre">eHOLE</span></tt>.</p>
</div>
<div class="section" id="triangle-meshes">
<h3>Triangle Meshes<a class="headerlink" href="#triangle-meshes" title="Permalink to this headline">¶</a></h3>
<p>Creating a PxTriangleMesh requires cooking. It is assumed here that the cooking library has already been initialized (see <a class="reference internal" href="Startup.html#startup"><em>Startup and Shutdown</em></a>.)</p>
<p>Like graphical triangle meshes, a collision triangle mesh consists of a collection of vertices and the triangle indices. Triangle mesh creation requires use of the cooking library:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxTriangleMeshDesc</span> <span class="n">meshDesc</span><span class="p">;</span>
<span class="n">meshDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">count</span>           <span class="o">=</span> <span class="n">nbVerts</span><span class="p">;</span>
<span class="n">meshDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">stride</span>          <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">);</span>
<span class="n">meshDesc</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">data</span>            <span class="o">=</span> <span class="n">verts</span><span class="p">;</span>

<span class="n">meshDesc</span><span class="p">.</span><span class="n">triangles</span><span class="p">.</span><span class="n">count</span>        <span class="o">=</span> <span class="n">triCount</span><span class="p">;</span>
<span class="n">meshDesc</span><span class="p">.</span><span class="n">triangles</span><span class="p">.</span><span class="n">stride</span>       <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PxU32</span><span class="p">);</span>
<span class="n">meshDesc</span><span class="p">.</span><span class="n">triangles</span><span class="p">.</span><span class="n">data</span>         <span class="o">=</span> <span class="n">indices32</span><span class="p">;</span>

<span class="n">PxToolkit</span><span class="o">::</span><span class="n">MemoryOutputStream</span> <span class="n">writeBuffer</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="n">cooking</span><span class="p">.</span><span class="n">cookTriangleMesh</span><span class="p">(</span><span class="n">meshDesc</span><span class="p">,</span> <span class="n">writeBuffer</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">PxToolkit</span><span class="o">::</span><span class="n">MemoryInputData</span> <span class="n">readBuffer</span><span class="p">(</span><span class="n">writeBuffer</span><span class="p">.</span><span class="n">getData</span><span class="p">(),</span> <span class="n">writeBuffer</span><span class="p">.</span><span class="n">getSize</span><span class="p">());</span>
<span class="k">return</span> <span class="n">physics</span><span class="p">.</span><span class="n">createTriangleMesh</span><span class="p">(</span><span class="n">readBuffer</span><span class="p">);</span>
</pre></div>
</div>
<p>Indices can be 16 or 32 bit. The strides used here assume that vertices and indices are arrays of PxVec3s and 32bit integers respectively with no gaps in the data layout.</p>
<p>Shapes with triangle mesh geometries may only be created for static and kinematic actors:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxShape</span><span class="o">*</span> <span class="n">aTriMeshShape</span> <span class="o">=</span> <span class="n">aTriMeshActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">PxTriangleMeshGeometry</span><span class="p">(</span><span class="n">triangleMesh</span><span class="p">),</span> <span class="n">aMaterial</span><span class="p">);</span>
</pre></div>
</div>
<p>The user can optionally specify a per-instance PxMeshScale in the PxTriangleMeshGeometry. The default scale is the identity.</p>
<p>Like height fields, triangle meshes support per-triangle material indices. To use per-triangle materials for a mesh, provide the indices to the cooking library in the mesh descriptor, and use the multi-material form of createShape().</p>
</div>
</div>
<div class="section" id="mesh-scaling">
<h2>Mesh Scaling<a class="headerlink" href="#mesh-scaling" title="Permalink to this headline">¶</a></h2>
<p>A shared PxTriangleMesh or PxConvexMesh may be stretched or compressed when it is instanced by a geometry. This allows multiple instancing of the same mesh with different scale factors applied.  Scaling is specified with the PxMeshScale class, which defines scale factors to be applied along 3 orthogonal axes. A factor greater than 1.0 results in stretching, while a factor less than 1.0 results in compression. The directions of the axes are governed by a quaternion, and specified in the local frame of the shape.</p>
<p>The following code creates a shape with a PxTriangleMesh scaled by a factor of x along the x-axis, y along the y-axis, and z along the z-axis:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// created earlier</span>
<span class="n">PxRigidActor</span><span class="o">*</span> <span class="n">myActor</span><span class="p">;</span>
<span class="n">PxTriangleMesh</span><span class="o">*</span> <span class="n">myTriMesh</span><span class="p">;</span>
<span class="n">PxMaterial</span><span class="o">*</span> <span class="n">myMaterial</span><span class="p">;</span>

<span class="c1">// create a shape instancing a triangle mesh at the given scale</span>
<span class="n">PxMeshScale</span> <span class="n">scale</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">PxQuat</span><span class="o">::</span><span class="n">createIdentity</span><span class="p">());</span>
<span class="n">PxTriangleMeshGeometry</span> <span class="n">geom</span><span class="p">(</span><span class="n">myTriMesh</span><span class="p">,</span><span class="n">scale</span><span class="p">);</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">myTriMeshShape</span> <span class="o">=</span> <span class="n">myActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="o">*</span><span class="n">myMaterial</span><span class="p">);</span>
</pre></div>
</div>
<p>Convex meshes are scaled using the PxMeshScale class in a similar manner.  The following code creates a shape with a PxConvexMesh scaled by a factor of x along (sqrt(1/2), 1.0, -sqrt(1/2)), by a factor of y along (0,1,0) and a by a factor of z along (sqrt(1/2), 1.0, sqrt(1/2)):</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxMeshScale</span> <span class="n">scale</span><span class="p">(</span><span class="n">PxVec3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">PxQuat</span> <span class="n">quat</span><span class="p">(</span><span class="n">PxPi</span><span class="o">*</span><span class="mf">0.25f</span><span class="p">,</span> <span class="n">PxVec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)));</span>
<span class="n">PxConvexMeshGeometry</span> <span class="n">geom</span><span class="p">(</span><span class="n">myTriMesh</span><span class="p">,</span><span class="n">scale</span><span class="p">);</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">myConvexMeshShape</span> <span class="o">=</span> <span class="n">myActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span><span class="o">*</span><span class="n">myMaterial</span><span class="p">);</span>
</pre></div>
</div>
<p>Height fields can also be scaled, using scale factors stored in PxHeightFieldGeometry. In this case the scale is assumed to be along the axes of the rows, columns and height directions of the height field. The scaling of is demonstrated in SampleNorthPole in SampleNorthPoleBuilder.cpp:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxHeightFieldGeometry</span> <span class="n">hfGeom</span><span class="p">(</span><span class="n">heightField</span><span class="p">,</span> <span class="n">PxMeshGeometryFlags</span><span class="p">(),</span> <span class="n">heightScale</span><span class="p">,</span> <span class="n">hfScale</span><span class="p">,</span> <span class="n">hfScale</span><span class="p">);</span>
<span class="n">PxShape</span><span class="o">*</span> <span class="n">hfShape</span> <span class="o">=</span> <span class="n">hfActor</span><span class="o">-&gt;</span><span class="n">createShape</span><span class="p">(</span><span class="n">hfGeom</span><span class="p">,</span> <span class="n">getDefaultMaterial</span><span class="p">());</span>
</pre></div>
</div>
<p>In this example, the coordinates along the x and z axes are scaled by hfScale, while the sample heights are scaled by heightScale.</p>
</div>
<div class="section" id="pxgeometryholder">
<h2>PxGeometryHolder<a class="headerlink" href="#pxgeometryholder" title="Permalink to this headline">¶</a></h2>
<p>When a geometry is provided for a shape, either on creation or with <em>PxShape::setGeometry()</em>, the geometry is copied into the SDK's internal structures. If you know the type of a shape's geometry you may retrieve it directly:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxBoxGeometry</span> <span class="n">boxGeom</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getBoxGeometry</span><span class="p">(</span><span class="n">geometry</span><span class="p">);</span>
</pre></div>
</div>
<p>The status return code is set to false if the shape's geometry is not of the expected type.</p>
<p>However, it is often convenient to retrieve a geometry object from a shape without first knowing its type - for example, to call a function which takes a PxGeometry reference as an argument.</p>
<p>PxGeometryHolder is a union-like class that allows the return of a PxGeometry object by value, regardless of type. Its use is illustrated in the <em>createRenderObjectFromShape()</em> function in PhysXSample.cpp:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxGeometryHolder</span> <span class="n">geom</span> <span class="o">=</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getGeometry</span><span class="p">();</span>

<span class="k">switch</span><span class="p">(</span><span class="n">geom</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span>
<span class="p">{</span>
<span class="k">case</span> <span class="n">PxGeometryType</span><span class="o">::</span><span class="nl">eSPHERE:</span>
    <span class="n">shapeRenderActor</span> <span class="o">=</span> <span class="n">SAMPLE_NEW</span><span class="p">(</span><span class="n">RenderSphereActor</span><span class="p">)(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">geom</span><span class="p">.</span><span class="n">sphere</span><span class="p">().</span><span class="n">radius</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">PxGeometryType</span><span class="o">::</span><span class="nl">eCAPSULE:</span>
    <span class="n">shapeRenderActor</span> <span class="o">=</span> <span class="n">SAMPLE_NEW</span><span class="p">(</span><span class="n">RenderCapsuleActor</span><span class="p">)(</span><span class="n">renderer</span><span class="p">,</span> <span class="n">geom</span><span class="p">.</span><span class="n">capsule</span><span class="p">().</span><span class="n">radius</span><span class="p">,</span> <span class="n">geom</span><span class="p">.</span><span class="n">capsule</span><span class="p">().</span><span class="n">halfHeight</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The function <em>PxGeometryHolder::any()</em> returns a reference to a PxGeometry object. For example, to compare two shapes in a scene for overlap:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">testForOverlap</span><span class="p">(</span><span class="k">const</span> <span class="n">PxShape</span><span class="o">&amp;</span> <span class="n">s0</span><span class="p">,</span> <span class="k">const</span> <span class="n">PxShape</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">PxGeometryQuery</span><span class="o">::</span><span class="n">overlap</span><span class="p">(</span><span class="n">s0</span><span class="p">.</span><span class="n">getGeometry</span><span class="p">().</span><span class="n">any</span><span class="p">(),</span> <span class="n">PxShapeExt</span><span class="o">::</span><span class="n">getGlobalPose</span><span class="p">(</span><span class="n">s0</span><span class="p">),</span>
                                    <span class="n">s1</span><span class="p">.</span><span class="n">getGeometry</span><span class="p">().</span><span class="n">any</span><span class="p">(),</span> <span class="n">PxShapeExt</span><span class="o">::</span><span class="n">getGlobalPose</span><span class="p">(</span><span class="n">s1</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="detaching-shapes">
<h2>Detaching Shapes<a class="headerlink" href="#detaching-shapes" title="Permalink to this headline">¶</a></h2>
<p>In the North Pole Sample, some of the shapes detach on contact with a snowball. To request notification of this event, the sample sets a flag in the simulation filter function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">needsContactReport</span><span class="p">(</span><span class="n">filterData0</span><span class="p">,</span> <span class="n">filterData1</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">pairFlags</span> <span class="o">|=</span> <span class="n">PxPairFlag</span><span class="o">::</span><span class="n">eNOTIFY_TOUCH_FOUND</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When this flag is set for a pair, the initial collision of that pair will generate a callback through PxSimulationEventCallback::onContact().  The implementation of this callback in the sample simply records which detachable shapes were touched during simulation. needsContactReport() is a helper function which returns true if one of the shapes is detachable and the other is marked as a snowball. It determines this by testing the flags in each shape's simulationFilterData, which were set on shape creation using the setDetachable() and setSnowball() functions. Collision filtering is discussed in more detail in the <a class="reference internal" href="Callbacks.html#callbacks"><em>Callbacks and Customization</em></a> section.</p>
<p>After simulation, the sample iterates over the list of touched detachable shapes and detaches each one from its owning actor. Since a PxShape must belong to a PxActor, the sample creates a new actor, whose global pose is that of the original shape. The geometry and material for the new shape are retrieved from the original shape:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">newActor</span> <span class="o">=</span> <span class="n">mPhysics</span><span class="o">-&gt;</span><span class="n">createRigidDynamic</span><span class="p">(</span><span class="n">pose</span><span class="p">);</span>

<span class="n">PxMaterial</span><span class="o">*</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">shape</span><span class="o">-&gt;</span><span class="n">getMaterials</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mat</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">PxGeometryHolder</span> <span class="n">geometry</span> <span class="o">=</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">getGeometry</span><span class="p">();</span>
<span class="n">PxTransform</span> <span class="n">newActorPose</span> <span class="o">=</span> <span class="n">PxShapeExt</span><span class="o">::</span><span class="n">getGlobalPose</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">);</span>

<span class="n">PxRigidDynamic</span><span class="o">*</span> <span class="n">newActor</span> <span class="o">=</span> <span class="n">PxCreateDynamic</span><span class="p">(</span><span class="o">*</span><span class="n">mPhysics</span><span class="p">,</span> <span class="n">newActorPose</span><span class="p">,</span> <span class="n">geometry</span><span class="p">.</span><span class="n">any</span><span class="p">(),</span> <span class="o">*</span><span class="n">mat</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">shape</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="shape-vertex-and-triangle-queries">
<h2>Shape Vertex and Triangle Queries<a class="headerlink" href="#shape-vertex-and-triangle-queries" title="Permalink to this headline">¶</a></h2>
<p>Convex meshes, triangle meshes, and height fields can all be queried for vertex and  face data.  This is particularly useful, for example, when rendering the mesh of the convex shape. The function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RenderBaseActor</span><span class="o">*</span> <span class="n">PhysXSample</span><span class="o">::</span><span class="n">createRenderObjectFromShape</span><span class="p">(</span><span class="n">PxShape</span><span class="o">*</span> <span class="n">shape</span><span class="p">,</span> <span class="n">RenderMaterial</span><span class="o">*</span> <span class="n">material</span><span class="p">)</span>
</pre></div>
</div>
<p>in PhysXSample.cpp contains a switch statement with a case for each shape type, illustrating the steps required to query the vertices and faces.</p>
<p>It is possible to get information about triangle from a triangle mesh using the getTriangle function, You may also get the information about adjacency triangles for the triangle, for this you need to cook your triangle meshes with cooking parameter buildTriangleAdjacencies, otherwise the adjacency information is not created and stored.</p>
<div class="section" id="id2">
<h3>Convex Meshes<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>A convex mesh contains an array of vertices, an array of faces, and an index buffer which concatenates the vertex indices for each face. To unpack a convex mesh, the first step is to extract the shared convex mesh:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxConvexMesh</span><span class="o">*</span> <span class="n">convexMesh</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">convexMesh</span><span class="p">().</span><span class="n">convexMesh</span><span class="p">;</span>
</pre></div>
</div>
<p>Then obtain references to the vertex and index buffers:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxU32</span> <span class="n">nbVerts</span> <span class="o">=</span> <span class="n">convexMesh</span><span class="o">-&gt;</span><span class="n">getNbVertices</span><span class="p">();</span>
<span class="k">const</span> <span class="n">PxVec3</span><span class="o">*</span> <span class="n">convexVerts</span> <span class="o">=</span> <span class="n">convexMesh</span><span class="o">-&gt;</span><span class="n">getVertices</span><span class="p">();</span>
<span class="k">const</span> <span class="n">PxU8</span><span class="o">*</span> <span class="n">indexBuffer</span> <span class="o">=</span> <span class="n">convexMesh</span><span class="o">-&gt;</span><span class="n">getIndexBuffer</span><span class="p">();</span>
</pre></div>
</div>
<p>Now iterate over the array of faces to triangulate them:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxU32</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nbPolygons</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PxHullPolygon</span> <span class="n">face</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">status</span> <span class="o">=</span> <span class="n">convexMesh</span><span class="o">-&gt;</span><span class="n">getPolygonData</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">face</span><span class="p">);</span>
    <span class="n">PX_ASSERT</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">PxU8</span><span class="o">*</span> <span class="n">faceIndices</span> <span class="o">=</span> <span class="n">indexBuffer</span> <span class="o">+</span> <span class="n">face</span><span class="p">.</span><span class="n">mIndexBase</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">face</span><span class="p">.</span><span class="n">mNbVerts</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">convexVerts</span><span class="p">[</span><span class="n">faceIndices</span><span class="p">[</span><span class="n">j</span><span class="p">]];</span>
        <span class="n">normals</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PxVec3</span><span class="p">(</span><span class="n">face</span><span class="p">.</span><span class="n">mPlane</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">face</span><span class="p">.</span><span class="n">mPlane</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">face</span><span class="p">.</span><span class="n">mPlane</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">face</span><span class="p">.</span><span class="n">mNbVerts</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">triangles</span><span class="o">++</span> <span class="o">=</span> <span class="n">PxU16</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
        <span class="o">*</span><span class="n">triangles</span><span class="o">++</span> <span class="o">=</span> <span class="n">PxU16</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="p">);</span>
        <span class="o">*</span><span class="n">triangles</span><span class="o">++</span> <span class="o">=</span> <span class="n">PxU16</span><span class="p">(</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">offset</span> <span class="o">+=</span> <span class="n">face</span><span class="p">.</span><span class="n">mNbVerts</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Observe that the vertex indices of the polygon begin at indexBuffer[face.mIndexBase], and the count of vertices is given by face.mNbVerts.</p>
</div>
<div class="section" id="id3">
<h3>Triangle Meshes<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Triangle meshes contain arrays of vertices and index triplets which define the triangles by indexing into the vertex buffer. The arrays can be accessed directly from the shared triangle mesh:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxTriangleMesh</span><span class="o">*</span> <span class="n">tm</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">triangleMesh</span><span class="p">().</span><span class="n">triangleMesh</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbVerts</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">getNbVertices</span><span class="p">();</span>
<span class="k">const</span> <span class="n">PxVec3</span><span class="o">*</span> <span class="n">verts</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">getVertices</span><span class="p">();</span>
<span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbTris</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">getNbTriangles</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">tris</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">getTriangles</span><span class="p">();</span>
</pre></div>
</div>
<p>The indices may be stored with either 16-bit or 32-bit values, specified when the mesh was originally cooked. To determine the storage format at runtime, use the API call:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">bool</span> <span class="n">has16bitIndices</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">has16BitTriangleIndices</span><span class="p">();</span>
</pre></div>
</div>
<p>Assuming that the triangle indices are stored in 16-bit format, find the jth vertex of the ith triangle by:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">PxU16</span><span class="o">*</span> <span class="n">triIndices</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">PxU16</span><span class="o">*</span><span class="p">)</span><span class="n">tris</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PxU16</span> <span class="n">index</span> <span class="o">=</span> <span class="n">triIndices</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span><span class="n">j</span><span class="p">];</span>
</pre></div>
</div>
<p>The corresponding vertex is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">PxVec3</span><span class="o">&amp;</span> <span class="n">vertex</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>Height Fields<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The storage of height field data is platform-dependent, and therefore direct access to the height field samples is not provided. Instead, calls are provided to render the samples to a user-supplied buffer.</p>
<p>Again, the first step is to retrieve the geometry for the height field:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">PxHeightFieldGeometry</span><span class="o">&amp;</span> <span class="n">geometry</span> <span class="o">=</span> <span class="n">geom</span><span class="p">.</span><span class="n">heightField</span><span class="p">();</span>
</pre></div>
</div>
<p>The height field has three scaling parameters:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">PxReal</span>    <span class="n">rs</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">.</span><span class="n">rowScale</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PxReal</span>    <span class="n">hs</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">.</span><span class="n">heightScale</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PxReal</span>    <span class="n">cs</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">.</span><span class="n">columnScale</span><span class="p">;</span>
</pre></div>
</div>
<p>And a shared data structure, which stores the row and column count:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxHeightField</span><span class="o">*</span>  <span class="n">hf</span> <span class="o">=</span> <span class="n">geometry</span><span class="p">.</span><span class="n">heightField</span><span class="p">;</span>
<span class="k">const</span> <span class="n">PxU32</span>     <span class="n">nbCols</span> <span class="o">=</span> <span class="n">hf</span><span class="o">-&gt;</span><span class="n">getNbColumns</span><span class="p">();</span>
<span class="k">const</span> <span class="n">PxU32</span>     <span class="n">nbRows</span> <span class="o">=</span> <span class="n">hf</span><span class="o">-&gt;</span><span class="n">getNbRows</span><span class="p">();</span>
</pre></div>
</div>
<p>To render the height field, first extract the samples to an array:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">PxU32</span> <span class="n">nbVerts</span> <span class="o">=</span> <span class="n">nbRows</span> <span class="o">*</span> <span class="n">nbCols</span><span class="p">;</span>
<span class="n">PxHeightFieldSample</span><span class="o">*</span> <span class="n">sampleBuffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PxHeightFieldSample</span><span class="p">[</span><span class="n">nbVerts</span><span class="p">];</span>
<span class="n">hf</span><span class="o">-&gt;</span><span class="n">saveCells</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">,</span> <span class="n">nbVerts</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PxHeightFieldSample</span><span class="p">));</span>
</pre></div>
</div>
<p>The samples are stored in row-major order; that is, row0 is stored first, followed by row1, then row2, and so on. Thus the sample corresponding to the ith row and the jth column is i*nbCols + j.</p>
<p>Evaluate the scaled vertices of the height field as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">PxVec3</span><span class="o">*</span> <span class="n">vertices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PxVec3</span><span class="p">[</span><span class="n">nbVerts</span><span class="p">];</span>
<span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbRows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="n">PxU32</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbCols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vertices</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">nbCols</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">PxVec3</span><span class="p">(</span><span class="n">PxReal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">rs</span><span class="p">,</span> <span class="n">PxReal</span><span class="p">(</span><span class="n">sampleBuffer</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">nbCols</span><span class="p">)].</span><span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="n">hs</span><span class="p">,</span> <span class="n">PxReal</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">cs</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then tessellate the field from the samples as required.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../Index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Shapes and Geometries</a><ul>
<li><a class="reference internal" href="#id1">Shapes</a></li>
<li><a class="reference internal" href="#simulation-shapes-and-scene-query-shapes">Simulation Shapes and Scene Query Shapes</a></li>
<li><a class="reference internal" href="#trigger-shapes">Trigger Shapes</a></li>
<li><a class="reference internal" href="#kinematic-triangle-meshes-planes-heighfields">Kinematic triangle meshes (planes, heighfields)</a></li>
<li><a class="reference internal" href="#geometries">Geometries</a><ul>
<li><a class="reference internal" href="#spheres">Spheres</a></li>
<li><a class="reference internal" href="#capsules">Capsules</a></li>
<li><a class="reference internal" href="#boxes">Boxes</a></li>
<li><a class="reference internal" href="#planes">Planes</a></li>
<li><a class="reference internal" href="#convex-meshes">Convex Meshes</a></li>
<li><a class="reference internal" href="#height-fields">Height Fields</a></li>
<li><a class="reference internal" href="#triangle-meshes">Triangle Meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mesh-scaling">Mesh Scaling</a></li>
<li><a class="reference internal" href="#pxgeometryholder">PxGeometryHolder</a></li>
<li><a class="reference internal" href="#detaching-shapes">Detaching Shapes</a></li>
<li><a class="reference internal" href="#shape-vertex-and-triangle-queries">Shape Vertex and Triangle Queries</a><ul>
<li><a class="reference internal" href="#id2">Convex Meshes</a></li>
<li><a class="reference internal" href="#id3">Triangle Meshes</a></li>
<li><a class="reference internal" href="#id4">Height Fields</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="ScenesAndActors.html"
                        title="previous chapter">Scenes, Materials, and Actors</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Joints.html"
                        title="next chapter">Joints</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Joints.html" title="Joints"
             >next</a></li>
        <li class="right" >
          <a href="ScenesAndActors.html" title="Scenes, Materials, and Actors"
             >previous</a> |</li>
        <li><a href="../Index.html">NVIDIA PhysX SDK Documentation</a> &raquo;</li>
          <li><a href="Index.html" >User's Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2012 NVIDIA Corporation, 2701 San Tomas Expressway, Santa Clara, CA 95050 U.S.A. All rights reserved.
    </div>
  </body>
</html>